{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Master model development\n",
    "\n",
    "## John Brandt\n",
    "\n",
    "### Last updated: November 1 2019"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "*  Package loading\n",
    "*  Hyperparameter definitions\n",
    "*  Additional layer definitions\n",
    "*  Model definition\n",
    "*  Data loading\n",
    "*  Data preprocessing\n",
    "*  K means clustering\n",
    "*  Augment training data\n",
    "*  Loss definition\n",
    "*  Equibatch creation\n",
    "*  Model training\n",
    "*  Model validation and sanity checks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using TensorFlow backend.\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "WARNING:tensorflow:From /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/framework/op_def_library.py:263: colocate_with (from tensorflow.python.framework.ops) is deprecated and will be removed in a future version.\n",
      "Instructions for updating:\n",
      "Colocations handled automatically by placer.\n"
     ]
    }
   ],
   "source": [
    "#TODO Remove imports that aren't needed to save RAM\n",
    "from tqdm import tqdm_notebook, tnrange\n",
    "import tensorflow as tf\n",
    "\n",
    "sess = tf.Session()\n",
    "from keras import backend as K\n",
    "K.set_session(sess)\n",
    "\n",
    "import keras\n",
    "from tensorflow.python.keras.layers import *\n",
    "from tensorflow.python.keras.layers import ELU\n",
    "from keras.losses import binary_crossentropy\n",
    "from tensorflow.python.ops import array_ops\n",
    "from tensorflow.python.keras.layers import Conv2D, Lambda, Dense, Multiply, Add\n",
    "\n",
    "import tensorflow.contrib.slim as slim\n",
    "from tensorflow.contrib.slim import conv2d\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from random import shuffle\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "import os\n",
    "import itertools\n",
    "from tflearn.layers.conv import global_avg_pool\n",
    "from tensorflow.contrib.framework import arg_scope\n",
    "from keras.regularizers import l1\n",
    "from tensorflow.layers import batch_normalization\n",
    "from tensorflow.python.util import deprecation as deprecation\n",
    "deprecation._PRINT_DEPRECATION_WARNINGS = False\n",
    "\n",
    "os.environ['KMP_DUPLICATE_LIB_OK']='True'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ../src/zoneout.py\n",
    "%run ../src/convgru.py\n",
    "%run ../src/lovasz.py\n",
    "%run ../src/utils.py\n",
    "%run ../src/adabound.py\n",
    "%run ../src/slope.py"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hyperparameter definitions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "539 135\n"
     ]
    }
   ],
   "source": [
    "ZONE_OUT_PROB = 0.10 #(0.05, 0.20, 0.05) --> 4\n",
    "L2_REG = 0.0 #(1-e6, 1-e1, x10) --> 5\n",
    "INITIAL_LR = 2e-6 #(1e-6, 1e-3, x5) --> 10\n",
    "FINAL_LR = 2e-4 # (1e - 5, 1e-2, x5) --> 10\n",
    "BN_MOMENTUM = 0.9 # --> 3\n",
    "BATCH_SIZE = 4 # -->4\n",
    "TRAIN_RATIO = 0.8\n",
    "TEST_RATIO = 0.2\n",
    "\n",
    "\n",
    "AUGMENTATION_RATIO = 4\n",
    "IMAGE_SIZE = 16\n",
    "existing = [int(x[:-4]) for x in os.listdir('../data/final/') if \".DS\" not in x]\n",
    "N_SAMPLES = len(existing)\n",
    "\n",
    "LABEL_SIZE = 14\n",
    "\n",
    "    \n",
    "TRAIN_SAMPLES = int((N_SAMPLES * AUGMENTATION_RATIO) * TRAIN_RATIO)\n",
    "TEST_SAMPLES = int((N_SAMPLES * AUGMENTATION_RATIO) - TRAIN_SAMPLES)\n",
    "print(TRAIN_SAMPLES // AUGMENTATION_RATIO, N_SAMPLES - (TRAIN_SAMPLES // AUGMENTATION_RATIO))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Additional layer definitions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "def conv_bn_elu(inp, is_training, kernel_size, scope, filter_count = 16):\n",
    "    if kernel_size == 3:\n",
    "        padded = ReflectionPadding2D((1, 1,))(inp)\n",
    "        padding = 'valid'\n",
    "    else:\n",
    "        padded = inp\n",
    "        padding = 'same'\n",
    "    conv = Conv2D(filters = filter_count, kernel_size = (kernel_size, kernel_size),\n",
    "                      padding = padding, kernel_regularizer=reg)(padded)\n",
    "    elu = ELU()(conv)\n",
    "    bn = Batch_Normalization(elu, training=is_training, scope = scope + \"bn\")\n",
    "    return bn\n",
    "    \n",
    "\n",
    "def upconv2d(X, filters, is_training, scope):\n",
    "    X = tf.image.resize_images(X, [X.shape[1]*2, X.shape[2]*2],\n",
    "                               method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)\n",
    "    X = conv_bn_elu(X, is_training, 3, scope, filter_count = filters)\n",
    "    return X\n",
    "\n",
    "    \n",
    "def create_deconv_init(filter_size, num_channels):\n",
    "    bilinear_kernel = np.zeros([filter_size, filter_size], dtype=np.float32)\n",
    "    scale_factor = (filter_size + 1) // 2\n",
    "    if filter_size % 2 == 1:\n",
    "        center = scale_factor - 1\n",
    "    else:\n",
    "        center = scale_factor - 0.5\n",
    "    for x in range(filter_size):\n",
    "        for y in range(filter_size):\n",
    "            bilinear_kernel[x,y] = (1 - abs(x - center) / scale_factor) * \\\n",
    "                                   (1 - abs(y - center) / scale_factor)\n",
    "    weights = np.zeros((filter_size, filter_size, num_channels, num_channels))\n",
    "    for i in range(num_channels):\n",
    "        weights[:, :, i, i] = bilinear_kernel\n",
    "\n",
    "    #assign numpy array to constant_initalizer and pass to get_variable\n",
    "    bilinear_init = tf.constant_initializer(value=weights, dtype=tf.float32)\n",
    "    return bilinear_init\n",
    "\n",
    "\n",
    "def get_deconv2d(inp, filter_count, num_channels, scope, is_training):\n",
    "    bilinear_init = create_deconv_init(4, filter_count)\n",
    "    x = tf.keras.layers.Conv2DTranspose(filters = filter_count, kernel_size = (4, 4),\n",
    "                                        strides=(2, 2), padding='same', \n",
    "                                        kernel_initializer = bilinear_init)(inp)\n",
    "    x = ELU()(x)\n",
    "    x = Batch_Normalization(x, training=is_training, scope = scope + \"bn\")\n",
    "    return x\n",
    "\n",
    "\n",
    "def Batch_Normalization(x, training, scope):\n",
    "    return batch_normalization(inputs=x, \n",
    "                               momentum = BN_MOMENTUM, \n",
    "                               training=training,\n",
    "                               renorm = True,\n",
    "                               reuse=None,\n",
    "                               name = scope)\n",
    "\n",
    "    \n",
    "\n",
    "def gau(x_low_level, x_high_level, scope, is_training, filter_count, uptype, size = 4):\n",
    "    \"\"\"\n",
    "    The global attention upsample to replace the up_cat_conv element\n",
    "    \"\"\"\n",
    "    print(x_low_level.shape)\n",
    "    print(x_high_level.shape)\n",
    "    low_feat = conv_bn_elu(x_low_level, is_training, 3, 'gauforward' + scope, filter_count)\n",
    "    high_gap = tf.keras.layers.GlobalAveragePooling2D()(x_high_level)\n",
    "    high_feat = tf.keras.layers.Dense(filter_count, activation='linear', use_bias=False)(high_gap)\n",
    "    high_feat = ELU()(high_feat)\n",
    "    high_feat = Batch_Normalization(high_feat, training=is_training, scope = scope + \"bn_highfeat\")\n",
    "    high_feat = tf.keras.layers.Reshape((1, 1, -1))(high_feat)\n",
    "    high_feat_gate = tf.keras.layers.UpSampling2D((size, size))(high_feat)\n",
    "    gated_low = tf.keras.layers.multiply([low_feat, high_feat_gate])\n",
    "    gated_low = conv_bn_elu(gated_low, is_training, 3, 'gauforward5' + scope, filter_count)\n",
    "    if uptype == \"upconv\":\n",
    "        gated_high = upconv2d(gated_low, filter_count, is_training, scope + \"conv\")\n",
    "    elif uptype == \"transpose\":\n",
    "        bilinear_init = create_deconv_init(4, filter_count)\n",
    "        gated_high = tf.keras.layers.Conv2DTranspose(filters = filter_count, kernel_size = (4, 4),\n",
    "                                             strides=(2, 2), padding='same', \n",
    "                                                     kernel_initializer = bilinear_init)(gated_low)\n",
    "        gated_high = ELU()(gated_high)\n",
    "        gated_high = Batch_Normalization(gated_high, training=is_training, scope = scope + \"bn_gatedhigh\")\n",
    "    high_clamped = conv_bn_elu(x_high_level, is_training, 3, 'gauforward1' + scope, filter_count)\n",
    "    return tf.keras.layers.add([gated_high, high_clamped])\n",
    "\n",
    "\n",
    "def attention(inputs, attention_size, time_major=False, return_alphas=False):\n",
    "    if isinstance(inputs, tuple):\n",
    "        # In case of Bi-RNN, concatenate the forward and the backward RNN outputs.\n",
    "        inputs = tf.concat(inputs, 2)\n",
    "\n",
    "    if time_major:\n",
    "        # (T,B,D) => (B,T,D)\n",
    "        inputs = tf.array_ops.transpose(inputs, [1, 0, 2])\n",
    "\n",
    "    hidden_size = inputs.shape[2].value  # D value - hidden size of the RNN layer\n",
    "\n",
    "    # Trainable parameters\n",
    "    w_omega = tf.Variable(tf.random_normal([hidden_size, attention_size], stddev=0.1))\n",
    "    b_omega = tf.Variable(tf.random_normal([attention_size], stddev=0.1))\n",
    "    u_omega = tf.Variable(tf.random_normal([attention_size], stddev=0.1))\n",
    "\n",
    "    with tf.name_scope('v'):\n",
    "        # Applying fully connected layer with non-linear activation to each of the B*T timestamps;\n",
    "        #  the shape of `v` is (B,T,D)*(D,A)=(B,T,A), where A=attention_size\n",
    "        v = tf.tanh(tf.tensordot(inputs, w_omega, axes=1) + b_omega)\n",
    "\n",
    "    # For each of the timestamps its vector of size A from `v` is reduced with `u` vector\n",
    "    vu = tf.tensordot(v, u_omega, axes=1, name='vu')  # (B,T) shape\n",
    "    alphas = tf.nn.softmax(vu, name='alphas')         # (B,T) shape\n",
    "\n",
    "    # Output of (Bi-)RNN is reduced with attention vector; the result has (B,D) shape\n",
    "    output = tf.reduce_sum(inputs * tf.expand_dims(alphas, -1), 1)\n",
    "\n",
    "    if not return_alphas:\n",
    "        return output\n",
    "    else:\n",
    "        return output, alphas"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def cse_block(prevlayer, prefix):\n",
    "    mean = Lambda(lambda xin: K.mean(xin, axis=[1, 2]))(prevlayer)\n",
    "    lin1 = Dense(K.int_shape(prevlayer)[3] // 2, name=prefix + 'cse_lin1', activation='relu')(mean)\n",
    "    lin2 = Dense(K.int_shape(prevlayer)[3], name=prefix + 'cse_lin2', activation='sigmoid')(lin1)\n",
    "    x = Multiply()([prevlayer, lin2])\n",
    "    return x\n",
    "\n",
    "\n",
    "def sse_block(prevlayer, prefix):\n",
    "    # Bug? Should be 1 here?\n",
    "    conv = Conv2D(K.int_shape(prevlayer)[3], (1, 1), padding=\"same\", kernel_initializer=\"he_normal\",\n",
    "                  activation='sigmoid', strides=(1, 1),\n",
    "                  name=prefix + \"_conv\")(prevlayer)\n",
    "    conv = Multiply(name=prefix + \"_mul\")([prevlayer, conv])\n",
    "    return conv\n",
    "\n",
    "\n",
    "def csse_block(x, prefix):\n",
    "    '''\n",
    "    Implementation of Concurrent Spatial and Channel ‘Squeeze & Excitation’ in Fully Convolutional Networks\n",
    "    https://arxiv.org/abs/1803.02579\n",
    "    '''\n",
    "    cse = cse_block(x, prefix)\n",
    "    sse = sse_block(x, prefix)\n",
    "    x = Add(name=prefix + \"_csse_mul\")([cse, sse])\n",
    "\n",
    "    return x\n",
    "\n",
    "class ReflectionPadding2D(Layer):\n",
    "    def __init__(self, padding=(1, 1), **kwargs):\n",
    "        self.padding = tuple(padding)\n",
    "        self.input_spec = [InputSpec(ndim=4)]\n",
    "        super(ReflectionPadding2D, self).__init__(**kwargs)\n",
    "\n",
    "    def compute_output_shape(self, s):\n",
    "        \"\"\" If you are using \"channels_last\" configuration\"\"\"\n",
    "        return (s[0], s[1] + 2 * self.padding[0], s[2] + 2 * self.padding[1], s[3])\n",
    "\n",
    "    def call(self, x, mask=None):\n",
    "        w_pad,h_pad = self.padding\n",
    "        return tf.pad(x, [[0,0], [h_pad,h_pad], [w_pad,w_pad], [0,0] ], 'REFLECT')\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Down block shape: (?, 4, 4, 24)\n",
      "Copy 1 SHape: (?, 16, 16, 24)\n",
      "Copy 2 SHape: (?, 8, 8, 24)\n",
      "(?, 4, 4, 24)\n",
      "(?, 8, 8, 24)\n",
      "Up block conv 1 shape: (?, 8, 8, 24)\n",
      "(?, 8, 8, 24)\n",
      "(?, 16, 16, 24)\n",
      "Up block conv 1 shape: (?, 16, 16, 12)\n",
      "(?, 14, 14, 1)\n"
     ]
    }
   ],
   "source": [
    "reg = keras.regularizers.l2(L2_REG)\n",
    "inp = tf.placeholder(tf.float32, shape=(None, 24, IMAGE_SIZE, IMAGE_SIZE, 14))\n",
    "length = tf.placeholder(tf.int32, shape = (None, 1))\n",
    "labels = tf.placeholder(tf.float32, shape=(None, 14, 14))#, 1))\n",
    "alpha = tf.placeholder(tf.float32, shape = (None))\n",
    "\n",
    "length2 = tf.reshape(length, (-1,))\n",
    "is_training = tf.placeholder_with_default(False, (), 'is_training')\n",
    "    \n",
    "FILTER_SIZE = IMAGE_SIZE\n",
    "\n",
    "down_16 = 12\n",
    "down_8 = 24\n",
    "\n",
    "up_8 = 24\n",
    "up_16 = 12\n",
    "\n",
    "def down_block(inp, length, size, flt, scope, train):\n",
    "    with tf.variable_scope(scope):\n",
    "        cell_fw = ConvGRUCell(shape = size, filters = flt,\n",
    "                           kernel = [3, 3], normalize = True)\n",
    "        cell_bw = ConvGRUCell(shape = size, filters = flt,\n",
    "                           kernel = [3, 3], normalize = True)\n",
    "        cell_fw = ZoneoutWrapper(\n",
    "           cell_fw, zoneout_drop_prob = ZONE_OUT_PROB, is_training = train)\n",
    "        cell_bw = ZoneoutWrapper(\n",
    "            cell_bw, zoneout_drop_prob = ZONE_OUT_PROB, is_training = train)\n",
    "        output, final_state = convGRU(inp, cell_fw, cell_bw, length)\n",
    "        final_state = tf.concat(final_state, axis = -1)\n",
    "        output = tf.concat(output, axis = -1)\n",
    "        final_state = conv_bn_elu(final_state, train, 3, scope, filter_count = flt*2)\n",
    "        down = MaxPool2D(pool_size = (2, 2))(final_state)\n",
    "    return down, final_state\n",
    "\n",
    "\n",
    "def down_block_no_gru(inp, flt, scope, train):\n",
    "    with tf.variable_scope(scope):\n",
    "        #padded = ReflectionPadding2D((1, 1))(inp)\n",
    "        \n",
    "        # Conv block 1\n",
    "        x = conv_bn_elu(inp, is_training, 3, scope + \"_1\", filter_count = flt)\n",
    "        x = conv_bn_elu(x, is_training, 3, scope + \"_2\", filter_count = flt)\n",
    "        x = csse_block(x, prefix='csse_block_{}'.format(scope))\n",
    "        down = MaxPool2D(pool_size = (2, 2))(x)\n",
    "        print(\"Down block shape: {}\".format(down.shape))\n",
    "    return down, x\n",
    "\n",
    "\n",
    "def up_block(inp, concat_inp, flt, sq, scope, concat, is_training, uptype, padding = True):\n",
    "    with tf.variable_scope(scope):\n",
    "        x = gau(inp, concat_inp, scope, is_training, flt, uptype, inp.shape[-2])\n",
    "        x = csse_block(x, prefix='csse_block_{}'.format(scope))\n",
    "        print(\"Up block conv 1 shape: {}\".format(x.shape))\n",
    "        return x\n",
    "        \n",
    "        \n",
    "# Down block - 16 - 8\n",
    "down_1, copy_1 = down_block(inp = inp, \n",
    "                            length = length2, \n",
    "                            size = [FILTER_SIZE, FILTER_SIZE], \n",
    "                            flt = down_16, \n",
    "                            scope = 'down_16', \n",
    "                            train = is_training)\n",
    "\n",
    "# Down block - 8 - 4\n",
    "down_2, copy_2 = down_block_no_gru(down_1, down_8, 'down_8', is_training)\n",
    "\n",
    "# Feature pyramid attention block - 4 - 4\n",
    "#down_fpa = fpa(down_2, down_8)\n",
    "#print(\"Down FPA SHape: {}\".format(down_fpa.shape))\n",
    "print(\"Copy 1 SHape: {}\".format(copy_1.shape))\n",
    "\n",
    "print(\"Copy 2 SHape: {}\".format(copy_2.shape))\n",
    "\n",
    "\n",
    "\n",
    "# Up block 4 - 8\n",
    "up_3 = up_block(inp = down_2,\n",
    "                concat_inp = copy_2, \n",
    "                flt = up_8, \n",
    "                sq = up_8,\n",
    "                scope = 'up_8', \n",
    "                concat = True, \n",
    "                is_training = is_training, \n",
    "                uptype = \"transpose\", \n",
    "                padding =  True) # 4 - 8\n",
    "\n",
    "# Up block 8 - 16\n",
    "up_2 = up_block(inp = up_3,\n",
    "                concat_inp = copy_1,\n",
    "                flt = up_16, \n",
    "                sq = up_16, \n",
    "                scope = 'up_16',\n",
    "                concat = True, \n",
    "                is_training = is_training,\n",
    "                uptype = \"transpose\",\n",
    "                padding = True) # 8 - 16\n",
    "\n",
    "# Down block 16 - 14\n",
    "up_2 = Conv2D(filters = 32, kernel_size = (3, 3), padding = 'valid')(up_2)\n",
    "elu = ELU()(up_2)\n",
    "bn = Batch_Normalization(elu, training=is_training, scope =  \"conv32_bn\")\n",
    "\n",
    "\n",
    "# Final conv block, with concatenation of DEM Slope\n",
    "#slope = tf.reshape(inp[:, 0, 1:15, 1:15, -1], (-1, 14, 14, 1))\n",
    "#up_2 = tf.concat([bn, slope], axis = -1)\n",
    "up_2 = conv_bn_elu(bn, is_training, 3, \"final_out\", filter_count = 32)\n",
    "\n",
    "#B = tf.Variable([-np.log(0.99/0.01)]) \n",
    "init = tf.constant_initializer([-np.log(0.99/0.01)]) # For focal loss\n",
    "fm = Conv2D(filters = 1,\n",
    "            kernel_size = (1, 1), \n",
    "            padding = 'valid',\n",
    "            activation = 'sigmoid',\n",
    "            bias_initializer = init, # For focal loss\n",
    "            )(up_2)\n",
    "print(fm.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This model has 83319 parameters\n"
     ]
    }
   ],
   "source": [
    "total_parameters = 0\n",
    "for variable in tf.trainable_variables():\n",
    "    shape = variable.get_shape()\n",
    "    variable_parameters = 1\n",
    "    for dim in shape:\n",
    "        variable_parameters *= dim.value\n",
    "    total_parameters += variable_parameters\n",
    "print(\"This model has {} parameters\".format(total_parameters))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data loading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "df = pd.read_csv(\"../data/subplot.csv\")\n",
    "df1 = pd.read_csv(\"../data/subplot2.csv\")\n",
    "df2 = pd.read_csv(\"../data/subplot3.csv\")\n",
    "df3 = pd.read_csv(\"../data/subplot4.csv\")\n",
    "\n",
    "df = df.drop('IMAGERY_TITLE', axis = 1).dropna(axis = 0)\n",
    "df1 = df1.drop('IMAGERY_TITLE', axis = 1).dropna(axis = 0)\n",
    "df2 = df2.drop('IMAGERY_TITLE', axis = 1).dropna(axis = 0)\n",
    "df3 = df3.drop('IMAGERY_TITLE', axis = 1).dropna(axis = 0)\n",
    "\n",
    "lens = [len(x) for x in [df, df1, df2, df3]]\n",
    "\n",
    "df = pd.concat([df, df1, df2, df3], ignore_index = True)\n",
    "df = df.dropna(axis = 0)\n",
    "\n",
    "existing = [int(x[:-4]) for x in os.listdir('../data/correct_dem/') if \".DS\" not in x]\n",
    "N_SAMPLES = len(existing)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b16013646a764831a2a3c4ec1916f1c8",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=682), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Finished data loading\n"
     ]
    }
   ],
   "source": [
    "df = df[df['PLOT_ID'].isin(existing)]\n",
    "N_SAMPLES = int(df.shape[0]/196)\n",
    "N_YEARS = 1\n",
    "\n",
    "plot_ids = sorted(df['PLOT_ID'].unique())\n",
    "#weight = np.load(\"weights.npy\")\n",
    "#weight = dict(zip(plot_ids, weight))\n",
    "#\n",
    "def reconstruct_images(plot_id):\n",
    "    subs = df[df['PLOT_ID'] == plot_id]\n",
    "    rows = []\n",
    "    lats = reversed(sorted(subs['LAT'].unique()))\n",
    "    for i, val in enumerate(lats):\n",
    "        subs_lat = subs[subs['LAT'] == val]\n",
    "        subs_lat = subs_lat.sort_values('LON', axis = 0)\n",
    "        rows.append(list(subs_lat['TREE']))\n",
    "    return rows\n",
    "\n",
    "data = [reconstruct_images(x) for x in plot_ids]\n",
    "\n",
    "# Initiate empty lists to store the X and Y data in\n",
    "data_x, data_y, lengths = [], [], []\n",
    "\n",
    "# Iterate over each plot\n",
    "for i in tnrange(len(plot_ids)):\n",
    "    # Load the sentinel imagery\n",
    "    for year in [\"correct_dem\"]:  \n",
    "        x = np.load(\"../data/\" + year + \"/\" + str(plot_ids[i]) + \".npy\")\n",
    "        x = ndvi(x, image_size = 16)\n",
    "        x = evi(x, image_size = 16)\n",
    "        x = savi(x, image_size = 16)\n",
    "        x = remove_blank_steps(x)\n",
    "        y = reconstruct_images(plot_ids[i])\n",
    "        x[:, :, :, 10] /= 90\n",
    "        lengths.append(x.shape[0])\n",
    "        if x.shape[0] < 24:\n",
    "            padding = np.zeros((24 - x.shape[0], IMAGE_SIZE, IMAGE_SIZE, 14))\n",
    "            x = np.concatenate((x, padding), axis = 0)\n",
    "        data_x.append(x)\n",
    "        data_y.append(y)\n",
    "print(\"Finished data loading\")\n",
    "\n",
    "data_x = np.stack(data_x)\n",
    "data_y = np.stack(data_y)\n",
    "lengths = np.stack(lengths)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.8164800855848524"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.max(data_x[:, :, :, :, 10])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data preprocessing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The outliers are: [7, 45, 141, 195, 225, 292, 324, 327, 487, 497, 519, 549, 601, 610, 652, 661, 7, 195, 225, 318, 487, 497, 634, 661], totalling 24\n",
      "\n",
      "\n",
      "[-6.321969935282787, -4.535834700871396, -27.47112805642772, -5.6786949197057535, -1.3754885005227688, -1.8062032684100147, -1.993483055138996, -4.530147022565086, -1.294937577395239, -738.3066513950349, -1.3696066436832348, -7.680050306753378, -5.0765703897432335, -4.257098714871306, -4.458718742819538, -1191.1332383574356] [5.0, 5.0, 5.0, 5.0, 5.0, 4291.504339112331, 5.0, 144.11851966358546]\n",
      "The data has been scaled to [0.0, 1.0]\n"
     ]
    }
   ],
   "source": [
    "below_1 = [i for i, val in enumerate(data_x) if np.min(val) < -1.05]\n",
    "above_1 = [i for i, val in enumerate(data_x) if np.max(val) > 1.05]\n",
    "min_vals = [np.min(val) for i, val in enumerate(data_x) if np.min(val) < -1.05]\n",
    "max_vals = [np.max(val) for i, val in enumerate(data_x) if np.max(val) > 1.05]\n",
    "outliers = below_1 + above_1\n",
    "print(\"The outliers are: {}, totalling {}\".format(outliers, len(outliers)))\n",
    "print(\"\\n\")\n",
    "print(min_vals, max_vals)\n",
    "data_x = data_x[[x for x in range(0, len(data_x)) if x not in outliers]]\n",
    "data_y = data_y[[x for x in range(0, len(data_y)) if x not in outliers]]\n",
    "lengths = lengths[[x for x in range(0, len(lengths)) if x not in outliers]]\n",
    "\n",
    "min_all = []\n",
    "max_all = []\n",
    "for x in range(0, data_x.shape[-1]):\n",
    "    mins, maxs = (np.min(data_x[:, :, :, :, x]), np.max(data_x[:, :, :, :, x]))\n",
    "    min_all.append(mins)\n",
    "    max_all.append(maxs)\n",
    "    \n",
    "    data_x[:, :, :, :, x] = (data_x[:, :, :, :, x] - mins) / (maxs - mins)\n",
    "    \n",
    "print(\"The data has been scaled to [{}, {}]\".format(np.min(data_x), np.max(data_x)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The region sample distribution is [196, 131, 154, 183]\n",
      "664\n"
     ]
    }
   ],
   "source": [
    "plot_ids2 = [val for x, val in enumerate(plot_ids) if x not in list(set([x for x in outliers]))]\n",
    "#plot_ids2[ordering[460]//4] \n",
    "N_SAMPLES = len(data_x)\n",
    "\n",
    "region_lengths = []\n",
    "for x in [df1, df2, df3]:\n",
    "    subs = [i for i in set(x['PLOT_ID']) if i in plot_ids2]\n",
    "    region_lengths.append(len(subs))\n",
    "    \n",
    "region_lengths = [N_SAMPLES - sum(region_lengths)] + region_lengths\n",
    "    #print(len(x[x['PLOT_ID'] in plot_ids2]))\n",
    "\n",
    "print(\"The region sample distribution is {}\".format(region_lengths))\n",
    "print(sum(region_lengths))\n",
    "train_ordering = []\n",
    "test_ordering = []\n",
    "ordering = []\n",
    "total_samples = 0\n",
    "for r in TRAIN_RATIO, TEST_RATIO:\n",
    "    for i, val in enumerate(region_lengths):\n",
    "        start = int(np.sum(region_lengths[:i]))\n",
    "        end = start + val\n",
    "        if r == 0.8:\n",
    "            start = start\n",
    "            end = end-((end-start)*(1-r))\n",
    "            start = int(start)\n",
    "            end = int(end)\n",
    "            total_samples += (end - start)\n",
    "            train_ordering += [x for x in range(start, end)]\n",
    "        if r == 0.2:\n",
    "            start = start + ((end-start)*(1-r))\n",
    "            end = end\n",
    "            start = int(start)\n",
    "            end = int(end)\n",
    "            total_samples += (end-start)\n",
    "            test_ordering += [x for x in range(start, end)]\n",
    "\n",
    "ordering = train_ordering + test_ordering\n",
    "\n",
    "data_x = data_x[ordering]\n",
    "data_y = data_y[ordering]\n",
    "lengths = lengths[ordering]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# K Means clustering"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "KMeans(algorithm='auto', copy_x=True, init='k-means++', max_iter=300,\n",
       "       n_clusters=6, n_init=10, n_jobs=None, precompute_distances='auto',\n",
       "       random_state=50, tol=0.0001, verbose=0)"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from sklearn.cluster import KMeans\n",
    "\n",
    "NONZERO_CLUSTERS = 10\n",
    "ZERO_CLUSTERS = 6\n",
    "\n",
    "kmeans = KMeans(n_clusters=NONZERO_CLUSTERS, random_state = 50)\n",
    "kmeans_zero = KMeans(n_clusters = ZERO_CLUSTERS, random_state = 50)\n",
    "unaugmented = [x for x in range(0, len(data_y))]\n",
    "zeros = [x for x in unaugmented if np.sum(data_y[x]) == 0]\n",
    "nonzero = [x for x in unaugmented if x not in zeros]\n",
    "kmeans.fit(data_y[nonzero, :, :].reshape((len(nonzero), 14*14)))\n",
    "kmeans_zero.fit(np.mean(data_x[zeros, :, :], axis = 1).reshape((len(zeros), 16*16*14)))             "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "def multiplot(matrices):\n",
    "    '''Plot multiple heatmaps with subplots'''\n",
    "    fig, axs = plt.subplots(ncols=4)\n",
    "    fig.set_size_inches(20, 4)\n",
    "    for i, matrix in enumerate(matrices):\n",
    "        sns.heatmap(data = matrix, ax = axs[i], vmin = 0, vmax = 0.9)\n",
    "        axs[i].set_xlabel(\"\")\n",
    "        axs[i].set_ylabel(\"\")\n",
    "        axs[i].set_yticks([])\n",
    "        axs[i].set_xticks([])\n",
    "    plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[64, 66, 109, 110, 132, 148, 161, 220, 238, 260, 273, 278, 307, 364, 410, 425, 462, 485, 487, 491, 516, 529, 548, 611, 638]\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import random \n",
    "samples_x = [val for x, val in enumerate(nonzero) if kmeans.labels_[x] == 1]\n",
    "print(samples_x)\n",
    "randoms = random.sample(samples_x, 4)\n",
    "randoms = [data_y[x] for x in randoms]\n",
    "randoms = [x.reshape((14, 14)) for x in randoms]\n",
    "multiplot(randoms)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "def balance_data(data_y, labels, labels2, unaugmented = unaugmented):\n",
    "    ids = {}\n",
    "    # Loop over the nonzero clusters\n",
    "    for i in range(0, NONZERO_CLUSTERS):\n",
    "        tmp = [val for x, val in enumerate(nonzero) if labels[x] == i]\n",
    "        ids[i] = tmp\n",
    "    # Loop over the zero clusters\n",
    "    for i in range(0, ZERO_CLUSTERS):\n",
    "        tmp = [val for x, val in enumerate(zeros) if labels2[x] == i]\n",
    "        ids[i + 10] = tmp\n",
    "    #ids[10] = zeros\n",
    "    return ids\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The 664 samples have been balanced between the sampling sites\n"
     ]
    }
   ],
   "source": [
    "ids = balance_data(data_y, kmeans.labels_, kmeans_zero.labels_ )\n",
    "items = [v for k, v in ids.items()]\n",
    "items = [item for sublist in items for item in sublist]\n",
    "print(\"The {} samples have been balanced between the sampling sites\".format(len(items)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "11 3 14\n",
      "20 5 25\n",
      "33 9 42\n",
      "8 2 10\n",
      "81 21 102\n",
      "7 2 9\n",
      "176 44 220\n",
      "1 1 2\n",
      "12 3 15\n",
      "12 3 15\n",
      "28 7 35\n",
      "5 2 7\n",
      "31 8 39\n",
      "26 7 33\n",
      "38 10 48\n",
      "38 10 48\n"
     ]
    }
   ],
   "source": [
    "train_ids = []\n",
    "test_ids = []\n",
    "for i in ids:\n",
    "    ln = len(ids[i])\n",
    "    train_len = int(np.floor([ln * TRAIN_RATIO]))\n",
    "    test_len = ln - train_len\n",
    "    print(train_len, test_len, ln)\n",
    "    trains = ids[i][:train_len]\n",
    "    tests = ids[i][train_len:]\n",
    "    train_ids += trains\n",
    "    test_ids += tests\n",
    "    \n",
    "train_labels = []\n",
    "for i in train_ids:\n",
    "    train_labels.append([k for k, v in ids.items() if i in v][0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train and test characteristics:\n",
      "Train mean Y 25.857685009487668\n",
      "Test mean Y 28.35036496350365\n",
      "Train number with zero trees 33.2\n",
      "Test number with zero trees 35.2\n",
      "Train mean NDVI\n",
      "Test mean NDVI\n",
      "There are 527 train and 137 test samples\n",
      "There is 0 overlap between train and test\n"
     ]
    }
   ],
   "source": [
    "print(\"Train and test characteristics:\")\n",
    "print(\"Train mean Y {}\".format(np.mean([np.sum(x) for x in data_y[train_ids]])))\n",
    "print(\"Test mean Y {}\".format(np.mean([np.sum(x) for x in data_y[test_ids]])))\n",
    "print(\"Train number with zero trees {}\".format(0.2*len([x for x in data_y[train_ids] if np.sum(x) == 0])))\n",
    "print(\"Test number with zero trees {}\".format(0.8*len([x for x in data_y[test_ids] if np.sum(x) == 0])))\n",
    "print(\"Train mean NDVI\")\n",
    "print(\"Test mean NDVI\")\n",
    "print(\"There are {} train and {} test samples\".format(len(train_ids), len(test_ids)))\n",
    "print(\"There is {} overlap between train and test\".format(len([x for x in train_ids if x in test_ids])))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Augment training data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [],
   "source": [
    "data_x_augmented = []\n",
    "data_y_augmented = []\n",
    "lengths_augmented = []\n",
    "labels_augmented = []\n",
    "for i, val in enumerate(train_ids):\n",
    "    data_x_augmented.append(data_x[val])\n",
    "    data_y_augmented.append(data_y[val])\n",
    "    lengths_augmented.append(data_x[val].shape[0])\n",
    "    labels_augmented.append(train_labels[i])\n",
    "    \n",
    "    x1 = np.flip(data_x[val], 1)\n",
    "    y1 = np.flip(data_y[val], 0)\n",
    "    lengths_augmented.append(x1.shape[0])\n",
    "    labels_augmented.append(train_labels[i])\n",
    "    data_x_augmented.append(x1)\n",
    "    data_y_augmented.append(y1)\n",
    "    \n",
    "    x1 = np.flip(data_x[val], [2, 1])\n",
    "    y1 = np.flip(data_y[val], [1, 0])\n",
    "    lengths_augmented.append(x1.shape[0])\n",
    "    labels_augmented.append(train_labels[i])\n",
    "    data_x_augmented.append(x1)\n",
    "    data_y_augmented.append(y1)\n",
    "    \n",
    "    x1 = np.flip(data_x[val], 2)\n",
    "    y1 = np.flip(data_y[val], 1)\n",
    "    lengths_augmented.append(x1.shape[0])\n",
    "    labels_augmented.append(train_labels[i])\n",
    "    data_x_augmented.append(x1)\n",
    "    data_y_augmented.append(y1)\n",
    "\n",
    "train_x = np.stack(data_x_augmented)\n",
    "train_y = np.stack(data_y_augmented)\n",
    "train_y = np.reshape(train_y, (train_y.shape[0], 14, 14, 1))\n",
    "train_l = np.stack(lengths_augmented)\n",
    "train_l = np.reshape(train_l, (train_y.shape[0], 1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [],
   "source": [
    "test_x = data_x[test_ids]\n",
    "test_y = data_y[test_ids]\n",
    "test_lengths = lengths[test_ids]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "RANDOM TRAIN SAMPLES - SHOULD BE AUGMENTED\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"RANDOM TRAIN SAMPLES - SHOULD BE AUGMENTED\")\n",
    "multiplot([x.reshape(14, 14) for x in train_y[:4]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "RANDOM TEST SAMPLES - SHOULD BE NOT AUGMENTED\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "print(\"RANDOM TEST SAMPLES - SHOULD BE NOT AUGMENTED\")\n",
    "multiplot([x.reshape(14, 14) for x in test_y[:4]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Loss definition"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [],
   "source": [
    "import math\n",
    "def dice_loss(y_true, y_pred):\n",
    "    smooth = 1.\n",
    "    y_true_f = K.flatten(y_true)\n",
    "    y_pred_f = K.flatten(y_pred)\n",
    "    intersection = y_true_f * y_pred_f\n",
    "    score = (2. * K.sum(intersection) + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n",
    "    return 1. - score\n",
    "\n",
    "def smooth_jaccard(y_true, y_pred, smooth=1):\n",
    "    y_true = tf.reshape(y_true, (-1, 14*14))\n",
    "    y_pred = tf.reshape(y_pred, (-1, 14*14))\n",
    "    intersection = K.sum(K.abs(y_true * y_pred), axis=-1)\n",
    "    sum_ = K.sum(K.abs(y_true) + K.abs(y_pred), axis=-1)\n",
    "    jac = (intersection + smooth) / (sum_ - intersection + smooth)\n",
    "    return (1 - jac) * smooth\n",
    "\n",
    "\n",
    "def focal_loss_fixed(y_true, y_pred, gamma = 2., alpha = 0.5):\n",
    "    y_true = tf.reshape(y_true, (-1, 14*14, 1))\n",
    "    y_pred = tf.reshape(y_pred, (-1, 14*14, 1))\n",
    "    y_pred = K.clip(y_pred, 1e-8, 1-1e-8)\n",
    "    pt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))\n",
    "    pt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))\n",
    "    epsilon = K.epsilon()\n",
    "        # clip to prevent NaN's and Inf's\n",
    "    pt_1 = K.clip(pt_1, epsilon, 1. - epsilon)\n",
    "    pt_0 = K.clip(pt_0, epsilon, 1. - epsilon)\n",
    "    loss = -K.mean(alpha * 1 * K.log(K.epsilon()+pt_1)) - K.mean((1-alpha) * K.pow( pt_0, gamma) * K.log(1. - pt_0 + K.epsilon()))\n",
    "    return 2 * tf.reduce_mean(loss)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.losses import binary_crossentropy\n",
    "\n",
    "def bce_lovasz(y_true, y_pred):\n",
    "    foc_losses = []\n",
    "    y_true_r = tf.reshape(y_true, (-1, 14, 14, 1))\n",
    "    '''\n",
    "    for i in range(BATCH_SIZE):\n",
    "        y_true_i = tf.reshape(y_true_r[i, :, :, :], (1, 14, 14, 1))\n",
    "        y_pred_i = tf.reshape(y_pred[i, :, :, :], (1, 14, 14, 1))\n",
    "        alpha = (1 - K.clip((tf.reduce_sum(y_true_i)/196), 0.33, 0.67))\n",
    "        gamma = (-tf.math.log(alpha))/2\n",
    "        focal_loss = focal_loss_fixed(y_true_i, y_pred_i, gamma = gamma, alpha = alpha)\n",
    "        foc_losses.append(focal_loss)\n",
    "    foc_losses = tf.concat(foc_losses, axis = 0)'''\n",
    "    loss1 = binary_crossentropy(y_true, y_pred)\n",
    "    lv = lovasz_softmax(y_pred, tf.reshape(y_true, (-1, 14, 14)), classes=[1], per_image=True)\n",
    "    loss = loss1 + 0.25*lv\n",
    "    #lovasz =  0.5*lovasz_softmax(tf.reshape(y_pred, (-1, 14, 14)), y_true, classes=[1], per_image=True) +\n",
    "    return loss"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Equibatch creation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.0\n",
      "0.0\n",
      "0.0\n",
      "0.0\n",
      "1.0\n",
      "5.0\n",
      "10.0\n",
      "15.0\n",
      "23.0\n",
      "31.0\n",
      "41.0\n",
      "63.0\n",
      "124.0\n"
     ]
    }
   ],
   "source": [
    "for i in range(0, 100, 8):\n",
    "    print(np.percentile([np.sum(x) for x in train_y], i))\n",
    "    \n",
    "train_ids = [x for x in range(0, len(train_y))]\n",
    "\n",
    "def equibatch(train_ids, lovasz = False):\n",
    "    first_len = 5\n",
    "    second_len = 9\n",
    "    third_len = 14\n",
    "    np.random.shuffle(train_ids)\n",
    "    ix = train_ids\n",
    "    percs = [np.sum(x) for x in train_y[ix]]\n",
    "    zero_ids = [x for x, z in zip(ix, percs) if z == 0]\n",
    "    one_ids = [x for x, z in zip(ix, percs) if 0 < z <= first_len]\n",
    "    two_ids = [x for x, z in zip(ix, percs) if first_len < z <= second_len]\n",
    "    three_ids = [x for x, z in zip(ix, percs) if second_len < z <= third_len]\n",
    "    four_ids = [x for x, z in zip(ix, percs) if third_len < z <= 19]\n",
    "    five_ids = [x for x, z in zip(ix, percs) if 19 < z < 27]\n",
    "    six_ids = [x for x, z in zip(ix, percs) if 27 < z <= 33]\n",
    "    seven_ids = [x for x, z in zip(ix, percs) if 33 < z <= 41]\n",
    "    eight_ids = [x for x, z in zip(ix, percs) if 41 < z <= 56]\n",
    "    nine_ids =  [x for x, z in zip(ix, percs) if 56 < z <= 80]\n",
    "    ten_ids =  [x for x, z in zip(ix, percs) if 80 < z <= 120]\n",
    "    eleven_ids = [x for x, z in zip(ix, percs) if 120 < z]\n",
    "    #ten_ids = [x for x, z in zip(ix, percs) if 125 < z]\n",
    "    \n",
    "    \n",
    "\n",
    "    all_ids = [x for x in [zero_ids, one_ids, two_ids, three_ids, four_ids, five_ids, six_ids,\n",
    "              seven_ids, eight_ids, nine_ids, ten_ids, eleven_ids]]\n",
    "    \n",
    "    new_batches = []\n",
    "    maxes = [len(zero_ids), len(one_ids), len(two_ids), len(three_ids), len(four_ids),\n",
    "             len(five_ids), len(six_ids), len(seven_ids), len(eight_ids), len(nine_ids), len(ten_ids), len(eleven_ids)]#, len(ten_ids)]\n",
    "    cur_ids = [0] * 12\n",
    "    iter_len = len(train_ids)// 16\n",
    "    for i in range(0, iter_len):\n",
    "        random_ids = np.random.randint(0, 12, 3)\n",
    "        for i, val in enumerate(cur_ids):\n",
    "            if val > maxes[i] - 5:\n",
    "                cur_ids[i] = 0\n",
    "        if cur_ids[0] >= (maxes[0] - 2):\n",
    "            cur_ids[0] = 0\n",
    "        to_append = [zero_ids[cur_ids[0]], zero_ids[cur_ids[0] + 1], one_ids[cur_ids[1]], two_ids[cur_ids[2]],\n",
    "                    three_ids[cur_ids[3]], four_ids[cur_ids[4]], five_ids[cur_ids[5]],\n",
    "                    six_ids[cur_ids[6]], seven_ids[cur_ids[7]], eight_ids[cur_ids[8]],\n",
    "                               nine_ids[cur_ids[9]], ten_ids[cur_ids[10]], eleven_ids[cur_ids[11]],\n",
    "                    all_ids[random_ids[0]][cur_ids[random_ids[0]]+1],\n",
    "                     all_ids[random_ids[1]][cur_ids[random_ids[1]]+1],\n",
    "                     all_ids[random_ids[2]][cur_ids[random_ids[2]]]+1]\n",
    "        np.random.shuffle(to_append)\n",
    "        new_batches.append(to_append)\n",
    "        cur_ids = [x + 1 for x in cur_ids]\n",
    "        cur_ids[0] += 1\n",
    "        for x in random_ids:\n",
    "            cur_ids[x] += 1\n",
    "        \n",
    "    new_batches = [item for sublist in new_batches for item in sublist]\n",
    "    #overlap = [x for x in new_batches if x in test_ids]\n",
    "    #print(\"There is {} overlap. Error if > 0\".format(len(overlap)))\n",
    "    return new_batches"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "batch = equibatch(train_ids, 32)\n",
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[:4]]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[4:8]]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[8:12]]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model training"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting model with: \n",
      " 0.1 zone out \n",
      " 0.0 l2 \n",
      " 2e-06 initial LR \n",
      " 0.0002 final LR \n",
      " 83319 parameters\n",
      "Restarting training from scratch on 2108 train and 137 test samples, total 664\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "c3c4312a0da741bb9479db48de9f7573",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=131), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-30-273ea443efa5>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     45\u001b[0m                                              \u001b[0mlength\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mtrain_l\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mbatch_ids\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m-\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m1\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     46\u001b[0m                                              \u001b[0mlabels\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mbatch_y\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 47\u001b[0;31m                                              \u001b[0mis_training\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     48\u001b[0m                                              })\n\u001b[1;32m     49\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36mrun\u001b[0;34m(self, fetches, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m    927\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    928\u001b[0m       result = self._run(None, fetches, feed_dict, options_ptr,\n\u001b[0;32m--> 929\u001b[0;31m                          run_metadata_ptr)\n\u001b[0m\u001b[1;32m    930\u001b[0m       \u001b[0;32mif\u001b[0m \u001b[0mrun_metadata\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    931\u001b[0m         \u001b[0mproto_data\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtf_session\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTF_GetBuffer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrun_metadata_ptr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_run\u001b[0;34m(self, handle, fetches, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m   1150\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mfinal_fetches\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mfinal_targets\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mhandle\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mfeed_dict_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1151\u001b[0m       results = self._do_run(handle, final_targets, final_fetches,\n\u001b[0;32m-> 1152\u001b[0;31m                              feed_dict_tensor, options, run_metadata)\n\u001b[0m\u001b[1;32m   1153\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1154\u001b[0m       \u001b[0mresults\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_do_run\u001b[0;34m(self, handle, target_list, fetch_list, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m   1326\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mhandle\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1327\u001b[0m       return self._do_call(_run_fn, feeds, fetches, targets, options,\n\u001b[0;32m-> 1328\u001b[0;31m                            run_metadata)\n\u001b[0m\u001b[1;32m   1329\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1330\u001b[0m       \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_do_call\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_prun_fn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeeds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetches\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_do_call\u001b[0;34m(self, fn, *args)\u001b[0m\n\u001b[1;32m   1332\u001b[0m   \u001b[0;32mdef\u001b[0m \u001b[0m_do_call\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1333\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1334\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1335\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0merrors\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOpError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1336\u001b[0m       \u001b[0mmessage\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcompat\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mas_text\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_run_fn\u001b[0;34m(feed_dict, fetch_list, target_list, options, run_metadata)\u001b[0m\n\u001b[1;32m   1317\u001b[0m       \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_extend_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1318\u001b[0m       return self._call_tf_sessionrun(\n\u001b[0;32m-> 1319\u001b[0;31m           options, feed_dict, fetch_list, target_list, run_metadata)\n\u001b[0m\u001b[1;32m   1320\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1321\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_prun_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_call_tf_sessionrun\u001b[0;34m(self, options, feed_dict, fetch_list, target_list, run_metadata)\u001b[0m\n\u001b[1;32m   1405\u001b[0m     return tf_session.TF_SessionRun_wrapper(\n\u001b[1;32m   1406\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_session\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_list\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1407\u001b[0;31m         run_metadata)\n\u001b[0m\u001b[1;32m   1408\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1409\u001b[0m   \u001b[0;32mdef\u001b[0m \u001b[0m_call_tf_sessionprun\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "FRESH_START = True\n",
    "FINE_TUNE = False\n",
    "\n",
    "BATCH_SIZE = 16\n",
    "print(\"Starting model with: \\n {} zone out \\n {} l2 \\n {} initial LR \\n {} final LR \\n {} parameters\"\n",
    "     .format(ZONE_OUT_PROB, L2_REG, INITIAL_LR, FINAL_LR, total_parameters))\n",
    "best_val = 0.270\n",
    "if not FRESH_START:\n",
    "    print(\"Resuming training with a best validation score of {}\".format(best_val))\n",
    "if FRESH_START:\n",
    "    print(\"Restarting training from scratch on {} train and {} test samples, total {}\".format(len(train_ids), len(test_ids), N_SAMPLES))\n",
    "    optimizer = tf.train.AdamOptimizer(2e-4, epsilon = 1e-4)\n",
    "    optimizer = tf.contrib.estimator.clip_gradients_by_norm(optimizer, clip_norm=0.05)\n",
    "    \n",
    "    train_loss = focal_loss_fixed(tf.reshape(labels, (-1, 14, 14, 1)), fm, alpha = 0.4, gamma = 1.5)\n",
    "    test_loss = binary_crossentropy(tf.reshape(labels, (-1, 14, 14, 1)), fm)\n",
    "    l2_loss = tf.losses.get_regularization_loss()\n",
    "    train_loss += l2_loss\n",
    "    update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS)\n",
    "    \n",
    "    with tf.control_dependencies(update_ops):\n",
    "        train_op = optimizer.minimize(train_loss)   \n",
    "\n",
    "    init_op = tf.global_variables_initializer()\n",
    "    sess.run(init_op)\n",
    "    saver = tf.train.Saver(max_to_keep = 2)\n",
    "\n",
    "# Run training loop\n",
    "for i in range(0, 200):\n",
    "    BATCH_SIZE = 16\n",
    "    op = train_op\n",
    "    loss = train_loss\n",
    "    randomize = equibatch(train_ids, 32)\n",
    "    test_ids = [x for x in range(0, len(test_x))]\n",
    "\n",
    "    losses = []\n",
    "    val_loss = []\n",
    "    \n",
    "    for k in tnrange(int(len(train_ids) // BATCH_SIZE)):\n",
    "        batch_ids = randomize[k*BATCH_SIZE:(k+1)*BATCH_SIZE]\n",
    "        batch_y = train_y[batch_ids, :, :].reshape(len(batch_ids), 14, 14)\n",
    "        if sum(sum(sum(batch_y))) > 0:\n",
    "            opt, tr = sess.run([op, loss],\n",
    "                                  feed_dict={inp: train_x[batch_ids, :, :, :],\n",
    "                                             length: train_l[batch_ids].reshape((-1, 1)),\n",
    "                                             labels: batch_y,\n",
    "                                             is_training: True,\n",
    "                                             })\n",
    " \n",
    "        else:\n",
    "            print(\"Skipping minibatch for equibatch reasons\")\n",
    "        losses.append(tr)\n",
    "    for j in range(len(test_ids) // 8):\n",
    "        batch_ids = test_ids[j*8:(j+1)*8]\n",
    "        vl, y = sess.run([test_loss, fm], \n",
    "                         feed_dict={inp: test_x[batch_ids, :, :, :],\n",
    "                                    length: test_lengths[batch_ids].reshape((-1, 1)),\n",
    "                                    labels: test_y[batch_ids, :, :].reshape(8, 14, 14),\n",
    "                                    is_training: False,\n",
    "                                    })\n",
    "        val_loss.append(np.mean(vl))\n",
    "        \n",
    "    tps, fps, fns = [], [], []\n",
    "    for m in test_ids:\n",
    "        y = sess.run([fm], feed_dict={inp: test_x[m, :, :, :].reshape(1, 24, 16, 16, 14),\n",
    "                                  length: test_lengths[m].reshape(1, 1),\n",
    "                                  is_training: False,\n",
    "                                  })[0]\n",
    "        true = test_y[m].reshape((LABEL_SIZE, LABEL_SIZE))\n",
    "        pred = y.reshape((14, 14))\n",
    "        pred[np.where(pred > 0.4)] = 1\n",
    "        pred[np.where(pred < 0.4)] = 0\n",
    "        tp, fp, fn = thirty_meter(true, pred)\n",
    "        tps.append(tp)\n",
    "        fps.append(fp)\n",
    "        fns.append(fn)\n",
    "        \n",
    "    precision = np.sum(tps) / (np.sum(tps) + np.sum(fps))\n",
    "    recall = np.sum(tps) / (np.sum(tps) + np.sum(fns))\n",
    "    if np.mean(val_loss) < best_val:\n",
    "        best_val = np.mean(val_loss)\n",
    "        print(\"Saving model with {}\".format(best_val))\n",
    "        save_path = saver.save(sess, \"../models/equibatch26/model\")\n",
    "    print(\"Epoch {}: Loss {} Val: {} P {} R {} F1 {} iou {}\".format(i + 1,\n",
    "                                                             np.mean(losses), np.mean(val_loss),\n",
    "                                                             precision, recall, 'hey', \"hey\"))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model validation and sanity checks\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "start = 0\n",
    "test_ids = [x for x in range(0, len(test_x))]\n",
    "\n",
    "def multiplot(matrices, nrows = 2, ncols = 4):\n",
    "    '''Plot multiple heatmaps with subplots'''\n",
    "    fig, axs = plt.subplots(ncols=4, nrows = nrows)\n",
    "    fig.set_size_inches(20, 4*nrows)\n",
    "    to_iter = [[x for x in range(i, i + ncols + 1)] for i in range(0, nrows*ncols, ncols)]\n",
    "    for r in range(1, nrows + 1):\n",
    "        min_i = min(to_iter[r-1])\n",
    "        max_i = max(to_iter[r-1])\n",
    "        for i, matrix in enumerate(matrices[min_i:max_i]):\n",
    "            sns.heatmap(data = matrix, ax = axs[r - 1, i], vmin = 0, vmax = 0.9)\n",
    "            axs[r - 1, i].set_xlabel(\"\")\n",
    "            axs[r - 1, i].set_ylabel(\"\")\n",
    "            axs[r - 1, i].set_yticks([])\n",
    "            axs[r - 1, i].set_xticks([])\n",
    "    plt.show()\n",
    "start = 0\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.46715328467153283\n",
      "64\n",
      "65\n",
      "66\n",
      "67\n",
      "68\n",
      "69\n",
      "70\n",
      "71\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x576 with 16 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "import random \n",
    "\n",
    "    \n",
    "test_losses = []\n",
    "print(start/len(test_ids))\n",
    "test_ids = sorted(test_ids)\n",
    "matrix_ids = [test_ids[start], test_ids[start + 1], test_ids[start + 2], test_ids[start + 3],\n",
    "              test_ids[start + 4], test_ids[start + 5], test_ids[start + 6], test_ids[start + 7]]\n",
    "#matrix_ids = random.sample(test_ids, 4)\n",
    "\n",
    "preds = []\n",
    "trues = []\n",
    "for i in matrix_ids:\n",
    "    idx = i\n",
    "    print(i)\n",
    "    y = sess.run([fm], feed_dict={inp: test_x[idx].reshape(1, 24, IMAGE_SIZE, IMAGE_SIZE, 14),\n",
    "                                  length: test_lengths[idx].reshape(1, 1),\n",
    "                                  is_training: False,\n",
    "                                  })\n",
    "    y = np.array(y).reshape(14, 14)\n",
    "    preds.append(y)\n",
    "    true = test_y[idx].reshape(LABEL_SIZE, LABEL_SIZE)\n",
    "    trues.append(true)\n",
    "    \n",
    "\n",
    "to_plot = trues[0:4] + preds[0:4]# + trues[5:] + preds[5:]\n",
    "multiplot(to_plot, nrows = 2, ncols = 4)\n",
    "#plot_ids[ordering[976]//4] \n",
    "start = start + 4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_ids2 = [val for x, val in enumerate(plot_ids) if x not in list(set([x // 4 for x in outliers]))]\n",
    "plot_ids2[ordering[460]//4] "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Calculate ROC for best threshold selection"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "\n",
    "\n",
    "for j in range(4, 18):\n",
    "    tps = []\n",
    "    fps = []\n",
    "    fns = []\n",
    "    for i in test_ids:\n",
    "        y = sess.run([fm], feed_dict={inp: data_x[i].reshape(1, 24, 16, 16, 14),\n",
    "                                  length: lengths[i].reshape(1, 1),\n",
    "                                  is_training: False,\n",
    "                                  })[0]\n",
    "        true = data_y[i].reshape((14, 14))\n",
    "        pred = y.reshape((14, 14))\n",
    "        pred[np.where(pred > j*0.05)] = 1\n",
    "        pred[np.where(pred < j*0.05)] = 0\n",
    "        tp, fp, fn = thirty_meter(true, pred)\n",
    "        tps.append(tp)\n",
    "        fps.append(fp)\n",
    "        fns.append(fn)\n",
    "        \n",
    "    precision = np.sum(tps) / (np.sum(tps) + np.sum(fps))\n",
    "    recall = np.sum(tps) / (np.sum(tps) + np.sum(fns))\n",
    "    print(j*0.05, precision, recall)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## TODO @jombrandt top 10 worst training, test samples by IOU \n",
    "\n",
    "These should be written to a tmp/ .txt file and indexed by validate-data.ipynb to ensure that original classifications were correct, and to identify regions that need more training data."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "policy-toolkit",
   "language": "python",
   "name": "policy-toolkit"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
