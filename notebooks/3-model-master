{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tree segmentation with multitemporal Sentinel 1/2 imagery\n",
    "\n",
    "## John Brandt\n",
    "## April 02, 2020\n",
    "\n",
    "## Overview\n",
    "\n",
    "This notebook contains the TensorFlow model training and prediction used to segment trees for [Restoration Mapper](https://restorationmapper.org). The notebook uses tensorflow 1.13.1 and additionally relies on Keras and tflearn. \n",
    "\n",
    "## Table of Contents\n",
    "\n",
    "- Package loading\n",
    "- Utility scripts\n",
    "- Hyperparameter definitions\n",
    "- Custom tensorflow layer functions\n",
    "- Tensorflow graph creation\n",
    "- Data loading\n",
    "- Data preprocessing\n",
    "- Equibatch creation\n",
    "- Loss definition\n",
    "- Tensorflow graph initialization\n",
    "- Training\n",
    "- Model validation\n",
    "- Sanity Checks\n",
    "\n",
    "## Package Loading"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "Using TensorFlow backend.\n"
     ]
    }
   ],
   "source": [
    "from tqdm import tqdm_notebook, tnrange\n",
    "import tensorflow as tf\n",
    "#import tensorflow_probability as tfp\n",
    "\n",
    "\n",
    "sess = tf.Session()\n",
    "from keras import backend as K\n",
    "K.set_session(sess)\n",
    "\n",
    "from time import sleep\n",
    "\n",
    "import keras\n",
    "from tensorflow.python.keras.layers import *\n",
    "from tensorflow.python.keras.layers import ELU\n",
    "from keras.losses import binary_crossentropy\n",
    "from tensorflow.python.ops import array_ops\n",
    "from tensorflow.python.keras.layers import Conv2D, Lambda, Dense, Multiply, Add\n",
    "from tensorflow.initializers import glorot_normal, lecun_normal\n",
    "from scipy.ndimage import median_filter\n",
    "from skimage.transform import resize\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from random import shuffle\n",
    "import pandas as pd\n",
    "\n",
    "import seaborn as sns\n",
    "import matplotlib.pyplot as plt\n",
    "%matplotlib inline\n",
    "import os\n",
    "import random\n",
    "import itertools\n",
    "from tensorflow.contrib.framework import arg_scope\n",
    "from keras.regularizers import l1\n",
    "from tensorflow.layers import batch_normalization\n",
    "from tensorflow.python.util import deprecation as deprecation\n",
    "deprecation._PRINT_DEPRECATION_WARNINGS = False\n",
    "\n",
    "os.environ['KMP_DUPLICATE_LIB_OK']='True'"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Utility scripts"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "%run ../src/layers/zoneout.py\n",
    "%run ../src/layers/convgru.py\n",
    "%run ../src/layers/adabound.py\n",
    "%run ../src/layers/dropblock.py\n",
    "%run ../src/layers/extra_layers.py\n",
    "%run ../src/preprocessing/indices.py\n",
    "%run ../src/preprocessing/slope.py\n",
    "%run ../src/utils/metrics.py\n",
    "%run ../src/not_for_release/lovasz.py"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hyperparameter definitions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "ZONE_OUT_PROB = 0.20 #0.2 for master model\n",
    "GRU_FILTERS = 32\n",
    "FPA_FILTERS = 28\n",
    "OUT_FILTERS = 32\n",
    "AVERAGE_GRU_FILTERS = True\n",
    "ACTIVATION_FUNCTION = 'relu'\n",
    "\n",
    "INITIAL_LR = 1e-4\n",
    "FINAL_LR = 2e-2\n",
    "DROPBLOCK_MAXSIZE = 5\n",
    "DECONV = 'bilinear'\n",
    "N_CONV_BLOCKS = 1\n",
    "FINAL_ALPHA = 0.7\n",
    "LABEL_SMOOTHING = 0.10 #0.075 for master\n",
    "BATCH_RENORM = 'norm'\n",
    "\n",
    "L2_REG = 0.0\n",
    "BN_MOMENTUM = 0.9\n",
    "BATCH_SIZE = 16\n",
    "MAX_DROPBLOCK = 0.85\n",
    "\n",
    "gru_flt = 32\n",
    "fpa_flt = 28\n",
    "out_conv_flt = 32\n",
    "\n",
    "IMAGE_SIZE = 16\n",
    "LABEL_SIZE = 14"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Hyperparameter grid search definitions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# There are 3.8 million combinations of hyperparameters\n",
    "params = {\n",
    "    'zone_out' : [0],#range(0, 0.5, 0.1), #6\n",
    "    'average_gru_filters': [True, False], # 2\n",
    "    'final_lr': [5e-3, 1e-2, 2e-2, 5e-2], # 4\n",
    "    'n_conv_blocks': [3, 2, 1], # 3\n",
    "    'final_alpha': [0.8, 0.75, 0.7, 0.65, 0.6], #5\n",
    "    'label_smoothing': [0., 0.025, 0.05, 0.075, 0.10, 0.125],\n",
    "    'batch_renorm': ['renorm', 'norm']\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Custom layer definitions"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Utility blocks (Batch norm, cSSE, etc.)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "def Batch_Normalization(x, training, scope, clipping_params):\n",
    "    '''Batch renormalization layer from tensorflow.layers\n",
    "\n",
    "         Parameters:\n",
    "          x (tf.Variable): input layer\n",
    "          training (tf.Variable): flag to differentiate between train/test ops\n",
    "          scope (str): tensorflow scope\n",
    "          clipping_params (dict): specifies clipping of \n",
    "                                  rmax, dmax, rmin for renormalization\n",
    "\n",
    "         Returns:\n",
    "          x (tf.Variable): output of batch renormalization\n",
    "          \n",
    "         References:\n",
    "          https://github.com/tensorflow/docs/blob/r1.13/site/en/\n",
    "          api_docs/python/tf/layers/batch_normalization.md\n",
    "    '''\n",
    "    return batch_normalization(inputs=x, \n",
    "                               momentum = BN_MOMENTUM, \n",
    "                               training=training,\n",
    "                               renorm = True,\n",
    "                               reuse=None,\n",
    "                               renorm_clipping = clipping_params,\n",
    "                               name = scope)\n",
    "\n",
    "\n",
    "def calc_renorm_params(epoch, n_samples, batch_size, k = 0):\n",
    "    '''Calculates the clipping parameters for renormalization\n",
    "       based on the learning schedule outlined in the original paper\n",
    "       where rmax is initialized to 1, dmax to 0, rmin to 0,\n",
    "       (effectively batch normalization), and then rmax and dmax\n",
    "       are gradually reaxed to 3 and 5 over 40k and 25k steps,\n",
    "       respectively. In this case, 40k has been reduced to 30k, and 25k\n",
    "       has been reduced to 20k.\n",
    "\n",
    "         Parameters:\n",
    "          epoch (int): number of current training epoch\n",
    "                       if testing, epoch number of model used\n",
    "          n_samples (int): total number of training samples\n",
    "          batch_size (int): training batch size \n",
    "\n",
    "         Returns:\n",
    "          rmax (float)\n",
    "          dmax (float)\n",
    "          rmin (float)\n",
    "    '''\n",
    "    step = epoch * (n_samples // batch_size)\n",
    "    step += k\n",
    "    if step < 2500:\n",
    "        rmax = 1.\n",
    "        dmax = 0.\n",
    "        rmin = 0.\n",
    "    if step >= 2500:\n",
    "        rmax = np.min([1 + 2*((step-2500)/20000), 3])\n",
    "        dmax = np.min([1 + 5*((step-2500)/15000), 5])\n",
    "        rmin = 0.\n",
    "    return rmax, dmax, rmin\n",
    "\n",
    "def cse_block(prevlayer, prefix):\n",
    "    '''Channel excitation and spatial squeeze layer. \n",
    "       Calculates the mean of the spatial dimensions and then learns\n",
    "       two dense layers, one with relu, and one with sigmoid, to rerank the\n",
    "       input channels\n",
    "       \n",
    "         Parameters:\n",
    "          prevlayer (tf.Variable): input layer\n",
    "          prefix (str): prefix for tensorflow scope\n",
    "\n",
    "         Returns:\n",
    "          x (tf.Variable): output of the cse_block\n",
    "    '''\n",
    "    mean = Lambda(lambda xin: K.mean(xin, axis=[1, 2]))(prevlayer)\n",
    "    lin1 = Dense(K.int_shape(prevlayer)[3] // 2, name=prefix + 'cse_lin1', activation='relu')(mean)\n",
    "    lin2 = Dense(K.int_shape(prevlayer)[3], name=prefix + 'cse_lin2', activation='sigmoid')(lin1)\n",
    "    x = Multiply()([prevlayer, lin2])\n",
    "    return x\n",
    "\n",
    "\n",
    "def sse_block(prevlayer, prefix):\n",
    "    '''Spatial excitation and channel squeeze layer.\n",
    "       Calculates a 1x1 convolution with sigmoid activation to create a \n",
    "       spatial map that is multiplied by the input layer\n",
    "\n",
    "         Parameters:\n",
    "          prevlayer (tf.Variable): input layer\n",
    "          prefix (str): prefix for tensorflow scope\n",
    "\n",
    "         Returns:\n",
    "          x (tf.Variable): output of the sse_block\n",
    "    '''\n",
    "    conv = Conv2D(1, (1, 1), padding=\"same\", kernel_initializer=\"glorot_uniform\",\n",
    "                  activation='sigmoid', strides=(1, 1),\n",
    "                  name=prefix + \"_conv\")(prevlayer)\n",
    "    conv = Multiply(name=prefix + \"_mul\")([prevlayer, conv])\n",
    "    return conv\n",
    "\n",
    "\n",
    "def csse_block(x, prefix):\n",
    "    '''Implementation of Concurrent Spatial and Channel \n",
    "       ‘Squeeze & Excitation’ in Fully Convolutional Networks\n",
    "    \n",
    "        Parameters:\n",
    "          prevlayer (tf.Variable): input layer\n",
    "          prefix (str): prefix for tensorflow scope\n",
    "\n",
    "         Returns:\n",
    "          x (tf.Variable): added output of cse and sse block\n",
    "          \n",
    "         References:\n",
    "          https://arxiv.org/abs/1803.02579\n",
    "    '''\n",
    "    cse = cse_block(x, prefix)\n",
    "    sse = sse_block(x, prefix)\n",
    "    x = Add(name=prefix + \"_csse_mul\")([cse, sse])\n",
    "\n",
    "    return x\n",
    "\n",
    "class ReflectionPadding2D(Layer):\n",
    "    def __init__(self, padding=(1, 1), **kwargs):\n",
    "        self.padding = tuple(padding)\n",
    "        self.input_spec = [InputSpec(ndim=4)]\n",
    "        super(ReflectionPadding2D, self).__init__(**kwargs)\n",
    "\n",
    "    def compute_output_shape(self, s):\n",
    "        \"\"\" If you are using \"channels_last\" configuration\"\"\"\n",
    "        return (s[0], s[1] + 2 * self.padding[0], s[2] + 2 * self.padding[1], s[3])\n",
    "\n",
    "    def call(self, x, mask=None):\n",
    "        w_pad,h_pad = self.padding\n",
    "        return tf.pad(x, [[0,0], [h_pad,h_pad], [w_pad,w_pad], [0,0] ], 'REFLECT')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Conv GRU Block"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "def gru_block(inp, length, size, flt, scope, train, normalize = True):\n",
    "    '''Bidirectional convolutional GRU block with \n",
    "       zoneout and CSSE blocks in each time step\n",
    "\n",
    "         Parameters:\n",
    "          inp (tf.Variable): (B, T, H, W, C) layer\n",
    "          length (tf.Variable): (B, T) layer denoting number of\n",
    "                                steps per sample\n",
    "          size (int): kernel size of convolution\n",
    "          flt (int): number of convolution filters\n",
    "          scope (str): tensorflow variable scope\n",
    "          train (tf.Bool): flag to differentiate between train/test ops\n",
    "          normalize (bool): whether to compute layer normalization\n",
    "\n",
    "         Returns:\n",
    "          gru (tf.Variable): (B, H, W, flt*2) bi-gru output\n",
    "          steps (tf.Variable): (B, T, H, W, flt*2) output of each step\n",
    "    '''\n",
    "    with tf.variable_scope(scope):\n",
    "        print(\"GRU input shape {}, zoneout: {}\".format(inp.shape, ZONE_OUT_PROB))\n",
    "        cell_fw = ConvGRUCell(shape = size, filters = flt,\n",
    "                           kernel = [3, 3], padding = 'VALID', normalize = normalize, sse = True)\n",
    "        cell_bw = ConvGRUCell(shape = size, filters = flt,\n",
    "                           kernel = [3, 3], padding = 'VALID', normalize = normalize, sse = True)\n",
    "        cell_fw = ZoneoutWrapper(\n",
    "           cell_fw, zoneout_drop_prob = ZONE_OUT_PROB, is_training = train)\n",
    "        cell_bw = ZoneoutWrapper(\n",
    "            cell_bw, zoneout_drop_prob = ZONE_OUT_PROB, is_training = train)\n",
    "        steps, out = convGRU(inp, cell_fw, cell_bw, length)\n",
    "        gru = tf.concat(out, axis = -1)\n",
    "        steps = tf.concat(steps, axis = -1)\n",
    "        print(\"Down block output shape {}\".format(gru.shape))\n",
    "    return gru, steps"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Conv blocks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "def conv_selu(inp, is_training, kernel_size, scope,\n",
    "                filter_count = 16, pad = True, padding = 'valid', dilated = False,\n",
    "                activation = True):\n",
    "    '''Convolutional 2D layer with SELU activation and Lecun normal initialization\n",
    "       with no batch norm. Only used if params['activation'] = 'selu'\n",
    "\n",
    "         Parameters:\n",
    "          inp (tf.Variable): (B, H, W, C) input layer\n",
    "          is_training (str): flag to differentiate between train/test ops\n",
    "          kernel_size (int): kernel size of convolution\n",
    "          scope (str): tensorflow variable scope\n",
    "          filter_count (int): number of convolution filters\n",
    "          pad (bool): whether or not to reflect pad input\n",
    "          padding (str): one of ['valid', 'same']\n",
    "          dilated (bool): whether to perform atruous convolution\n",
    "          activation (bool): whether to activate output\n",
    "\n",
    "         Returns:\n",
    "          conv (tf.Variable): output of Conv2D -> SELU\n",
    "          \n",
    "         References:\n",
    "          https://arxiv.org/abs/1706.02515\n",
    "    '''\n",
    "    if activation:\n",
    "        act = selu\n",
    "    else:\n",
    "        act = None\n",
    "    if not dilated:\n",
    "        padded = ReflectionPadding2D((1, 1,))(inp)\n",
    "        conv = Conv2D(filters = filter_count, kernel_size = (kernel_size, kernel_size), activation = act,\n",
    "                        padding = padding, kernel_initializer = lecun_normal())(padded)\n",
    "    if not dilated and not pad:\n",
    "        conv = Conv2D(filters = filter_count, kernel_size = (kernel_size, kernel_size), activation = act,\n",
    "                        padding = padding, kernel_initializer = lecun_normal())(inp)\n",
    "    if dilated:\n",
    "        padded = ReflectionPadding2D((2, 2,))(inp)\n",
    "        conv = Conv2D(filters = filter_count, kernel_size = (3, 3), activation = act, dilation_rate = (2, 2),\n",
    "                        padding = padding, kernel_initializer = lecun_normal())(padded)\n",
    "    return conv\n",
    "\n",
    "def conv_bn_relu(inp, \n",
    "                 is_training, \n",
    "                 kernel_size,\n",
    "                 scope,\n",
    "                 filters, \n",
    "                 clipping_params,\n",
    "                 keep_rate,\n",
    "                 stride = (1, 1),\n",
    "                 activation = True,\n",
    "                 use_bias = False,\n",
    "                 batch_norm = True,\n",
    "                 dropblock = True,\n",
    "                 csse = True):\n",
    "    '''2D convolution, batch renorm, relu block, 3x3 drop block. \n",
    "       Use_bias must be set to False for batch normalization to work. \n",
    "       He normal initialization is used with batch normalization.\n",
    "       RELU is better applied after the batch norm.\n",
    "       DropBlock performs best when applied last, according to original paper.\n",
    "\n",
    "         Parameters:\n",
    "          inp (tf.Variable): input layer\n",
    "          is_training (str): flag to differentiate between train/test ops\n",
    "          kernel_size (int): size of convolution\n",
    "          scope (str): tensorflow variable scope\n",
    "          filters (int): number of filters for convolution\n",
    "          clipping_params (dict): specifies clipping of \n",
    "                                  rmax, dmax, rmin for renormalization\n",
    "          activation (bool): whether to apply RELU\n",
    "          use_bias (str): whether to use bias. Should always be false\n",
    "\n",
    "         Returns:\n",
    "          bn (tf.Variable): output of Conv2D -> Batch Norm -> RELU\n",
    "        \n",
    "         References:\n",
    "          http://papers.nips.cc/paper/8271-dropblock-a-regularization-\n",
    "              method-for-convolutional-networks.pdf\n",
    "          https://arxiv.org/abs/1702.03275\n",
    "          \n",
    "    '''\n",
    "    \n",
    "    bn_flag = \"Batch Renorm\" if batch_norm else \"\"\n",
    "    activation_flag = \"RELU\" if activation else \"Linear\"\n",
    "    csse_flag = \"CSSE\" if csse else \"No CSSE\"\n",
    "    bias_flag = \"Bias\" if use_bias else \"NoBias\"\n",
    "    drop_flag = \"DropBlock\" if dropblock else \"NoDrop\"\n",
    "        \n",
    "    \n",
    "    print(\"{} {} Conv 2D {} {} {} {} {}\".format(scope, kernel_size,\n",
    "                                                   bn_flag, activation_flag,\n",
    "                                                   csse_flag, bias_flag, drop_flag))\n",
    "    \n",
    "    with tf.variable_scope(scope + \"_conv\"):\n",
    "        conv = Conv2D(filters = filters, kernel_size = (kernel_size, kernel_size),  strides = stride,\n",
    "                      activation = None, padding = 'valid', use_bias = use_bias,\n",
    "                      kernel_initializer = tf.keras.initializers.he_normal())(inp)\n",
    "    if batch_norm:\n",
    "        conv = Batch_Normalization(conv, is_training, scope, clipping_params)\n",
    "    if activation:\n",
    "        conv = tf.nn.relu(conv)\n",
    "    if csse:\n",
    "        conv = csse_block(conv, 'csse_' + scope)\n",
    "    if dropblock: \n",
    "        with tf.variable_scope(scope + \"_drop\"):\n",
    "            drop_block = DropBlock2D(keep_prob=keep_rate, block_size=4)\n",
    "            conv = drop_block(conv, is_training)\n",
    "    return conv\n",
    "\n",
    "\n",
    "def create_deconv_init(filter_size, num_channels):\n",
    "    '''Initializes a kernel weight matrix with a bilinear deconvolution\n",
    "    \n",
    "         Parameters:\n",
    "          filter_size (int): kernel size of convolution\n",
    "          num_channels (int): number of filters for convolution\n",
    "\n",
    "         Returns:\n",
    "          bilinear_init (tf.Variable): [filter_size, filter_size, num_channels] kernel\n",
    "    '''\n",
    "    bilinear_kernel = np.zeros([filter_size, filter_size], dtype=np.float32)\n",
    "    scale_factor = (filter_size + 1) // 2\n",
    "    if filter_size % 2 == 1:\n",
    "        center = scale_factor - 1\n",
    "    else:\n",
    "        center = scale_factor - 0.5\n",
    "    for x in range(filter_size):\n",
    "        for y in range(filter_size):\n",
    "            bilinear_kernel[x,y] = (1 - abs(x - center) / scale_factor) * \\\n",
    "                                   (1 - abs(y - center) / scale_factor)\n",
    "    weights = np.zeros((filter_size, filter_size, num_channels, num_channels))\n",
    "    for i in range(num_channels):\n",
    "        weights[:, :, i, i] = bilinear_kernel\n",
    "\n",
    "    #assign numpy array to constant_initalizer and pass to get_variable\n",
    "    bilinear_init = tf.constant_initializer(value=weights, dtype=tf.float32)\n",
    "    return bilinear_init\n",
    "\n",
    "def get_deconv2d(inp, filter_count, num_channels, scope, is_training, clipping_params):\n",
    "    '''Creates a deconvolution layer with Conv2DTranspose. Following recent\n",
    "       recommendations to use 4 kernel, 2 stride to avoid artifacts. \n",
    "       Initialize kernel with bilinear upsampling.\n",
    "\n",
    "         Parameters:\n",
    "          inp (tf.Variable): input tensorflow layer (B, X, Y, C) shape\n",
    "          filter_count (int): number of filters for convolution\n",
    "          num_channels (int): number of output channels\n",
    "          scope (str): tensorflow variable scope\n",
    "          is_training (str): flag to differentiate between train/test ops\n",
    "          clipping_params (dict): specifies clipping of \n",
    "                                  rmax, dmax, rmin for renormalization\n",
    "\n",
    "         Returns:\n",
    "          x (tf.Variable): layer with (B, x * 2, y * 2, C) shape\n",
    "          \n",
    "         References:\n",
    "          https://distill.pub/2016/deconv-checkerboard/\n",
    "    '''\n",
    "    bilinear_init = create_deconv_init(4, filter_count)\n",
    "    x = tf.keras.layers.Conv2DTranspose(filters = filter_count, kernel_size = (4, 4),\n",
    "                                        strides=(2, 2), padding='same', \n",
    "                                        use_bias = False,\n",
    "                                        kernel_initializer = bilinear_init)(inp)\n",
    "    #x = ELU()(x)\n",
    "    #x = tf.nn.relu(x)\n",
    "    x = Batch_Normalization(x, training=is_training, scope = scope + \"bn\", clipping_params = clipping_params)\n",
    "    return x"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fpa(inp, is_training, filter_count, clipping_params, \n",
    "        keep_rate, upsample = \"upconv\"):\n",
    "    '''Feature pyramid attention layer block, that allows for cross-scale combination\n",
    "       of different size features without making blurry feature maps.\n",
    "\n",
    "         Parameters:\n",
    "          inp (tf.Variable): input tensorflow layer\n",
    "          is_training (str): flag to differentiate between train/test ops\n",
    "          filter_count (int): number of filters for convolution\n",
    "          clipping_params (dict): specifies clipping of \n",
    "                                  rmax, dmax, rmin for renormalization\n",
    "\n",
    "         Returns:\n",
    "          concat_1 (tf.Variable): output of FPA\n",
    "          \n",
    "         References:\n",
    "          https://arxiv.org/abs/1805.10180\n",
    "    '''\n",
    "    one = conv_bn_relu(inp = inp, is_training = is_training, \n",
    "                       kernel_size = 1, scope =  'forward1',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = False,\n",
    "                       use_bias = False, batch_norm = True,\n",
    "                       dropblock = False,\n",
    "                       csse = False)\n",
    "    inp_pad = ReflectionPadding2D(padding = (2, 2))(inp)\n",
    "    seven = conv_bn_relu(inp = inp_pad, is_training = is_training, \n",
    "                       kernel_size = 5, scope =  'down1', stride = (2, 2),\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True, csse = True, dropblock = False)\n",
    "    seven_pad = ReflectionPadding2D(padding = (2, 2))(seven)\n",
    "    seven_f = conv_bn_relu(inp = seven_pad, is_training = is_training, \n",
    "                       kernel_size = 5, scope =  'down1_f',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = False,\n",
    "                       use_bias = False, batch_norm = True, csse = False, dropblock = False)\n",
    "    \n",
    "    print(\"Seven: {}\".format(seven.shape))\n",
    "    print(\"Seven f: {}\".format(seven_f.shape))\n",
    "    \n",
    "    five_pad = ReflectionPadding2D(padding = (1, 1))(seven)\n",
    "    five = conv_bn_relu(inp = five_pad, is_training = is_training,  stride = (2, 2),\n",
    "                       kernel_size = 3, scope =  'down2',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True, csse = True, dropblock = False)\n",
    "    \n",
    "    five_pad2 = ReflectionPadding2D(padding = (1, 1))(five)\n",
    "    five_f = conv_bn_relu(inp = five_pad2, is_training = is_training, \n",
    "                       kernel_size = 3, scope =  'down2_f',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = False,\n",
    "                       use_bias = False, batch_norm = True, csse = False, dropblock = False)\n",
    "    print(\"Five: {}\".format(five.shape))\n",
    "    print(\"Five_F: {}\".format(five_f.shape))\n",
    "    '''\n",
    "    three_pad = ReflectionPadding2D(padding = (1, 1))(five)\n",
    "    three = conv_bn_relu(inp = three_pad, is_training = is_training,  stride = (2, 2),\n",
    "                       kernel_size = 3, scope =  'down3',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True, csse = True, dropblock = False)\n",
    "    \n",
    "    three_pad2 = ReflectionPadding2D(padding = (1, 1))(three)\n",
    "    three_f = conv_bn_relu(inp = three_pad2, is_training = is_training, \n",
    "                       kernel_size = 3, scope =  'down3_f',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = False,\n",
    "                       use_bias = False, batch_norm = True, csse = True, dropblock = False)\n",
    "        \n",
    "    \n",
    "    if upsample == 'upconv' or 'bilinear':\n",
    "        three_up = tf.keras.layers.UpSampling2D((2, 2), interpolation = 'bilinear')(three_f)\n",
    "        if upsample == 'upconv':\n",
    "            three_up = ReflectionPadding2D((1, 1,))(three_up)\n",
    "            three_up = conv_bn_relu(inp = three_up, is_training = is_training, \n",
    "                       kernel_size = 3, scope =  'upconv1',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True,\n",
    "                       csse = False, dropblock = False)\n",
    "            \n",
    "            # 4x4\n",
    "            three_up = tf.nn.relu(tf.add(three_up, five_f))\n",
    "    '''        \n",
    "    \n",
    "    if upsample == 'upconv' or \"bilinear\":\n",
    "        five_up = tf.keras.layers.UpSampling2D((2, 2), interpolation = 'nearest')(five)\n",
    "        if upsample == 'upconv':\n",
    "            five_up = ReflectionPadding2D((1, 1,))(five_up)\n",
    "            five_up = conv_bn_relu(inp = five_up, is_training = is_training, \n",
    "                       kernel_size = 3, scope =  'upconv2',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True, \n",
    "                       csse = False, dropblock = False)\n",
    "            five_up = tf.nn.relu(tf.add(five_up, seven_f))\n",
    "            \n",
    "    if upsample == 'upconv' or \"bilinear\":\n",
    "        seven_up = tf.keras.layers.UpSampling2D((2, 2), interpolation = 'nearest')(five_up)\n",
    "        if upsample == 'upconv':\n",
    "            seven_up = ReflectionPadding2D((1, 1,))(seven_up)\n",
    "            seven_up = conv_bn_relu(inp = seven_up, is_training = is_training, \n",
    "                       kernel_size = 3, scope =  'upconv3',\n",
    "                       filters = filter_count, clipping_params = clipping_params,\n",
    "                       keep_rate = keep_rate, activation = True,\n",
    "                       use_bias = False, batch_norm = True, \n",
    "                       csse = False, dropblock = False)\n",
    "    \n",
    "    print(\"One: {}\".format(one.shape))\n",
    "    print(\"Five_up: {}\".format(five_up.shape))\n",
    "    print(\"Seven_up: {}\".format(seven_up.shape))\n",
    "    \n",
    "    # top block\n",
    "\n",
    "    #pooled = tf.keras.layers.GlobalAveragePooling2D()(inp)\n",
    "    #one_top = conv_bn_relu(inp = tf.reshape(pooled, (-1, 1, 1, pooled.shape[-1])),\n",
    "    #                       is_training = is_training, \n",
    "    #                   kernel_size = 1, scope =  'topconv',\n",
    "    #                   filters = filter_count, clipping_params = clipping_params,\n",
    "    #                   keep_rate = keep_rate, activation = False,\n",
    "    #                   use_bias = False, batch_norm = True, \n",
    "    #                   csse = False, dropblock = False)\n",
    "    #one_top = conv_bn_relu(tf.reshape(pooled, (-1, 1, 1, pooled.shape[-1])),\n",
    "    ##                      is_training, 1, 'top1', filter_count, pad = False)\n",
    "    #four_top = tf.keras.layers.UpSampling2D((16, 16))(one_top)\n",
    "    \n",
    "    #seven_up = tf.multiply(one, seven_up)\n",
    "    out = tf.nn.relu(tf.multiply(seven_up, one))\n",
    "    return out\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model definition\n",
    "\n",
    "## Placeholders"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_bands = 16 # 16 for master model\n",
    "reg = keras.regularizers.l2(L2_REG) # for GRU\n",
    "inp = tf.placeholder(tf.float32, shape=(None, 12, IMAGE_SIZE, IMAGE_SIZE, n_bands))\n",
    "length = tf.placeholder(tf.int32, shape = (None, 1))\n",
    "labels = tf.placeholder(tf.float32, shape=(None, 14, 14))#, 1))\n",
    "keep_rate = tf.placeholder_with_default(1.0, ()) # For DropBlock\n",
    "length2 = tf.reshape(length, (-1,)) # Remove\n",
    "is_training = tf.placeholder_with_default(False, (), 'is_training') # For BN, DropBlock\n",
    "alpha = tf.placeholder(tf.float32, shape = ()) # For loss scheduling\n",
    "ft_lr = tf.placeholder_with_default(0.001, shape = ()) # For loss scheduling\n",
    "loss_weight = tf.placeholder_with_default(1.0, shape = ())\n",
    "beta_ = tf.placeholder_with_default(0.0, shape = ())\n",
    "\n",
    "\n",
    "inp_median = tf.placeholder(tf.float32, shape = (None, IMAGE_SIZE, IMAGE_SIZE, n_bands))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "rmax = tf.placeholder(tf.float32, shape = ())\n",
    "rmin = tf.placeholder(tf.float32, shape = ())\n",
    "dmax = tf.placeholder(tf.float32, shape = ())\n",
    "\n",
    "clipping_params = {\n",
    "    'rmax': rmax,\n",
    "    'rmin': rmin,\n",
    "    'dmax': dmax\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Layers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "GRU input shape (?, 12, 16, 16, 16), zoneout: 0.2\n",
      "(3, 3, 48, 64)\n",
      "(3, 3, 48, 64)\n",
      "Down block output shape (?, 16, 16, 64)\n",
      "mean 3 Conv 2D Batch Renorm RELU CSSE NoBias DropBlock\n",
      "median1 (?, 16, 16, 32)\n",
      "median (?, 16, 16, 96)\n",
      "mean2 1 Conv 2D Batch Renorm RELU No CSSE NoBias NoDrop\n",
      "median (?, 16, 16, 48)\n",
      "max1 (?, 8, 8, 48)\n",
      "down2 3 Conv 2D Batch Renorm RELU CSSE NoBias DropBlock\n",
      "down2 (?, 6, 6, 64)\n",
      "down2_f 3 Conv 2D Batch Renorm RELU CSSE NoBias DropBlock\n",
      "Down2_f (?, 4, 4, 64)\n",
      "up1 3 Conv 2D Batch Renorm RELU CSSE NoBias DropBlock\n",
      "up1 (?, 8, 8, 96)\n",
      "up2 3 Conv 2D Batch Renorm RELU CSSE NoBias DropBlock\n",
      "up2 (?, 16, 16, 96)\n",
      "outconv2 3 Conv 2D Batch Renorm RELU No CSSE NoBias NoDrop\n",
      "Finzl output shape:  (?, 14, 14, 48)\n",
      "Initializing last sigmoid bias with -2.94 constant\n"
     ]
    }
   ],
   "source": [
    "gru_out, steps = gru_block(inp = inp, length = length2,\n",
    "                            size = [16, 16],\n",
    "                            flt = gru_flt,\n",
    "                            scope = 'down_16',\n",
    "                            train = is_training)\n",
    "\n",
    "median = ReflectionPadding2D((1, 1,))(inp_median)\n",
    "median = conv_bn_relu(inp = median, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 3, scope = 'mean', filters = 32, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = True, dropblock = True)\n",
    "print(\"median1\", median.shape)\n",
    "\n",
    "median = tf.concat([gru_out, median], axis = -1)\n",
    "print(\"median\", median.shape)\n",
    "median = conv_bn_relu(inp = median, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 1, scope = 'mean2', filters = 48, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = False, dropblock = False)\n",
    "\n",
    "print(\"median\", median.shape)\n",
    "\n",
    "#mean_2f = conv_bn_relu(inp = mean_1f, is_training = is_training, stride = (1, 1),\n",
    "#                    kernel_size = 1, scope = 'mean_1f', filters = 64, clipping_params = clipping_params,\n",
    "#                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "#                    csse = False, dropblock = False)\n",
    "\n",
    "max1 = MaxPool2D()(median)\n",
    "print(\"max1\", max1.shape)\n",
    "\n",
    "\n",
    "# Down block 2 (8 - 4)\n",
    "down2 = conv_bn_relu(inp = max1, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 3, scope = 'down2', filters = 64, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = True, dropblock = True)\n",
    "print(\"down2\", down2.shape)\n",
    "down2_f = conv_bn_relu(inp = down2, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 3, scope = 'down2_f', filters = 64, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = True, dropblock = True)\n",
    "print(\"Down2_f\", down2_f.shape)\n",
    "\n",
    "# Upblock 1 (4 - 8)\n",
    "up1 = tf.keras.layers.UpSampling2D((2, 2), interpolation = 'nearest')(down2_f)\n",
    "up1 = ReflectionPadding2D((1, 1,))(up1)\n",
    "up1 = conv_bn_relu(inp = up1, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 3, scope = 'up1', filters = 48, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = True, dropblock = True)\n",
    "up1 = tf.concat([up1, max1], axis = -1)\n",
    "print(\"up1\", up1.shape)\n",
    "\n",
    "\n",
    "# Upblock2 (8 - 16)\n",
    "up2 = tf.keras.layers.UpSampling2D((2, 2), interpolation = 'nearest')(up1)\n",
    "up2 = ReflectionPadding2D((1, 1,))(up2)\n",
    "up2 = conv_bn_relu(inp = up2, is_training = is_training, stride = (1, 1),\n",
    "                    kernel_size = 3, scope = 'up2', filters = 48, clipping_params = clipping_params,\n",
    "                    keep_rate = keep_rate, activation = True, use_bias = False, batch_norm = True,\n",
    "                    csse = True, dropblock = True)\n",
    "up2 = tf.concat([up2, median], axis = -1)\n",
    "print(\"up2\", up2.shape)\n",
    "\n",
    "\n",
    "x = conv_bn_relu(inp = up2,\n",
    "                 is_training = is_training,\n",
    "                 kernel_size = 3,\n",
    "                 scope = \"outconv2\",\n",
    "                 filters = 48,\n",
    "                 clipping_params = clipping_params,\n",
    "                 activation = True,\n",
    "                 keep_rate = keep_rate,\n",
    "                 use_bias = False, dropblock = False,\n",
    "                 batch_norm = True, csse = False)\n",
    "print(\"Finzl output shape: \", x.shape)\n",
    "\n",
    "print(\"Initializing last sigmoid bias with -2.94 constant\")\n",
    "init = tf.constant_initializer([-np.log(0.7/0.3)]) # For focal loss\n",
    "fm = Conv2D(filters = 1,\n",
    "            kernel_size = (1, 1),\n",
    "            padding = 'valid',\n",
    "            activation = 'sigmoid',\n",
    "            bias_initializer = init,\n",
    "           )(x) # For focal loss"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This model has 282934 parameters\n"
     ]
    }
   ],
   "source": [
    "total_parameters = 0\n",
    "for variable in tf.trainable_variables():\n",
    "    shape = variable.get_shape()\n",
    "    variable_parameters = 1\n",
    "    for dim in shape:\n",
    "        variable_parameters *= dim.value\n",
    "    total_parameters += variable_parameters\n",
    "print(\"This model has {} parameters\".format(total_parameters))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Data loading\n",
    "\n",
    "*  Load in CSV data from Collect Earth\n",
    "*  Reconstruct the X, Y grid for the Y data per sample\n",
    "*  Calculate NDVI, EVI, SAVI, BI, MSAVI2, and SI\n",
    "*  Stack X, Y, length data\n",
    "*  Apply median filter to DEM"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/hickle/hickle.py:542: UserWarning: Input argument 'file_obj' appears to be a file made with hickle v3. Using legacy load...\n",
      "  warnings.warn(\"Input argument 'file_obj' appears to be a file made\"\n"
     ]
    }
   ],
   "source": [
    "import hickle as hkl\n",
    "train_x = hkl.load(\"../tile_data/processed/train_x.hkl\")\n",
    "train_y = hkl.load(\"../tile_data/processed/train_y.hkl\")\n",
    "train_l = hkl.load(\"../tile_data/processed/train_l.hkl\")\n",
    "\n",
    "train_x = np.delete(train_x, 14, -1) # test not deleting the SI inde\n",
    "\n",
    "data = pd.read_csv(\"train_plot_ids.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "12abf589badb4633801f43d505e23482",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=4870), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "(4870, 12, 16, 16, 16)\n",
      "4870\n"
     ]
    }
   ],
   "source": [
    "for sample in tnrange(0, len(train_x)):\n",
    "    filtered = median_filter(train_x[sample, 0, :, :, 10], size = 5)\n",
    "    filtered = np.reshape(filtered, (8, 2, 8, 2))\n",
    "    filtered = np.mean(filtered, axis = (1, 3))\n",
    "    filtered = resize(filtered, (16, 16), 0)\n",
    "    train_x[sample, ..., 10] = np.stack([filtered] * 12)\n",
    "    \n",
    "print(train_x.shape)\n",
    "print(len(data))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# Data preprocessing\n",
    "\n",
    "*  Identify and remove samples with time steps / channels that have a 0. or 1. value, which indicates missing data\n",
    "*  Identify and remove samples with time steps / channels with no variation, which indicates missing data\n",
    "*  Identify and remove samples with values above or below the allowable values for the band\n",
    "*  Identify and remove samples with null data, or samples with extreme band 0 data (which squash all the \"clean\" samples)\n",
    "*  Smooth per-pixel temporal data with Whittaker smoother, d = 2, lambda = 0.5 to reduce sample noise"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Removing 42 outlying training data points\n",
      "[3403, 3405, 3407, 3421, 3422, 3638, 3644, 3647, 3672, 3692, 3702, 3703, 3725, 3768, 3770, 3799, 3803, 3878, 3882, 3983, 3984, 4002, 4004, 4008, 4012, 4020, 4025, 4028, 4033, 4040, 4087, 4096, 4121, 4262, 4315, 4339, 4341, 4351, 4520, 4528, 4639, 4657]\n",
      "Removing 25 outlying training data points\n",
      "[237, 1054, 1295, 1535, 1543, 1749, 1812, 1816, 2055, 2105, 2205, 2211, 2617, 2659, 3046, 3052, 3084, 3130, 3345, 3718, 3825, 3845, 3913, 4530, 4793]\n",
      "Removing 19 outlying training data points\n",
      "[631, 752, 916, 947, 965, 984, 1082, 1105, 1335, 1522, 1853, 1992, 2056, 2604, 3036, 3338, 3643, 4420, 4613]\n",
      "(4784, 12, 16, 16, 16)\n"
     ]
    }
   ],
   "source": [
    "below_1 = [i for i, val in enumerate(train_x[..., :10]) if np.min(val) < -2]\n",
    "above_1 = [i for i, val in enumerate(train_x[..., :10]) if np.max(val) > 2]\n",
    "min_vals = [np.min(val) for i, val in enumerate(train_x[..., :10]) if np.min(val) < -1.5]\n",
    "max_vals = [np.max(val) for i, val in enumerate(train_x[..., :10]) if np.max(val) > 1.5]\n",
    "nans = [i for i, val in enumerate(train_x) if np.sum(np.isnan(val)) > 100]\n",
    "oob_vals = [i for i, val in enumerate(train_x) if np.max(val[..., 0]) > 0.7]\n",
    "\n",
    "outliers = below_1 + above_1 + nans + oob_vals\n",
    "outliers = list(set(outliers))\n",
    "print(\"Removing {} outlying training data points\".format(len(outliers)))\n",
    "print(sorted(outliers))\n",
    "train_x = np.delete(train_x, outliers, 0)\n",
    "train_y = np.delete(train_y, outliers, 0)\n",
    "train_l = np.delete(train_l, outliers)\n",
    "data = data.drop(outliers, 0)\n",
    "data.reset_index(inplace = True, drop = True)\n",
    "\n",
    "outliers = [237, 1054, 1295, 1535, 1543, 1749, 1812, 1816, 2055,  2105, 2205, 2211, 2617,\n",
    "            2659, 3046, 3052, 3084, 3130, 3345, 3718, 3825, 3845,  3913, 4530, 4793]\n",
    "\n",
    "print(\"Removing {} outlying training data points\".format(len(outliers)))\n",
    "print(sorted(outliers))\n",
    "train_x = np.delete(train_x, outliers, 0)\n",
    "train_y = np.delete(train_y, outliers, 0)\n",
    "train_l = np.delete(train_l, outliers)\n",
    "data = data.drop(outliers, 0)\n",
    "data.reset_index(inplace = True, drop = True)\n",
    "\n",
    "outliers = [631, 752, 916, 947, 965, 984, 1082, 1105, 1335, 1522, 1853,  1992,\n",
    "            2056, 2604, 3036, 3338, 3643, 4420, 4613]\n",
    "\n",
    "print(\"Removing {} outlying training data points\".format(len(outliers)))\n",
    "print(sorted(outliers))\n",
    "train_x = np.delete(train_x, outliers, 0)\n",
    "train_y = np.delete(train_y, outliers, 0)\n",
    "train_l = np.delete(train_l, outliers)\n",
    "data = data.drop(outliers, 0)\n",
    "data.reset_index(inplace = True, drop = True)\n",
    "\n",
    "outliers = [3605, 3942, 4757]\n",
    "print(\"Removing {} outlying training data points\".format(len(outliers)))\n",
    "print(sorted(outliers))\n",
    "train_x = np.delete(train_x, outliers, 0)\n",
    "train_y = np.delete(train_y, outliers, 0)\n",
    "train_l = np.delete(train_l, outliers)\n",
    "data = data.drop(outliers, 0)\n",
    "data.reset_index(inplace = True, drop = True)\n",
    "\n",
    "print(train_x.shape)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Temporal Smoothing"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "8a22f8872ee24bc18f87708bf44e20ff",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=16), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "The data has been scaled to [-1.0000001192092896, 1.0000001192092896]\n",
      "[0.016768555792030362, 0.031859364002449986, 0.018888066882654337, 0.08300588143157157, 0.04900411763090337, 0.07196114637821546, 0.0790915859490633, 0.08027978003529285, 0.05206992316991091, 0.033226898834616644, 0.0, 0.0029407649199765626, -0.026773188909673434, 0.0032562207477167242, 0.006299999542534351, 4.999999873689376e-05] [0.21292338743805878, 0.29813900702779483, 0.4300807791948318, 0.5124803858995437, 0.4764584118127815, 0.4890428495407102, 0.5156670875445272, 0.5284151314082131, 0.6588925588130947, 0.6016234779357905, 0.37872035768296985, 0.7223387521306766, 0.40211242556571936, 0.6531514992624433, 0.7853250503540039, 0.15389999747276306]\n"
     ]
    }
   ],
   "source": [
    "min_all = [0.016768555792030362,\n",
    " 0.031859364002449986,\n",
    " 0.018888066882654337,\n",
    " 0.08300588143157157,\n",
    " 0.04900411763090337,\n",
    " 0.07196114637821546,\n",
    " 0.0790915859490633,\n",
    " 0.08027978003529285,\n",
    " 0.05206992316991091,\n",
    " 0.033226898834616644,\n",
    " 0.0,\n",
    " 0.0029407649199765626,\n",
    " -0.026773188909673434,\n",
    " 0.0032562207477167242,\n",
    " 0.006299999542534351,\n",
    " 4.999999873689376e-05]\n",
    "\n",
    "max_all = [0.21292338743805878,\n",
    " 0.29813900702779483,\n",
    " 0.4300807791948318,\n",
    " 0.5124803858995437,\n",
    " 0.4764584118127815,\n",
    " 0.4890428495407102,\n",
    " 0.5156670875445272,\n",
    " 0.5284151314082131,\n",
    " 0.6588925588130947,\n",
    " 0.6016234779357905,\n",
    " 0.37872035768296985,\n",
    " 0.7223387521306766,\n",
    " 0.40211242556571936,\n",
    " 0.6531514992624433,\n",
    " 0.7853250503540039,\n",
    " 0.15389999747276306]\n",
    "#\n",
    "#min_all = []\n",
    "#max_all = []\n",
    "#\n",
    "for band in tnrange(0, train_x.shape[-1]):\n",
    "   # mins = np.percentile(train_x[..., band], 1)\n",
    "   # maxs = np.percentile(train_x[..., band], 99)\n",
    "    mins = min_all[band]\n",
    "    maxs = max_all[band]\n",
    "    #print(mins1 - mins, maxs1 - maxs)\n",
    "    train_x[..., band] = np.clip(train_x[..., band], mins, maxs)\n",
    "    midrange = (maxs + mins) / 2\n",
    "    rng = maxs - mins\n",
    "    standardized = (train_x[..., band] - midrange) / (rng / 2)\n",
    "    train_x[..., band] = standardized\n",
    "    \n",
    "    #min_all.append(mins)\n",
    "    #max_all.append(maxs)\n",
    "    \n",
    "print(\"The data has been scaled to [{}, {}]\".format(np.min(train_x), np.max(train_x)))\n",
    "print(min_all, max_all)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Augment training data\n",
    "\n",
    "Horizontal and vertical flips for 4x augmentation.\n",
    "\n",
    "**To do**\n",
    "*  Random guassian noise\n",
    "*  Brightness, contrast\n",
    "*  Region swaps (randomply position positive samples at different locations)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Load and process test data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 284,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1054, 12, 16, 16, 17)\n",
      "(1054, 3)\n",
      "There are 4 outliers: [961, 990, 542, 1022]\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "917f17f2df4044beaae1889721af07ae",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=1032), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The data has been scaled to [-1.0000001192092896, 1.0000001192092896]\n",
      "(1032, 12, 16, 16, 16)\n",
      "(1032, 3)\n"
     ]
    }
   ],
   "source": [
    "test_x = hkl.load(\"../tile_data/processed/test_x.hkl\")\n",
    "test_y = hkl.load(\"../tile_data/processed/test_y.hkl\")\n",
    "test_lengths = hkl.load(\"../tile_data/processed/test_lengths.hkl\")\n",
    "test_data = pd.read_csv(\"test_plot_ids.csv\")\n",
    "print(test_x.shape)\n",
    "print(test_data.shape)\n",
    "\n",
    "test_x = np.delete(test_x, 14, -1)\n",
    "\n",
    "below_1 = [i for i, val in enumerate(test_x[..., :-2]) if np.min(val) < -1.66]\n",
    "above_1 = [i for i, val in enumerate(test_x[..., :-2]) if np.max(val) > 1.66]\n",
    "nans = [i for i, val in enumerate(test_x) if np.sum(np.isnan(val)) > 0]\n",
    "outliers = below_1 + above_1 + nans\n",
    "outliers = list(set(outliers))\n",
    "print(\"There are {} outliers: {}\".format(len(outliers), outliers))\n",
    "\n",
    "test_x = np.delete(test_x, outliers, 0)\n",
    "test_y = np.delete(test_y, outliers, 0)\n",
    "test_lengths = np.delete(test_lengths, outliers, 0)\n",
    "test_data = test_data.drop(outliers, 0)\n",
    "test_data = test_data.reset_index(drop = True)\n",
    "\n",
    "outliers = [516, 870, 887]\n",
    "test_x = np.delete(test_x, outliers, 0)\n",
    "test_y = np.delete(test_y, outliers, 0)\n",
    "test_lengths = np.delete(test_lengths, outliers, 0)\n",
    "test_data = test_data.drop(outliers, 0)\n",
    "test_data = test_data.reset_index(drop = True)\n",
    "\n",
    "outliers = [54, 603, 628, 714, 722, 764, 812, 1024]\n",
    "test_x = np.delete(test_x, outliers, 0)\n",
    "test_y = np.delete(test_y, outliers, 0)\n",
    "test_lengths = np.delete(test_lengths, outliers, 0)\n",
    "test_data = test_data.drop(outliers, 0)\n",
    "test_data = test_data.reset_index(drop = True)\n",
    "\n",
    "outliers = [201,]\n",
    "test_x = np.delete(test_x, outliers, 0)\n",
    "test_y = np.delete(test_y, outliers, 0)\n",
    "test_lengths = np.delete(test_lengths, outliers, 0)\n",
    "test_data = test_data.drop(outliers, 0)\n",
    "test_data = test_data.reset_index(drop = True)\n",
    "\n",
    "\n",
    "outliers = [603, 656, 658, 665, 776, 918, ]\n",
    "test_x = np.delete(test_x, outliers, 0)\n",
    "test_y = np.delete(test_y, outliers, 0)\n",
    "test_lengths = np.delete(test_lengths, outliers, 0)\n",
    "test_data = test_data.drop(outliers, 0)\n",
    "test_data = test_data.reset_index(drop = True)\n",
    "\n",
    "\n",
    "for sample in tnrange(0, len(test_x)):\n",
    "    filtered = median_filter(test_x[sample, 0, :, :, 10], size = 5)\n",
    "    filtered = np.reshape(filtered, (8, 2, 8, 2))\n",
    "    filtered = np.mean(filtered, axis = (1, 3))\n",
    "    filtered = resize(filtered, (16, 16), 0)\n",
    "    test_x[sample, ..., 10] = np.stack([filtered] * 12)\n",
    "    \n",
    "for band in range(0, test_x.shape[-1]):\n",
    "    mins = min_all[band]\n",
    "    maxs = max_all[band]\n",
    "    test_x[..., band] = np.clip(test_x[..., band], mins, maxs)\n",
    "    midrange = (maxs + mins) / 2\n",
    "    rng = maxs - mins\n",
    "    standardized = (test_x[..., band] - midrange) / (rng / 2)\n",
    "    test_x[..., band] = standardized\n",
    "    \n",
    "    \n",
    "print(\"The data has been scaled to [{}, {}]\".format(np.min(test_x), np.max(test_x)))\n",
    "\n",
    "#test_x = np.reshape(test_x, (test_x.shape[0], 12, 2, 16, 16, 16))\n",
    "#test_x = np.mean(test_x, axis = 2)\n",
    "print(test_x.shape)\n",
    "print(test_data.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Train and test characteristics:\n",
      "Train mean Y 69.53104106972302\n",
      "Test STD Y 79.07626160330894\n",
      "Train mean NDVI\n",
      "Test mean NDVI\n"
     ]
    }
   ],
   "source": [
    "print(\"Train and test characteristics:\")\n",
    "print(\"Train mean Y {}\".format(np.mean([np.sum(x) for x in test_y])))\n",
    "print(\"Test STD Y {}\".format(np.std([np.sum(x) for x in test_y])))\n",
    "#print(\"Train number with zero trees {}\".format(0.2*len([x for x in data_y[train_ids] if np.sum(x) == 0])))\n",
    "#print(\"Test number with zero trees {}\".format(0.8*len([x for x in data_y[test_ids] if np.sum(x) == 0])))\n",
    "print(\"Train mean NDVI\")\n",
    "print(\"Test mean NDVI\")\n",
    "#print(\"There are {} train and {} test samples\".format(len(train_ids), len(test_ids)))\n",
    "#print(\"There is {} overlap between train and test\".format(len([x for x in train_ids if x in test_ids])))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Equibatch creation\n",
    "\n",
    "The modelling approach uses equibatch sampling to ensure that there is a near constant standard deviation of the percent tree cover in the output labels for each batch. This helps ensure that the model performs equally well across gradients of tree cover, by mitigating the random possibility that many batches in a row near the end of sampling may be randomly biased towards a tree cover range."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[6.0, 13.0, 22.0, 34.0, 55.7800000000002, 98.0, 168.0, 196.0]\n",
      "There are 914 zeros\n"
     ]
    }
   ],
   "source": [
    "sums = np.sum(train_y, axis = (1, 2))\n",
    "percents = [np.percentile(sums, x) for x in range(30, 100, 9)]\n",
    "print(percents)\n",
    "print(\"There are {} zeros\".format(len(np.argwhere(sums == 0))))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n"
     ]
    }
   ],
   "source": [
    "train_ids = [x for x in range(0, len(train_y))]\n",
    "\n",
    "def multiplot(matrices):\n",
    "    '''Plot multiple heatmaps with subplots\n",
    "    \n",
    "         Parameters:\n",
    "          matrices (list of arrays):\n",
    "\n",
    "         Returns:\n",
    "          None\n",
    "    '''\n",
    "    fig, axs = plt.subplots(ncols=4)\n",
    "    fig.set_size_inches(20, 4)\n",
    "    for i, matrix in enumerate(matrices):\n",
    "        sns.heatmap(data = matrix, ax = axs[i], vmin = 0, vmax = 0.9)\n",
    "        axs[i].set_xlabel(\"\")\n",
    "        axs[i].set_ylabel(\"\")\n",
    "        axs[i].set_yticks([])\n",
    "        axs[i].set_xticks([])\n",
    "\n",
    "def equibatch(train_ids, p = percents):\n",
    "    '''Docstring\n",
    "    \n",
    "         Parameters:\n",
    "          train_ids (list):\n",
    "          p (list):\n",
    "\n",
    "         Returns:\n",
    "          equibatches (list):\n",
    "    '''\n",
    "    percents = [9.0, 19.0, 29.0, 40.0, 64.0, 95.0, 145.0] # sept 28\n",
    "    percents = [9.0, 19.0, 28.0, 40.0, 62.0, 100.0, 155.0] # november\n",
    "   # percents =  [7.0, 13.0, 21.0, 33.0, 50.0, 80.0, 130.0] # overall\n",
    "    #percents = [12.0, 24.0, 42.0, 65.0, 90.0, 125., 170.0] # lac\n",
    "    #percents = [9.0, 19.0, 29.0, 40.0, 55.0, 85.0, 150.0] # east africa\n",
    "    np.random.shuffle(train_ids)\n",
    "    ix = train_ids\n",
    "    percs = [np.sum(x) for x in train_y[ix]]\n",
    "    ids0 = [x for x, z in zip(ix, percs) if z <= 2]\n",
    "    ids30 = [x for x, z in zip(ix, percs) if 2 < z <= percents[0]]\n",
    "    ids40 = [x for x, z in zip(ix, percs) if percents[0] < z <= percents[1]]\n",
    "    ids50 = [x for x, z in zip(ix, percs) if percents[1] < z <= percents[2]]\n",
    "    ids60 = [x for x, z in zip(ix, percs) if percents[2] < z <= percents[3]]\n",
    "    ids70 = [x for x, z in zip(ix, percs) if percents[3] < z <= percents[4]]\n",
    "    ids80 = [x for x, z in zip(ix, percs) if percents[4] < z <= percents[5]]\n",
    "    ids90 = [x for x, z in zip(ix, percs) if percents[5] < z <= percents[6]]\n",
    "    ids100 = [x for x, z in zip(ix, percs) if percents[6] < z]\n",
    "    \n",
    "    new_batches = []\n",
    "    maxes = [len(ids0), len(ids30), len(ids40), len(ids50), len(ids60), len(ids70),\n",
    "             len(ids80), len(ids90), len(ids100)]\n",
    "    print(maxes)\n",
    "    print(sum(maxes))\n",
    "    cur_ids = [0] * len(maxes)\n",
    "    iter_len = len(train_ids)//(len(maxes))\n",
    "    for i in range(0, iter_len):\n",
    "        for i, val in enumerate(cur_ids):\n",
    "            if val > maxes[i] - 1:\n",
    "                cur_ids[i] = 0\n",
    "        if cur_ids[0] >= (maxes[0] - 2):\n",
    "            cur_ids[0] = 0\n",
    "        to_append = [ids0[cur_ids[0]],\n",
    "                    ids30[cur_ids[1]], ids40[cur_ids[2]],\n",
    "                    ids50[cur_ids[3]], ids60[cur_ids[4]], \n",
    "                    ids70[cur_ids[5]], ids80[cur_ids[6]],\n",
    "                    ids90[cur_ids[7]], ids100[cur_ids[8]]]\n",
    "        \n",
    "        np.random.shuffle(to_append)\n",
    "        new_batches.append(to_append)\n",
    "        cur_ids = [x + 1 for x in cur_ids]\n",
    "        \n",
    "    new_batches = [item for sublist in new_batches for item in sublist]\n",
    "    return new_batches\n",
    "\n",
    "batch = equibatch(train_ids)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1080x432 with 2 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n",
    "f.set_size_inches(15, 6)\n",
    "sns.distplot(np.sum(train_y, axis = (1, 2)), bins = 50, kde = False, ax = ax1)\n",
    "ax1.set_title('Original distribution')\n",
    "ax2.set_title('Equibatch distribution')\n",
    "sns.distplot(np.sum(train_y[batch], axis = (1, 2)),\n",
    "             bins = 50, kde = False, ax = ax2)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Example equibatch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[4:8]]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[8:12]]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x288 with 8 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "multiplot([x.reshape((14, 14)) for x in train_y[batch[0:4]]])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Weight cross entropy by effective number of samples"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Beta: 0.0\n",
      "[3365.38265306 1413.61734694]\n",
      "[3365.38265306 1413.61734694]\n",
      "Neg and pos weights: [0.29579773 0.70420227]\n",
      "2.380688564942307\n"
     ]
    }
   ],
   "source": [
    "sum_pos = np.sum(train_y[batch])\n",
    "sum_neg = len(train_y[batch]) * 196 - sum_pos\n",
    "beta = 0.0\n",
    "print(\"Beta: {}\".format(beta))\n",
    "samples_per_cls = np.array([sum_neg, sum_pos]) / 196\n",
    "print(samples_per_cls)\n",
    "effective_num = samples_per_cls#1.0 #- np.power(beta, samples_per_cls)\n",
    "print(effective_num)\n",
    "weights = (1.0 - beta) / np.array(effective_num)\n",
    "weights = weights / np.sum(weights)\n",
    "print(\"Neg and pos weights: {}\".format(weights))\n",
    "weight = weights[1] / weights[0]\n",
    "print(weight)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "278420.0 659244.0\n",
      "Beta: 0.999\n",
      "[3363.48979592 1420.51020408]\n",
      "[0.96544395 0.75858092]\n",
      "Neg and pos weights: [0.44000579 0.55999421]\n",
      "1.2726973826215766\n"
     ]
    }
   ],
   "source": [
    "sum_pos = np.sum(train_y)\n",
    "sum_neg = len(train_y) * 196 - sum_pos\n",
    "print(sum_pos, sum_neg)\n",
    "beta = 0.999\n",
    "print(\"Beta: {}\".format(beta))\n",
    "samples_per_cls = np.array([sum_neg, sum_pos]) / 196\n",
    "print(samples_per_cls)\n",
    "effective_num = 1.0 - np.power(beta, samples_per_cls)\n",
    "print(effective_num)\n",
    "weights = (1.0 - beta) / np.array(effective_num)\n",
    "weights = weights / np.sum(weights)\n",
    "print(\"Neg and pos weights: {}\".format(weights))\n",
    "weight = weights[1] / weights[0]\n",
    "print(weight)\n",
    "weight = 1.7"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Baseline: The positive is: 0.44000578680056873\n",
      "Baseline: The negative is: 0.5599942131994313\n",
      "\n",
      "\n",
      "Balanced: The positive is: 0.7480098375609668\n",
      "Balanced: The negative is: 0.5599942131994313\n"
     ]
    }
   ],
   "source": [
    "print(\"Baseline: The positive is: {}\".format(weights[0]))\n",
    "print(\"Baseline: The negative is: {}\".format(weights[1]))\n",
    "print(\"\\n\")\n",
    "print(\"Balanced: The positive is: {}\".format(weight*weights[0]))\n",
    "print(\"Balanced: The negative is: {}\".format(weights[1]))\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "# Loss definition\n",
    "\n",
    "The current best loss is a combination of weighted binary cross entropy and per-image Lovasz-Softmax, with a loss schedule with the latter becoming more important each epoch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.losses import binary_crossentropy\n",
    "import math\n",
    "from scipy.ndimage import distance_transform_edt as distance\n",
    "\n",
    "def calc_mask(seg):\n",
    "\n",
    "    res = np.zeros_like(seg)\n",
    "    posmask = seg.astype(np.bool)\n",
    "    loss_importance = np.array([x for x in range(0, 197, 1)])\n",
    "    loss_importance = loss_importance / 196\n",
    "    loss_importance = np.expm1(loss_importance)\n",
    "    loss_importance[:30] = 0.\n",
    "\n",
    "    if posmask.any():\n",
    "        negmask = ~posmask\n",
    "        res = distance(negmask) * negmask - (distance(posmask) - 1) * posmask\n",
    "        #res[np.where(res == 0)] = -1 * loss_importance[196 - sums]\n",
    "    if np.sum(seg) == 196:\n",
    "        res = np.ones_like(seg)\n",
    "    if np.sum(seg) == 0:\n",
    "        res = np.ones_like(seg)\n",
    "    res[np.logical_and(res < 2, res > 0)] = 0.5\n",
    "    res[np.logical_or(res >= 2, res <= 0)] = 1.\n",
    "    return res# / max_value\n",
    "\n",
    "def calc_mask_batch(y_true):\n",
    "    '''Applies calc_dist_map to each sample in an input batch\n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          \n",
    "         Returns:\n",
    "          loss (arr):\n",
    "    '''\n",
    "    y_true_numpy = y_true.numpy()\n",
    "    bce_batch = np.array([calc_mask(y)\n",
    "                     for y in y_true_numpy]).astype(np.float32)\n",
    "    return bce_batch\n",
    "\n",
    "def weighted_bce_loss(y_true, y_pred, weight, mask = True, smooth = 0.03):\n",
    "    '''Calculates the weighted binary cross entropy loss between y_true and\n",
    "       y_pred with optional masking and smoothing for regularization\n",
    "       \n",
    "       For smoothing, we want to weight false positives as less important than\n",
    "       false negatives, so we smooth false negatives 2x as much. \n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          y_pred (arr):\n",
    "          weight (float):\n",
    "          mask (arr):\n",
    "          smooth (float):\n",
    "\n",
    "         Returns:\n",
    "          loss (float):\n",
    "    '''\n",
    "    epsilon = 1e-7\n",
    "    y_pred = K.clip(y_pred, epsilon, 1. - epsilon)\n",
    "    y_true = K.clip(y_true, smooth, 1. - smooth)\n",
    "    logit_y_pred = K.log(y_pred / (1. - y_pred))\n",
    "    loss = tf.nn.weighted_cross_entropy_with_logits(\n",
    "        y_true,\n",
    "        logit_y_pred,\n",
    "        weight,\n",
    "    )\n",
    "\n",
    "    return loss\n",
    "    #return tf.reduce_mean(loss)\n",
    "'''\n",
    "    \n",
    "def calc_dist_map(seg):\n",
    "    #Utility function for calc_dist_map_batch that calculates the loss\n",
    "     #  importance per pixel based on the surface distance function\n",
    "    \n",
    "    #     Parameters:\n",
    "     #     seg (arr):\n",
    "          \n",
    "     #    Returns:\n",
    "     #     res (arr):\n",
    "    #\n",
    "    res = np.zeros_like(seg)\n",
    "    posmask = seg.astype(np.bool)\n",
    "    loss_importance = np.array([x for x in range(0, 197, 1)])\n",
    "    loss_importance = loss_importance / 196\n",
    "    loss_importance = np.expm1(loss_importance)\n",
    "    loss_importance[:30] = 0.\n",
    "\n",
    "    if posmask.any():\n",
    "        negmask = ~posmask\n",
    "        res = distance(negmask) * negmask - (distance(posmask) - 1) * posmask\n",
    "        sums = int(np.sum(seg))\n",
    "        # When % = 1, 0 -> 1.75\n",
    "        # When % = 100, 0 -> 0\n",
    "        res[np.where(res == 0)] = -1 * loss_importance[196 - sums]\n",
    "        res[np.where(np.isclose(res, -0.4142, rtol = 1e-2))] = -1 * loss_importance[196 - sums]\n",
    "        # When % = 1, 1 -> 0\n",
    "        # When % = 100, 1 -> 1.75\n",
    "        res[np.where(res == 1)] = loss_importance[sums]\n",
    "        res[np.where(np.isclose(res, 1.41421356, rtol = 1e-2))] = loss_importance[sums]\n",
    "        \n",
    "    res[np.where(res < -3)] = -3\n",
    "    res[np.where(res > 3)] = 3\n",
    "    if np.sum(seg) == 196:\n",
    "        res = np.ones_like(seg)\n",
    "        res *= -1\n",
    "    if np.sum(seg) == 0:\n",
    "        res = np.ones_like(seg)\n",
    "    return res# / max_value\n",
    "'''\n",
    "\n",
    "def calc_dist_map(seg):\n",
    "    #Utility function for calc_dist_map_batch that calculates the loss\n",
    "    #   importance per pixel based on the surface distance function\n",
    "    \n",
    "     #    Parameters:\n",
    "    #      seg (arr):\n",
    "     #     \n",
    "    #     Returns:\n",
    "    #      res (arr):\n",
    "    #\n",
    "    res = np.zeros_like(seg)\n",
    "    posmask = seg.astype(np.bool)\n",
    "    loss_importance = np.array([x for x in range(0, 197, 1)])\n",
    "    loss_importance = loss_importance / 196\n",
    "    loss_importance[:20] = 0.\n",
    "    loss_importance[20:60] = np.arange(0, 40, 1) / 40\n",
    "    loss_importance[60:] = 1.\n",
    "\n",
    "    mults = np.ones_like(seg)\n",
    "    ones = np.ones_like(seg)\n",
    "    for x in range(1, res.shape[0] -1 ):\n",
    "        for y in range(1, res.shape[0] - 1):\n",
    "            if seg[x, y] == 1:\n",
    "                l = seg[x - 1, y]\n",
    "                r = seg[x + 1, y]\n",
    "                u = seg[x, y + 1]\n",
    "                d = seg[x, y - 1]\n",
    "                lu = seg[x - 1, y + 1]\n",
    "                ru = seg[x + 1, y + 1]\n",
    "                rd = seg[x + 1, y - 1]\n",
    "                ld = seg[x -1, y - 1]\n",
    "                \n",
    "                sums = (l + r + u + d)\n",
    "                sums2 = (l + r + u + d + lu + ru +rd + ld)\n",
    "                if sums >= 2:\n",
    "                    mults[x, y] = 1.5\n",
    "                if sums2 <= 1:\n",
    "                    ones[x - 1, y] = 0.25\n",
    "                    ones[x + 1, y] = 0.25\n",
    "                    ones[x, y + 1] = 0.25\n",
    "                    ones[x, y - 1] = 0.25\n",
    "                    ones[x - 1, y + 1] = 0.25\n",
    "                    ones[x + 1, y + 1] = 0.25\n",
    "                    ones[x + 1, y - 1] = 0.25\n",
    "                    ones[x -1, y - 1] = 0.25\n",
    "\n",
    "    if posmask.any():\n",
    "        \n",
    "        negmask = ~posmask\n",
    "        res = distance(negmask) * negmask - (distance(posmask) - 1) * posmask\n",
    "        #sums = int(np.sum(seg))\n",
    "        # When % = 1, 0 -> 1.75\n",
    "        # When % = 100, 0 -> 0\n",
    "        res = np.round(res, 0)\n",
    "        res[np.where(np.isclose(res, -.41421356, rtol = 1e-2))] = -1\n",
    "        res[np.where(res == -1)] = -1 * mults[np.where(res == -1)]\n",
    "        res[np.where(res == 0)] = -1  * mults[np.where(res == 0)]# * loss_importance[196 - sums]\n",
    "        # When % = 1, 1 -> 0\n",
    "        # When % = 100, 1 -> 1.75\n",
    "        res[np.where(res == 1)] = 1 * ones[np.where(res == 1)]\n",
    "        res[np.where(res == 1)] *= 0.67\n",
    "        #res[np.where(np.isclose(res, 1.41421356, rtol = 1e-2))] = loss_importance[sums]\n",
    "        \n",
    "    res[np.where(res < -3)] = -3\n",
    "    res[np.where(res > 3)] = 3\n",
    "    if np.sum(seg) == 196:\n",
    "        res = np.ones_like(seg)\n",
    "        res *= -1\n",
    "    if np.sum(seg) == 0:\n",
    "        res = np.ones_like(seg)\n",
    "    return res# / max_value\n",
    "\n",
    "\n",
    "def calc_lovasz_weight(y_true):\n",
    "    if np.sum(y_true) > 12:\n",
    "        return np.array(1., dtype = np.float32)\n",
    "    else:\n",
    "        return np.array(0., dtype = np.float32)\n",
    "    \n",
    "def calc_bce_weight(y_true):\n",
    "    if np.sum(y_true) <= 12:\n",
    "        return np.array(1., dtype = np.float32)\n",
    "    else:\n",
    "        return np.array(0., dtype = np.float32)\n",
    "    \n",
    "def calc_lovasz_weight_batch(y_true):\n",
    "    '''Applies calc_dist_map to each sample in an input batch\n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          \n",
    "         Returns:\n",
    "          loss (arr):\n",
    "    '''\n",
    "    y_true_numpy = y_true.numpy()\n",
    "    lovasz_batch = np.array([calc_lovasz_weight(y)\n",
    "                     for y in y_true_numpy]).astype(np.float32)\n",
    "    return lovasz_batch\n",
    "\n",
    "def calc_bce_weight_batch(y_true):\n",
    "    '''Applies calc_dist_map to each sample in an input batch\n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          \n",
    "         Returns:\n",
    "          loss (arr):\n",
    "    '''\n",
    "    y_true_numpy = y_true.numpy()\n",
    "    bce_batch = np.array([calc_bce_weight(y)\n",
    "                     for y in y_true_numpy]).astype(np.float32)\n",
    "    return bce_batch\n",
    "    \n",
    "    \n",
    "\n",
    "def calc_dist_map_batch(y_true):\n",
    "    '''Applies calc_dist_map to each sample in an input batch\n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          \n",
    "         Returns:\n",
    "          loss (arr):\n",
    "    '''\n",
    "    y_true_numpy = y_true.numpy()\n",
    "    return np.array([calc_dist_map(y)\n",
    "                     for y in y_true_numpy]).astype(np.float32)\n",
    "\n",
    "def surface_loss(y_true, y_pred):\n",
    "    '''Calculates the mean surface loss for the input batch\n",
    "       by multiplying the distance map by y_pred\n",
    "    \n",
    "         Parameters:\n",
    "          y_true (arr):\n",
    "          y_pred (arr):\n",
    "          \n",
    "         Returns:\n",
    "          loss (arr):\n",
    "        \n",
    "         References:\n",
    "          https://arxiv.org/abs/1812.07032\n",
    "    '''\n",
    "    y_true_dist_map = tf.py_function(func=calc_dist_map_batch,\n",
    "                                     inp=[y_true],\n",
    "                                     Tout=tf.float32)\n",
    "    y_true_dist_map = tf.stack(y_true_dist_map, axis = 0)\n",
    "    multipled = y_pred * y_true_dist_map\n",
    "    #loss = tf.reduce_mean(multipled, axis = (1, 2, 3))\n",
    "    loss = K.mean(multipled)\n",
    "    return loss\n",
    "\n",
    "\n",
    "\n",
    "def lovasz_surf(y_true, y_pred, alpha, weight, beta):\n",
    "    \n",
    "    #lv = lovasz_softmax(probas = y_pred,\n",
    "    #                    labels = tf.reshape(y_true, (-1, 14, 14)), \n",
    "    #                    classes=[1],\n",
    "    #                    per_image=True) \n",
    "    #print(\"Lovasz Shape: \", lv.shape)\n",
    "    \n",
    "    bce = weighted_bce_loss(y_true = y_true, \n",
    "                             y_pred = y_pred, \n",
    "                             weight = weight,\n",
    "                             smooth = 0.03)\n",
    "    #mask_wt = tf.py_function(func=calc_mask_batch,\n",
    "    #                                 inp=[y_true],\n",
    "    #                                 Tout=tf.float32)\n",
    "   # bce = bce * mask_wt\n",
    "    #print(\"BCE Shape: \", bce.shape)\n",
    "    #return tf.reduce_mean(bce)\n",
    "\n",
    "    \n",
    "    bce = tf.reduce_mean(bce, axis = (1, 2, 3))\n",
    "    #print(\"BCE Shape: \", bce.shape)\n",
    "    surface = surface_loss(y_true, y_pred)\n",
    "    \n",
    "    #lv_mask = tf.math.reduce_sum(y_true, axis = (1, 2, 3))\n",
    "    #lv_mask = tf.cast(lv_mask, tf.float32)\n",
    "    #lv_mask = tf.math.greater_equal(lv_mask, tf.constant([25.]))\n",
    "    #lv_mask = tf.cast(lv_mask, tf.float32)\n",
    "\n",
    "    \n",
    "    #bce_mask = tf.math.reduce_sum(y_true, axis = (1, 2, 3))\n",
    "    #bce_mask = tf.cast(bce_mask, tf.float32)\n",
    "    #bce_mask = tf.math.less(bce_mask, tf.constant([25.]))\n",
    "    #bce_mask = tf.cast(bce_mask, tf.float32)\n",
    "    \n",
    "    \n",
    "    #lovasz = (lv * lv_mask) + (bce * bce_mask)\n",
    "    #lovasz = tf.reduce_mean(lovasz)\n",
    "    bce = tf.reduce_mean(bce)\n",
    "    \n",
    "\n",
    "    #lovasz_portion = (1 - alpha) * lovasz\n",
    "    #lovasz_portion = lovasz_portion * beta\n",
    "    bce = (1 - alpha) * bce\n",
    "    #bce = bce * (1 - beta)\n",
    "    surface_portion = alpha * surface\n",
    "    \n",
    "\n",
    "    \n",
    "    result = bce + surface_portion\n",
    "    return result\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1008x360 with 4 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "f, (ax1, ax2) = plt.subplots(1, 2, sharey=True)\n",
    "f.set_size_inches(14, 5)\n",
    "sns.heatmap(calc_mask(train_y[-4]), ax = ax1)\n",
    "ax2.set_title('Ground truth Y')\n",
    "ax1.set_title('Boundary loss mask')\n",
    "sns.heatmap(train_y[-4], ax = ax2)\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Evaluation metrics"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [],
   "source": [
    "countries = {'africaeast-test': [0, 34],\n",
    " 'africawest-test': [35, 96],\n",
    " 'cameroon-test': [97, 135],\n",
    " 'ethiopia-test': [136, 248],\n",
    " 'ghana-test': [249, 282],\n",
    " 'ghana-test-large': [283, 318],\n",
    " 'global-test': [319, 460],\n",
    " 'india-test': [461, 511],\n",
    " 'kenya-test': [512, 600],\n",
    " 'lac-north-test': [601, 641],\n",
    " 'lac-south-test': [642, 683], 'all': [0, 683]}\n",
    "\n",
    "countries = {'all': [0, 1150]}\n",
    "\n",
    "def dice_loss_tolerance(y_true, y_pred):\n",
    "    numerator_data = np.zeros_like(y_true)\n",
    "    for x in range(y_true.shape[0]):\n",
    "        for y in range(y_true.shape[1]):\n",
    "            min_x = np.max([0, x-1])\n",
    "            min_y = np.max([0, y-1])\n",
    "            max_y = np.min([y_true.shape[0], y+2])\n",
    "            max_x = np.min([y_true.shape[0], x+2])\n",
    "            if y_true[x, y] == 1:\n",
    "                numerator_data[x, y] = np.max(y_pred[min_x:max_x, min_y:max_y])\n",
    "                \n",
    "    numerator = 2 * np.sum(y_true * numerator_data, axis=-1)\n",
    "    denominator = np.sum(y_true + y_pred, axis=-1)\n",
    "    return (numerator + 1) / (denominator + 1)\n",
    "                    \n",
    "            \n",
    "        \n",
    "def compute_f1_score_at_tolerance(true, pred, tolerance = 1):\n",
    "    fp = 0\n",
    "    tp = 0\n",
    "    fn = 0\n",
    "    \n",
    "    tp = np.zeros_like(true)\n",
    "    fp = np.zeros_like(true)\n",
    "    fn = np.zeros_like(true)\n",
    "    \n",
    "    \n",
    "    for x in range(true.shape[0]):\n",
    "        for y in range(true.shape[1]):\n",
    "            min_x = np.max([0, x-1])\n",
    "            min_y = np.max([0, y-1])\n",
    "            max_y = np.min([true.shape[0], y+2])\n",
    "            max_x = np.min([true.shape[0], x+2])\n",
    "            if true[x, y] == 1:\n",
    "                if np.sum(pred[min_x:max_x, min_y:max_y]) > 0:\n",
    "                    tp[x, y] = 1\n",
    "                else:\n",
    "                    fn[x, y] = 1\n",
    "            if pred[x, y] == 1:\n",
    "                if np.sum(true[min_x:max_x, min_y:max_y]) > 0:\n",
    "                    if true[x, y] == 1:\n",
    "                        tp[x, y] = 1\n",
    "                else:\n",
    "                    fp[x, y] = 1                \n",
    "                \n",
    "    return np.sum(tp), np.sum(fp), np.sum(fn)\n",
    "\n",
    "def recover_patches(arr, thresh_p):\n",
    "    sum1 = np.sum(arr)\n",
    "    thresh = thresh_p / 2\n",
    "\n",
    "    for window_x in range(2, arr.shape[0]-2, 1):\n",
    "        for window_y in range(2, arr.shape[1]-2, 1):\n",
    "            l, r, u, d =  False, False, False, False\n",
    "            cur_window = arr[window_x-2:window_x+3, window_y-2:window_y+3]\n",
    "            hor_vert_neighbors = False\n",
    "            if (cur_window[2, 2] > thresh and\n",
    "                cur_window[2, 2] < thresh_p):\n",
    "                if cur_window[3, 2] > thresh * 2 and cur_window[4, 2] < thresh * 2 :\n",
    "                    hor_vert_neighbors = True\n",
    "                    r = True\n",
    "                if cur_window[1, 2] > thresh * 2 and cur_window[2, 0] < thresh * 2:\n",
    "                    hor_vert_neighbors = True\n",
    "                    l = True\n",
    "                if cur_window[2, 3] > thresh * 2 and cur_window[2, 4] < thresh * 2:\n",
    "                    hor_vert_neighbors = True\n",
    "                    d = True\n",
    "                if cur_window[2, 1] > thresh * 2 and cur_window[2, 0] < thresh * 2:\n",
    "                    hor_vert_neighbors = True\n",
    "                    u = True\n",
    "            passes = False\n",
    "            if r and not l:\n",
    "                passes = True\n",
    "            if l and not r:\n",
    "                passes = True\n",
    "            if d and not u:\n",
    "                passes = True\n",
    "            if u and not d:\n",
    "                passes = True\n",
    "\n",
    "            if passes:\n",
    "                if r:\n",
    "                    if cur_window[1, 1] < thresh * 2 and cur_window[1, 3] < thresh * 2:\n",
    "                        arr[window_x, window_y] = (thresh_p + 0.01)\n",
    "\n",
    "                if l:\n",
    "                    if cur_window[3, 1] < thresh * 2 and cur_window[3, 3] < thresh * 2:\n",
    "                        arr[window_x, window_y] = (thresh_p + 0.01)\n",
    "\n",
    "                if u:\n",
    "                    if cur_window[1, 3] < thresh * 2 and cur_window[3, 3] < thresh * 2:\n",
    "                        arr[window_x, window_y] = (thresh_p + 0.01)\n",
    "\n",
    "                if d:\n",
    "                    if cur_window[1, 1] < thresh * 2 and cur_window[3, 1] < thresh * 2:\n",
    "                        arr[window_x, window_y] = (thresh_p + 0.01)\n",
    "    return arr\n",
    "\n",
    "\n",
    "def calculate_metrics(country, al = 0.4, canopy_thresh = 100):\n",
    "    '''Calculates the following metrics for an input country, based on\n",
    "       indexing of the country dictionary:\n",
    "       \n",
    "         - Loss\n",
    "         - F1\n",
    "         - Precision\n",
    "         - Recall\n",
    "         - Dice\n",
    "         - Mean surface distance\n",
    "         - Average error\n",
    "    \n",
    "         Parameters:\n",
    "          country (str):\n",
    "          al (float):\n",
    "          \n",
    "         Returns:\n",
    "          val_loss (float):\n",
    "          best_dice (float):\n",
    "          error (float):\n",
    "    '''\n",
    "    print(canopy_thresh)\n",
    "    start_idx = 0\n",
    "    stop_idx = len(test_x)\n",
    "    best_f1 = 0\n",
    "    best_dice = 0\n",
    "    best_thresh = 0\n",
    "    hausdorff = 0\n",
    "    relaxed_f1 = 0\n",
    "    preds = []\n",
    "    vls = []\n",
    "    trues = []\n",
    "    test_ids = [x for x in range(len(test_x))]\n",
    "    for test_sample in test_ids[start_idx:stop_idx]:\n",
    "        if np.sum(test_y[test_sample]) < ((canopy_thresh/100) * 197):\n",
    "            x_input = test_x[test_sample].reshape(1, 12, 16, 16, n_bands)\n",
    "            x_median_input = calc_median_input(x_input)\n",
    "            y, vl = sess.run([fm, test_loss], feed_dict={inp: x_input,\n",
    "                                                         inp_median: x_median_input,\n",
    "                                                          length: np.full((1, 1), 12),\n",
    "                                                          is_training: False,\n",
    "                                                          clipping_params['rmax']: rmax_epoch,\n",
    "                                                          clipping_params['rmin']: rmin_epoch,\n",
    "                                                          clipping_params['dmax']: dmax_epoch,\n",
    "                                                          labels: test_y[test_sample].reshape(1, 14, 14),\n",
    "                                                          loss_weight: 1.7,\n",
    "                                                          alpha: al,\n",
    "                                                          })\n",
    "            preds.append(y.reshape((14, 14)))\n",
    "            vls.append(vl)\n",
    "            trues.append(test_y[test_sample].reshape((14, 14)))\n",
    "    dice_losses = []\n",
    "    for thresh in range(8, 13):\n",
    "        tps_relaxed = np.empty((len(preds), ))\n",
    "        fps_relaxed = np.empty((len(preds), ))\n",
    "        fns_relaxed = np.empty((len(preds), ))\n",
    "        abs_error = np.empty((len(preds), ))\n",
    "        \n",
    "        for sample in range(len(preds)):\n",
    "            pred = np.copy(preds[sample])\n",
    "            true = trues[sample]\n",
    "            if thresh == 8:\n",
    "                if np.sum(true + pred) > 0:\n",
    "                    dice_losses.append(dice_loss_tolerance(np.array(true), np.array(pred)))\n",
    "                else:\n",
    "                    dice_losses.append(1.)\n",
    "            pred[np.where(pred >= thresh*0.05)] = 1\n",
    "            pred[np.where(pred < thresh*0.05)] = 0\n",
    "            \n",
    "            true_s = np.sum(true[1:-1])\n",
    "            pred_s = np.sum(pred[1:-1])\n",
    "            abs_error[sample] = abs(true_s - pred_s)\n",
    "            tp_relaxed, fp_relaxed, fn_relaxed = compute_f1_score_at_tolerance(true, pred)\n",
    "            tps_relaxed[sample] = tp_relaxed\n",
    "            fps_relaxed[sample] = fp_relaxed\n",
    "            fns_relaxed[sample] = fn_relaxed                   \n",
    "            \n",
    "        oa_error = np.mean(abs_error)\n",
    "        precision_r = np.sum(tps_relaxed) / (np.sum(tps_relaxed) + np.sum(fps_relaxed))\n",
    "        recall_r = np.sum(tps_relaxed) / (np.sum(tps_relaxed) + np.sum(fns_relaxed))\n",
    "        f1_r = 2*((precision_r* recall_r) / (precision_r + recall_r))\n",
    "        \n",
    "        if f1_r > best_f1:\n",
    "            haus = np.zeros((len(preds), ))\n",
    "            for sample in range(len(preds)):\n",
    "                pred = np.copy(preds[sample])\n",
    "                pred[np.where(pred >= thresh*0.05)] = 1\n",
    "                pred[np.where(pred < thresh*0.05)] = 0\n",
    "                true = trues[sample]\n",
    "                dists = compute_surface_distances(np.array(true).reshape(14, 14, 1).astype(int),\n",
    "                                                  np.array(pred).reshape(14, 14, 1).astype(int),\n",
    "                                                  [1, 1, 1])\n",
    "                if np.sum(true + pred) > 0:\n",
    "                    haus_i = compute_robust_hausdorff(dists, 50)\n",
    "                    if not np.isinf(haus_i):\n",
    "                        haus[sample] = haus_i\n",
    "                if np.sum(true + pred) == 0:\n",
    "                    haus[sample] = 0.\n",
    "                    \n",
    "            dices = np.mean(dice_losses)\n",
    "            haus = np.mean(haus)\n",
    "            best_dice = dices\n",
    "            best_f1 = f1_r\n",
    "            p = precision_r\n",
    "            r = recall_r\n",
    "            error = oa_error\n",
    "            best_thresh = thresh*0.05\n",
    "            best_haus = haus\n",
    "    print(\"{}: Val loss: {} Thresh: {} F1: {}\"\n",
    "          \" R: {} P: {} D: {} H: {} Error: {}\".format(country, \n",
    "                                                     np.around(np.mean(vls), 3),\n",
    "                                                     np.around(best_thresh, 2),\n",
    "                                                     np.around(best_f1, 3), np.around(p, 3),\n",
    "                                                     np.around(r, 3), \n",
    "                                                     np.around(np.mean(best_dice), 3),\n",
    "                                                     np.around(best_haus, 3),\n",
    "                                                     np.around(error, 3)))\n",
    "    return np.mean(vls), best_f1, error, best_haus, np.mean(best_dice)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Graph set up"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [],
   "source": [
    "def augment_batch(batch_ids, batch_size):\n",
    "    '''Performs random flips and rotations of the X and Y\n",
    "       data for a total of 4 x augmentation\n",
    "    \n",
    "         Parameters:\n",
    "          batch_ids (list):\n",
    "          batch_size (int):\n",
    "          \n",
    "         Returns:\n",
    "          x_batch (arr):\n",
    "          y_batch (arr):\n",
    "    '''\n",
    "    x = train_x[batch_ids]\n",
    "    y = train_y[batch_ids]\n",
    "    x_batch = np.zeros_like(x)\n",
    "    y_batch = np.zeros_like(y)\n",
    "    flips = np.random.choice(np.array([0, 1, 2, 3]), batch_size, replace = True)\n",
    "    for i in range(x.shape[0]):\n",
    "        current_flip = flips[i]\n",
    "        if current_flip == 0:\n",
    "            x_batch[i] = x[i]\n",
    "            y_batch[i] = y[i]\n",
    "        if current_flip == 1:\n",
    "            x_batch[i] = np.flip(x[i], 1)\n",
    "            y_batch[i] = np.flip(y[i], 0)\n",
    "        if current_flip == 2:\n",
    "            x_batch[i] = np.flip(x[i], [2, 1])\n",
    "            y_batch[i] = np.flip(y[i], [1, 0])\n",
    "        if current_flip == 3:\n",
    "            x_batch[i] = np.flip(x[i], 2)\n",
    "            y_batch[i] = np.flip(y[i], 1)\n",
    "\n",
    "    y_batch = y_batch.reshape((batch_size, 14, 14))\n",
    "    return x_batch, y_batch\n",
    "\n",
    "x_batch_test, y_batch_test = augment_batch([0,], 1)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_median_input(x_batch):\n",
    "    #x_s2 = x_batch[..., :10]\n",
    "    #x_s1 = x_batch[..., -2:]\n",
    "    #x = np.concatenate([x_s2, x_s1], axis = -1)\n",
    "    x_median = np.median(x_batch, axis = (1))\n",
    "    #x_mean = np.mean(x_batch, axis = 1)\n",
    "    #x_variance = np.var(x, axis = (1))\n",
    "    #x = np.concatenate([x_median, x_variance], axis = -1)\n",
    "    #x = np.reshape(x, (x.shape[0], 4, 3, 16, 16, 12))\n",
    "    #x = np.median(x, axis = 2)\n",
    "    #x = np.swapaxes(x, 3, 1)\n",
    "    #x = np.swapaxes(x, 1, 2)\n",
    "    #x = np.reshape(x, (x.shape[0], 16, 16, 12*4))\n",
    "    return x_median\n",
    "\n",
    "x_batch_med = calc_median_input(x_batch_test)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Starting model with: \n",
      " 0.2 zone out \n",
      " 0.0 l2 \n",
      "0.0001 initial LR \n",
      " 0.02 final LR \n",
      " 282934 parameters\n",
      "Restarting training from scratch on 4784 train and 1047 test samples\n",
      "The graph has been finalized\n"
     ]
    }
   ],
   "source": [
    "FRESH_START = True\n",
    "best_val = 0.2\n",
    "\n",
    "START_EPOCH = 1\n",
    "END_EPOCH = 100\n",
    "LEARNING_RATE = 3e-3\n",
    "test_ids = [x for x in range(0, len(test_x))]\n",
    "\n",
    "print(f\"Starting model with: \\n {ZONE_OUT_PROB} zone out \\n {L2_REG} l2 \\n\"\n",
    "      f\"{INITIAL_LR} initial LR \\n {FINAL_LR} final LR \\n {total_parameters} parameters\")        \n",
    "    \n",
    "if FRESH_START:\n",
    "    print(f\"Restarting training from scratch on {len(train_ids)} train and {len(test_ids)} test samples\")\n",
    "    optimizer = AdaBoundOptimizer(1e-4, 7e-3)\n",
    "    #optimizer = tf.train.AdamOptimizer(1e-4)\n",
    "    train_loss = lovasz_surf(tf.reshape(labels, (-1, 14, 14, 1)), \n",
    "                             fm, weight = loss_weight, \n",
    "                             alpha = alpha, beta = beta_)\n",
    "    #l2_loss = tf.losses.get_regularization_l05oss()\n",
    "    #train_loss += l2_loss\n",
    "\n",
    "    ft_optimizer = tf.train.GradientDescentOptimizer(ft_lr)\n",
    "    test_loss = lovasz_surf(tf.reshape(labels, (-1, 14, 14, 1)),\n",
    "                            fm, weight = loss_weight, \n",
    "                            alpha = alpha, beta = beta_)\n",
    "    update_ops = tf.get_collection(tf.GraphKeys.UPDATE_OPS)\n",
    "    \n",
    "    with tf.control_dependencies(update_ops):\n",
    "        train_op = optimizer.minimize(train_loss)   \n",
    "        ft_op = ft_optimizer.minimize(train_loss)\n",
    "        \n",
    "    init_op = tf.global_variables_initializer()\n",
    "    sess.run(init_op)\n",
    "    saver = tf.train.Saver(max_to_keep = 150)\n",
    "    \n",
    "print(\"The graph has been finalized\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_losses = []\n",
    "test_losses = []\n",
    "f1s = []\n",
    "dices = []\n",
    "errors = []\n",
    "hausdorff = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "INFO:tensorflow:Restoring parameters from ../models/unet-final-data/162-89-2/model\n"
     ]
    }
   ],
   "source": [
    "# This cell should be run to do fine-tuning, if commented - train from scratch\n",
    "#@path = '../models/tropics/2e-5/ft-bce-surf/322-92-0/'\n",
    "path = \"../models/unet-final-data/162-89-2/\"\n",
    "#path = \"../models/unet-s1/9-74-4/\"\n",
    "\n",
    "\n",
    "#path = \"../models/nov-unet-1.7/132-87-6/\"\n",
    "#path = \"../models/lac-new/157-82-6/\"\n",
    "#path = '../models/sept-22/27-82-5/'\n",
    "#path = '../models/october/64-83-3/'\n",
    "\n",
    "#path = '../models/nov-unet/85-86-6/'\n",
    "#new_saver = tf.train.import_meta_graph(path + 'model.meta')\n",
    "saver.restore(sess, tf.train.latest_checkpoint(path))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_losses = train_losses[:126]\n",
    "test_losses = test_losses[:126]\n",
    "errors = errors[:126]\n",
    "hausdorff =hausdorff[:126]\n",
    "dices = dices[:126]\n",
    "f1s = f1s[:126]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAA3oAAAK7CAYAAACkkP3dAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADl0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uIDMuMC4yLCBodHRwOi8vbWF0cGxvdGxpYi5vcmcvOIA7rQAAIABJREFUeJzs3XvcHHV5///Xdd853UkICSQgkkRSCNQoaOQuCqkKgohKQaqVg5wEgZhS+1Wh4FexKFpF5GfbryABRARUpBw0VRQpBW0jIEk5KLFRBCUJh9zGBHIiyZ29fn/MTJhs9jC7O7s7M/t+Ph73I9nd2d2Z3Z3PfK7P4fqYuyMiIiIiIiLF0dftHRAREREREZF0KdATEREREREpGAV6IiIiIiIiBaNAT0REREREpGAU6ImIiIiIiBSMAj0REREREZGCUaAHmFm/ma0zs+lNPHcfM9MaFSIiHWBmbmb7dHs/RES6zcyuMrOLur0fkl25DPTCoCz6K5nZxtjtDzT6eu6+1d3Hu/vT7djfPDCzXc3s+2a23sx+b2bH19j242b2lJm9aGYrzOxyMxsRPtZnZvea2ZCZvWBmj5jZ0W3a52PM7OdmtsbMnjWz+WY2vsb2M8zsp2a2wcx+bWaHlT1+vpk9F+73tWY2qh37HXu/MWZ2jZmtNLM/mdkCM3tlk681IqwAr4+dC1c18Px/MrNfmdmwmX2qmX2IvdaFZva4ma01syfN7GOtvJ5kn5mdbma/DM+t58zsa2Y2MeFzMxO4mdlkM1toZqvCcuV+M5vTwuudbmZby65ZXw0fOywsK18ws9+ndhAiUhhhfWxjeD1dE9Z55ppZH4C7z3X3S7q9n5JduQz0wqBsvLuPB54G/ip237fKt4+CEKnpKmA9sBtwGnCNmf15lW2/B7ze3ScABwCDwLzwMQc+Auzh7juH93/HzHZrwz7vBHwG2AN4DTAD+GKN7W8BHgR2Af4RuN3MdgUws3cDHwcOC19nP+DTbdjnuI8BBwKvBfYE1gH/3OJrviZ2Lsxt4Hm/Ac4Dftzi+0dOBiYC7wY+ambvS+l1JWPM7OPApcD5wM7Am4BXAXe3u7GkFVWuC+uAM4ApwCSC4/r3Fq8h98evWe5+bnj/euA6gs+tq3SNFMm0v3L3nQjK1S8CFwBf7+4uSV7kMtCrx8w+Z2bfNbPvmNla4GQzO9jMHoj1/vyrmY0Mt496Q/YKb98UPv6jsBXlfjObkfC9p5rZD8Iemt+a2Rmxx95kZv8T9oQ9b2aXhfePNbNvx1qRf2Fmk8PHJprZN8J9Xm5mn41acsxsXzP7Wdgi/Ecz+3aTn9cE4D3Ap9x9vbv/FPghQWV9B+7+O3d/IXo6UAL2CR9zd/+luw+bWfTYKGBqlfeu+r3U4+7fcve73H2ju/8JuBao2PpuZrMIAqrPuPtL7n4L8L/AceEmpwFXu/uvw9f6HHB6ldf6lpn9ffj/V4W/nXPC2/tZ0JtpCQ5hBvBjd1/p7huB7xIErNH7TDWzO8LXe8rM/jbBazbF3a939x8TVHR3YGYfMrP/NbPV4XkxrcZrfdHdHw57yn8N/DtVvhfJt7Ds+Azwd+7+Y3ff4u6/B94P7EVYhlgwPP7/mtnvwjJ1sZlNM7OfhS/1aNjbdXy4/Vlm9oRV7+l+lwW9xX80s8uiMjF87hkW9NivNrO7zOxVscfczP7WzH4L/Lb8eMKyYam7lwjKtq0EAd8u6Xxi273XL9z9RuDJetta0Pt/U+wa8ZCZ7R4+tkt4jXgmPObvxZ5X9XOs9FmY2Z+b2d3h9kvN7P1pH7eINMfdX3D3BcDxwGlm9lozu97MPhdtY2bHWjCS6sWwvD0qvH9nM/t6WM9aYUE9ub9bxyKdU8hAL3Qc8G2CFubvAsPA3wOTCSqdRwHn1Hj+ScBFBBf4p4GkXePfBZ4CXklwMn7JzN4aPvb/gMvCnrB9gFvD+z8IjCUIhnYl6AV7KXzsRmAjsDdB78+7w+0BPk8QkE0Kn3tFwn0stx/wkrvHKxyPEgs6ypnZKRYE0UPhdleXPf6j8BjuB/4DeKTKSzX6vdTyFuDxKo+9BnjC3dfH7osf42vC2/HH9jSznSu81k+BQ8P/v5WgovaW2O2fuXuSeZvXAm82sz3MbBzBb+5HEAyBBX4APETQ2/d24HwzO7zOa/7cgqFzt8YruK0ws/cS9DocS9DT8SDBuZXkuX3AX1L9e5F8OwQYA9wev9Pd1wF3EvxuIei9PhF4FzCBoNdsg7tH583rwt6u75rZ24AvEASLewB/AG4ue9/jCEYSvIHgd3kGBJUc4P8Cf03wW/0v4Dtlz30P8EZgVrWDMrPHCMqvBcC17r6y3gfRZqcRXMumEVwj5hJcFyC4RowlKMN2A74CkPBz3PZZhGXQ3QTn9m7ACcCVYSOZiGSEu/8CWA68OX6/mR0E3EBwvZ5IUC/5ffjw9QT1rX2A2cCRwIc6ssPSVUUO9P7b3f/d3Uthj89D7v6guw+HAc3VBJXyam5190XuvgX4FvD6em9oQa/fQcCFYcvw/wDfAE4JN9kCzDSzXd19rbs/GLt/MrBP2AuyyN3XmdmewBHAR919g7s/TzC074TY8/YiGCb5krsvTP7xbGc88ELZfS8QDI2syN1vDIcS/DkwH1hZ9vg7w9c9Grg7bCGv9DqNfi8Vmdk7CQKlf6yySb1jLH88+n+lz+CnBAGaERSklxIEMxDs+08T7vZS4FngmfD99iHoSQQ4GJjg7v/k7pvd/QmCoRonVHyloOfhLQS/h1cTBOALUmqxmwv8U9jTMRzu40Hh77OeSwguLjeksB+SPZOBP4a/i3LPho9DUKH4VPgbcnd/1N1XVXnNDwDXufv/uPsm4BPAwRaOuAhd6u5/CudV/zNBEAnBb/ULYc/8MPBPwOvLGj2+ED53I1W4+wEEAelJwH9XP/xE3hT2wkV/b2riNbYQBHjRNWKxu79oZnsA7wTmuvvqsEc1Kn+SfI7xz+Jo4Pfu/o2wPH4YuA34m+YOW0Ta6Bl2HGlwJsE5f3dY913h7v8b9v6/C/g/4aitlQQNQtXqE1IgRQ70lsVvhENSfhj2drwIfJaXKyGVPBf7/waCQKCeVxJUeuK9Rn8g6JGBoCduFrDUguGZ7wrvv56g1+uWsEv9ixbMmXgVMBp4PqokEPTa7R4+7+PASGCRBYkQTqu0UxYkFokSAfxDhU3WEVRq4iYAa+sdsLsvJQhYvlrhsS3u/kPg6Nixlu9bo99Lpdc4hCCQ+Gt3/12VzeodY/nj0f93+AzCYx4G9idoUVsArDKzvWks0LuK4BzcBRhH0IP3w/CxVwHT4xVE4B+AV9jLWWKjv1eGlef/CoPC1QTzJPcN/1r1KuCK2H78kWBI7lQzu8jKkkxELBjeegJwtLtvTmE/JHv+CEy2ynO89ggfh6Anqtq5We6VBOUmsK13cBUvl6Owffn+h/A5EPxW/yX2W/0TwRDMas+tKmw8+w5woZm9rvxxM5sePw9rvNQD7j4x9vdAkvcvcyNwF3BzOETzSxYMcZ8G/Ck858s1+jm+CnhjWZnzAeAVTeyviLTXngTlW1y1cvZVBHXFZ2Pn9nyCnnspuCIHeuVD5+YDvyJoEZ1AkGgjyTyqRjxDUOkZF7tvOrACggDB3U8gOLkuB24zszFh5fxid381Qc/QcQQX2GUEQeYusUrChLC1GXd/1t0/5O57AH8LXG0V5hKG20SJAL5UYb+XAgNlz30dyYfbjSAYWtrM4y19L2Y2SJAc5jR3v6/Gpo8D+5jZ2Nh98WN8PLwdf2yFvzwXsdxPCYIYd/fnwttnEgyh+mXC3X898I2wJX4TwdDeQyzIVrgM+G1ZBXEnd/8rfzlLbPT3TIXX9vAvjd/4MuDMsn0ZCHtiL/Edk0xgZmcTNEQcXmX/pBjuBzYRDJXcxoLst+8E7gnvWkbtMiLuGYKKSfRa4wh6s1bEtonPEZ0ePid6n3Mq/FZ/Htu+0eVwRgJ/Vn6nuz/t2ycGa5uw0ewz7j6LYLjs0cCpBMe7i1XOcJrkc4x/FsuAn5Z9duPd/cNpH4+INM/M/oIg0CsfbVCtnF1GUE5PLqtLVp2eI8VR5ECv3E4Ew+PWm9mraX4eWFXu/hSwCPgnMxttZq8n6MW7CbbNa5vswTDGFwgusiUze1s4qbYPeJFgmE7J3ZcRBBBfNrMJFixdsI+ZvSV8vffHhs+tCV9vaxP7/SLwfeASCxLDvJlgLuBNlba3YIL/lPD/ryHIAHVPeHuWmR1lQfKAUWEv48HAzyq9FnW+FzP7b6uS7j9sZb8TmOfud9Y5xiUEwdynw317H8EQxzvCTW4Azgp7GCcBnyLoaa3mp8C5vNx7d194+7/C7zee5OcvK78EDxFMqJ4Qts7PA5529zUEFejNFixlMSbsxdvfzA6s8lnsb2avC7fbiWBYxh8IsmlGyVSeqHYwZjbSzMYQlAkjwveMyoergE+G30+UIKhqFs3wO/8M8HYPEnNIQYUNIZ8B/l943o8MhwbeQjCH5MZw02sJypeZFjjAwoy3wPNsH0h9B/igmb3ezEYTDL98sOy3dL6ZTbIgKdDfE8yNhuC3+omwXIoSECQeemhBwqy/DMuuATO7gGAExYP1ntuosDwfQxBIWlRmVtn2sPAc72f7a8SzBPN6rww/j5HR9YFkn2PcD4B9w+vUyPDvL6LzXkS6K6wrHE0w1/Ymdy9vVP46wTl/eFi+7Glmfx6WEz8BLo/VJfe2l/NHSJG5e67/CCaaHlF23+eA68vuO4yg52odQdDxOeC+8LERBEHSXuHtm4CLY889gmDuQqX33yf4GLfdnk4QfKwGngDOij32HYK5U2sJerH+Krz/ZIIK+TqCIaP/DPSHj00i6PVaThAQPQy8P3zscoJW2/Xhe53Zwuc4mWAI4nqCAOH42GOHAmtit28kmJO3niDxzKXA6PCx1wK/IKiMrCGoIB1T432rfi/h438ADqvy3BsJAtt1sb9HY49fC3w1dvvPCAKzjcCvgbeVvd754XG9SFBgjqqx368JfzMfCG/vQjCc8eOxbWaEn8HEKq8xJfxNrAy3+xlwYOzxPQkqsM+Fv6ef1/gsjgg/x/Xh690B7B17/DPAN2scz0283AsY/Z0ce/z08Df7IkFyomtqvNYyYHPZ9/LVatvrL/9/BL3ZvwrPrecJyqxJscf7CRpPniIo/x4CpoaPzSWYz7eGl8u2uQRDkP5EEIBMjb1WtITLkwRDES8nLC/Dx08h6FV/MfwtXlf23H1qHMdbCRIxrQ3f+6fAW1r4XE4nmC9e6bFDK5xz91XZ9sTY+f088K/AiPCxXYBvhvevBm6PPa/e57hP2fvsRzB8fCj8bP+TYCmdrv/G9Ke/XvwjqONuDMukFwgagf+Wl+uI1wOfi21/HPBYuP0TwDvC+3cGvsb2dckTun18+mv/n4U/AJHMCXsGbnT3N9fZNJPM7HSCYOuiDOzLPcCH3f033d4XEREREWk/BXoiIiIiIiIF00tz9ERERERERHqCAj0REREREZGCSRTohdnUlprZE2Z2YYXHP2ZmS8zsMTO7x2KL01qw1tBPzOzX4TZ7hfdfb2ZPmdkj4V/dBclFRERERESkvrpz9MJ0zr8B3k6Qrech4EQP0tVH2xxGkLZ5g5l9GDjU3Y8PH7sP+Ly7323B2kqlcLvrgR+4+61Jd3by5Mm+1157NXJ8IpJxixcv/qO7T+n2frRCZZNI8RShbAKVTyJFlLR8GpHgtQ4CnnD3JwHM7GbgWGBboOfu98a2f4BguQDMbBZBCui7w+3WJT6CCvbaay8WLVrUykuISMaY2R+6vQ+tUtkkUjxFKJtA5ZNIESUtn5IM3dyTYC2iyPLwvmrOJFjAFWBfYI2Z3W5mD5vZZWEPYeTz4XDPr4QLuoqIiIiIiEiLUk3GYmYnA4PAZeFdI4A3A+cBf0GwYPXp4WOfAP48vH8X4IIqr3m2mS0ys0VDQ0Np7q6IiIiIiEghJQn0VgDTYrenhvdtx8yOAD4JHOPum8K7lwOPuPuT7j4MfA94A4C7P+uBTcA3CIaI7sDdr3b3QXcfnDIl90PlRURERERE2i5JoPcQMNPMZpjZKOAEYEF8AzObDcwnCPJWlj13oplFEdrbCOf2mdke4b8GvAf4VSsHIiIiIiIiIoG6yVjcfdjMzgXuAvqB69z9cTP7LLDI3RcQDNUcD/xbELfxtLsf4+5bzew84J4woFsMXBO+9LfCANCAR4C5aR+ciIiIiIhIL0qSdRN3vxO4s+y+T8f+f0SN594NHFDh/rcl300RERERERFJKtVkLCIiIiIiItJ9CvREREREREQKRoGeiIiIiIhIwSjQExERERERKRgFeiIiIiIiIgWjQE9ERERERKRgEi2vICIiIiKSZaWSs2r9ZjYPb2XUiH52HTeKvj7r9m6JdI0CPRERERHJtVLJWfr8Ws66YRHLV29k6qQBrjl1kP1230nBnvQsDd0UERERkVxbtX7ztiAPYPnqjZx1wyJWrd/c5T3Lt1LJGVq7iRWrNzC0dhOlknd7l6QB6tETERGRrtKQO2nV5uGt24K8yPLVG9k8vLVLe5R/6iXNP/XoiYiISNdElcnjrlzInEvv5bgrF7L0+bXqOZCGjBrRz9RJA9vdN3XSAKNG9Hdpj/JPvaT5p0BPRESkA1oZAlXk4VOqTEoadh03imtOHdwW7EW9T7uOG9XlPcsv9ZLmn4ZuioiItFkrQ6CKPnxKlUlJQ1+fsd/uO3HHvDkaApySqJc0fn6qlzRfeqpHr8gtoiIikl2t9FoVvcdLQ+4kLX19xpSdRrPnpLFM2Wm0grwWqZc0/3qmR6/oLaIiIpJdrfRaFb3HK6pMll+fVZkU6S71kuZfzwR61VpE75g3hyk7je7y3omISJG1MgSq6MOnVJkUya6ol1TyqWeGbha9RVRERDqn0akArQyB6oXhUxpyJyKSvsL26JWvyTNyRF+hW0RFRKQzmpkK0GyvVXQt22XsSG4552DcvekeL61VJyK9QGXdywoZ6FW6CN9wxkGaAyAiIi1rdipAo0OgqgeUA00FeZqnLtJ9CkLaS2Xd9go5dLPSRfjU637B7hNGc8e8OSy84DDumDenZ790ERFpXqemAqSZbbMImTuVOVvyLgpCjrtyIXMuvZfjrlzI0ufX6recoiKUdWkqZKBX7SK8cfNWzQEQEZGWdGo5gDQDyrzPU1cFWYpAQUj75b2sS1shAz2tySMiZnaUmS01syfM7MIKj083s3vN7GEze8zM3hXeP8rMvmFmvzSzR83s0I7vvGRap5KjpHkty/t1sUgV5HplU7jN+81siZk9bmbfjt0/3cx+Yma/Dh/fq1P7La1TENJ+eS/r0lbIQK8XMpSJSHVm1g9cAbwTmAWcaGazyjb7FHCLu88GTgCuDO8/C8Dd9wfeDlxuZoUsK6U58cQq7ZwKkOa1LO/XxaJUkJOUTWY2E/gEMMfdXwP8n9jDNwCXufurgYOAlR3ZcUmFgpD2y3tZl7ZCJmPRmjwiPe8g4Al3fxLAzG4GjgWWxLZxYEL4/52BZ8L/zwL+E8DdV5rZGmAQ+EUH9ltyop1rS8WTNew+YTS3zzuELcOllq5leb8uFmgtwSRl01nAFe6+GoJyKNx2FjDC3e8O71/XyR2X1kVBiBIDtk/ey7q0FTLQAy3wKNLj9gSWxW4vB95Yts3FwE/M7O+AccAR4f2PAseY2XeAacCB4b8K9AqumWx4aWfQa2fGuDxfFwtUQU5SNu0LYGYLgX7gYnf/cXj/GjO7HZgB/Adwobvv0K1pZmcDZwNMnz497WOQJikI6Yx2lXV5zJhauEAvj1+CiHTFicD17n65mR0M3GhmrwWuA14NLAL+APwcUEWq4OIB1pTxo/nI4TOZMXkcY0f3M3lc5eRd7QjKml26oeh6rII8ApgJHApMBX5mZvuH978ZmA08DXwXOB34evkLuPvVwNUAg4ODyliTIXlucOlleV22oVDzTpJm5VKKZpHCW0HQCxeZGt4XdyZwC4C73w+MASa7+7C7f9TdX+/uxwITgd+Uv4G7X+3ug+4+OGXKlLYchHROFGBNGT+a896xHxd9/1cc+uX7+Osrf141u2M7EoQUZS5aO0QV5Jxnzk5SNi0HFrj7Fnd/iqD8mRne/4i7P+nuw8D3gDd0YJ9Fel5eE0IVKtBL8iUoRbNIT3gImGlmM8xsFEGylQVl2zwNHA5gZq8mCPSGzGysmY0L7387MOzuS5BCiwKsuYfuzQW3PZboYt6OoCyPyRrUeNqQJGXT9wh68zCzyQRDNp8MnzvRzKKWpbex/dw+EWmTvDbCFSrQS/Il5DUiF5Hkwtbuc4G7gF8TZNd83Mw+a2bHhJt9HDjLzB4FvgOc7u4O7Ab8j5n9GrgAOKXzRyCdFgVYEwdGJr6YtyMoy1vGODWeNiZh2XQXsMrMlgD3Aue7+6pwLt55wD1m9kvAgGs6fxQivSePjXBQsDl6SbJy5TUiF5HGuPudwJ1l93069v8lwJwKz/s9sF+790+yJQqwnnvhpcTZHduRICRvc9E0p7BxCcomBz4W/pU/927ggHbvo4hsL68JoQoV6CX5EgqUollEJPeykOkSXg6wdp8wmvknH8g5Ny2uezFvV1CWp2QNajwVkV6Qt0a4SKECvSRfQl4jchGRomkmi1mzmc+SBId9fcYu40YzcWBU4ot5noKytMQ/SzOr2niahSzYWdgHaQ99t9JpeSzvCxXoQf0vIa8RuYhI0TQz7K+Z5zQaHObpYt7pym75Z3nkrN246uQDmVvWAzppYGSizzyt/a/0OkAu06FLfXlNdS/SaYUL9JLI00VcRKSomhn218xzijqPrB2V3XqBV/ln+ZMlKwG45ZyDcfdtz0nymae1/9VeZ9fxowr5vUuxzukkjR3qvZRmFSrrpoiI5EczWcyaeU4n55F1cqmBtLNIJ8mgWemz/MmSlbg7e+wcfC/PvrCRjVuGO5YFu9rrvLRF8weLqihzQ5Occ8psK61QoCciIl3RzFICzTynU2mxO10ha7ayWy0YTRJ4VfssB0b1bzv2c7/9MJuHvep20XsnCQZb+Rz6w/mD5fug5GvJZXWNxLymui+X5JzTsmDSikSBnpkdZWZLzewJM7uwwuMfM7MlZvaYmd1jZq+KPTbdzH5iZr8Ot9krvH+GmT0YvuZ3w4VDRUSkR8TnTC+84DDumDen7rC9Zp5TLzhMqzLb6QpZM5XdWsFoksCx2mc5XHLOumERU8aP5rx37MeXfvxrLn3vAdttd8MZB/H8i5u2vffvVq5PpbIe/xxmT5vI/FMO5Na5BzOyvy9XaxJmTZZ7kvK23mQ1Sc65ovReSnfUnaNnZv3AFcDbgeXAQ2a2IFyDKvIwMOjuG8zsw8CXgOPDx24APu/ud5vZeKAU3n8p8BV3v9nMrgLOBL6WylGJiEguNDNnutHnVErCNWlgJKvWb6ZUKvHH9Zs558btk4k0M8+t0xWyZrJI15rblGT5oWoJzZ59YSPLV2/koqNnccFtj7F89UaG1m7moqNnseu4Ubxy4gAj+o1Tr/z5ttf/13t+y2XvO4Dzb32spSzY0efwlbuXctohM7a9fxRc3j7vELYMlzS3qUFZngdXlMR6Sc65etto/p7UkqRH7yDgCXd/0t03AzcDx8Y3cPd73X1DePMBYCqAmc0CRoQLfOLu68Jg0IC3AbeGz/km8J6Wj6ZBWR2SICIi6YqCwz0njWXXcaP47dA6jrtyIY8sf2FbkAet9cJ1ejhZM72btYLRpL0k8c9yyk6j6euzbcc+cWDkttd/eNkazrlxMe+76n7cnS3Dpe3e++Fla/jSj5fy3bPflHj/a30OFx/z2m1BXnRcp173Cwzbbl8lmaz3JFX6HeZNknOu1jbd7HVVHTofkmTd3BNYFru9HHhjje3PBH4U/n9fYI2Z3Q7MAP4DuBCYBKxx9+HYa+7ZwH63TKl5RUR6U7ynIh6YRJqtzHZjndZGezdr9Q600ksSHftzL7xUs/eh/LGhdZsYNaK/5R6ivj7D3TMdmORNkt6mXpVWL1qSc67WNkNrN3Wl11V16PxINRmLmZ0MDAKXhXeNAN4MnAf8BfBnwOkNvubZZrbIzBYNDQ2ltq+a3Coi0pviPRVrNm5JrReumR62TqvXg9BsL0l07K+btjPzTz6w4uunNa+qWk9CURJ0ZEVR5sGlLe1etCTnXLVtutXr2s06tHoSG5OkR28FMC12e2p433bM7Ajgk8Bb3X1TePdy4BF3fzLc5nvAm4DrgIlmNiLs1av4mgDufjVwNcDg4GBq32b85Jg9bSJzD92biQMj2Ty8lVLJM3VhFpHeojkX7RXvqbjqvt9x6XsP2G5eV3xYVKPfQ5bWaa22/+2a29TXZ+wybjQTB0ZVff1W3zvekzBl/Gg+cvhMZkwex9jR/ewy0Pke1SIryjy4tGVp7mK3el27FWCqJ7FxSQK9h4CZZjaDIBg7ATgpvoGZzQbmA0e5+8qy5040synuPkQwL2+Ru7uZ3Qu8j2DO32nA91s+mgZEJ0eUIaz8Iq8fjYh0gy5k7RcfYvnwsjV88+dP8e0PvZH+cK5ZFBjk+Xuo9zuqVyFtpbGh1uu3GghHlexq1+6ZU8YrMElRlhousiJLcxe7MVwcuhdgZinIzou6gZ67D5vZucBdQD9wnbs/bmafJQjaFhAM1RwP/FuQZ4Wn3f0Yd99qZucB94QJWBYD14QvfQFws5l9jiBr59fTPrha4vMJogtF1LO3ftMwz734Eq+YMEYXCBHpqHZcyHqxh7DWMSfpqejW3Je0tPI7ynJjQ1TJjmf3hPx9P5JfWZq72K1e124FmJ0Osotw7UzSo4e73wncWXbfp2P/P6LGc+8GDqhw/5MEGT3bqtqXFJ0c40b3bwvyavXsFeHLFpHsS/tCluVKe7skOeZ6PRXdaLVP8zrTyv5nudW8UnbPiBKvdEe760dZq391K8ipphu9rt0KMDsZZBfl2plqMpasqTdhtq/PGBg5gqmTBph76N4VWweDdZayu2hoJZqoKpJPpZJjZqkmlOjFxFNpHHOnE3ukfZ1pZf/L57DPP+VALv+b122bw95NUSVa5op0AAAgAElEQVR7w+atSrySAe2uH2Wx/pWHpEudEAWYe+wcnIfPvrCx7XXOTiYIKsq1s9CBXpIvKfrR7DpuVNXWwTx92VksFEWkvujcvXjBr7j0vQekdiHL0nySTknjmDudcTDt60wr+x8FidFIl0t+sITjr36A469+oOvXkyTZPaV5jTYUN/q7bffrd0oR1vBLQ6frnJ0Msoty7Uw0dDOvknxJ0Y/muRerr/2Tpy87y0NuRKS6+Lk7tHYzFx09i13HjeKVEwdami/c7FCXrA2XakQaw3s6PTQpjetM+XfWbGKSSnPYo/3JwvUkSXZPaVwzQ9Ua+d22+/Wlec2W992oc3ZqqGqW5mK2otA9ekmHrvT1Ga+YMKZq62ee1uZRoSiST/Fz9+FlazjnxsW876r7cfdt84SbGZLdTM9O3kcGpNUb18lW+1avM5W+s98OrWPXcaOaXhNv793GZfp6ol6VdDXTe9bI77bdry/NaaW8z3qds5WpTEVZR7LQPXqNTJit1XqbtYm3tRSlBUKk19Q6d1uZFN5Mz1S8QpbHbMTt6o2r1erdag9oq9eZtFvW43PYdT3pDc1U2hv53bb79aU5rZQdWa5ztppMpSjrSBY60Gv0S6rWHZynL1uFokg+1Tp3W63ENzrUJaqQ1ctGXE0U9JRKJbY6uHvHs/GlPbynVqUBWl9zr9XrTDta1ot0PcnzUOROaabS3sjvtt2vL81ppexotozoxPmYRuNXEdaRLHSgB+l9SXn5slUoiuRTrXO31oW40gUTaOkiGlXIqmUjrnWhjAKir9y9lNMOmdFwkFhL/FgHRvXz/IubWgquGlGr0gCk0pvWynWmHS3r9a4neQmeipImvd2arbQn/d22+/Ul0Oh52UrZ0Uyds1PnYx6GlXai/Cx8oNduWbzQqVAUyadq5261C/HAqP4dLpg3nHEQm4ZLDV9Ey4Ooa04dZP2m4YYvlFFA1OyC1tXK1PLKwTdO/wsu+v6vOpYEoF6lodsVinb1vlX7TeYpeFKSsmSSVtqbrffUev0s1qXyqJnzstWyo9E6Z6fOxyIPK22EAr0KkhY4ebrQiUh+VbsQD5d8hwvmH1ZtqBoARcNA6wVRUcC488BAwxfKKCBqZkHrWmVqeeVg7Kj+jgZX9SoNnVzEt9J32OlKdJ6Cp6y37GdJvUp7GvOeyl9fdan0NHNe5jHDcBLdHnpeq9ztZPlZ6KybzWgk+1BW13cRkWKptnbQluHSDhfMagFQqVSqWrZVKstOve4XjBnZ13DWsSggWrNxS8PZ8mqVqeWVg2ZevxW1MrB1KjtbvetTpSyU7cqgmqfgSZkb09OOeo/qUo2rlk2y2fMyTxmGk+rmwvb1yt1Olp8K9Mo0UuDk6UInIvlW6UJc6YK5YfPWihfRrV55HlmlICp6fOPmrQ1fKKOg57bFyxpe+L1WmVp+rFfd9zsue196C8vXU6vS0KkKRTMV4nZVovMUPBUlTXoWtKPeo7pUY2oFEXk4L5s9H5tZKqFbS7DUK3c7+T1p6GaZRgqcLI//FZHiqzQ05VW7jq04XMXd6wZRlcqyRudfREHP5487gFKpxC3nHJw462at/Sg/1qF1m9h9whhun3cIW4ZLHZnXU+uz6MTc6GYqxO2qRDc6LKqbc7CUpCw97aj3FKku1e1skt0erphElhO4pKVSuTtl/Gg2D29lxeoN2+bBd+J7UqBXppECJw8nlIgUV7ULJrDDfavWb04cRLValjUT9JRKTn8fzD/5QM65afEO+6HKenMV4nZVohv5PrJQSVOSstbVO0ebVZS6VLezSZZKJVat38wuY0c21MDWDdH5GAXGz76wsea+5mlOMOxY7s6eNpF/OGo/jr/6ge3mwXeiodLcWxun30mDg4O+aNGitr5HoyeqMkWJtMbMFrv7YLf3oxWdKJtaVa9s62ZZFt+3KeNH85HDZzJj8jjGju5n8rjODbfplnYmAMtCkDW0dhPHXblwh2Azq5W0SBHKJkinfGr3OVqEulSnfueV3ufIWbvx90fsyzk3Ls5Uj1et77WRsmnF6g3MufTeHV5/4QWHseeksR05lkbUyxINrf82kpZP6tErk9Yi640qQiEnItlVr2zrZo9HvLV2+eqNfPD6h7ZdBIteDjZS2WmmVzMLPaGag5V/7T5Hi9Dj2s1skp969yxOuvbBrvZ4lddjJw2M5LdD66qWbY300uVteG95ubu1xtSJdlOgV0Gzw46aDdSy0OIqIp3XTLnRSlmT1cpU1gOBdjbENTokqZnvsNvfe94qabKjrJ+j7ZakDGjH77za+5Y33jT7/aRVtlWqx377Q2+sWbaV7/PsaROZe+jebNg8zNBattuXPA7vjZe7Q2s3da0MVKCXglYDtbyNPRaR1uV1GF47tFpBamcg1u7PvBcq0HmspMn2ejlYT1oGpP07r/e+8fphM4FEmmVbpXrsyrWbapZt8d/U7GkTOe8d+3HBbY9V3JcsjExoRTfLQC2vkIJW01f3woVeRLaXpVT53dZK+vt2rRMXafdnnod06K3q5npWko5eXqIiaRmQ9u+8kbKnme8nzbKtUj02SgAWFy/b4vs899C9twV51fYlraUSmlmmoVXdLAPVo5eCVgO1Xm4pE+lVWUqV322ttNa2e0REuz/zXunt6vbwUWlN3ntUWtFIGZDm77zR9y3/fiYNjKw50iHNsq1SPfa2xcuYf8qBOySIicq2+D5v2DzckWtbN0fFdKsMVKCXglYDtXZd6JXgRSS70k6Vn/fzvdmLYLsDsXY3xPVyBVrypVeD9W41xjf6vvHvJ0lAk+ZxVarHfvTt+zFzyviaZVu0z0Nr6chn3ItTpTR0MwWtDmloR5duu4cziUhrmik3qj1n0sDInj3f2z30sRND1tIakiQi9TU6dK9bw1Zbed8kwzLTPK5q9dgRI/oSlW2d+oyLOiqmFq2jl5Kstabndd0i6T1FWKuq2bIpraybq9Zv7tnzvRNDcbJWvktnFKFsgmzXnTqt2fKiW2VAs+9bbd25Bz/xNvr6+rYb3rl645ZEr9/uz6ATn3E36sbtOi6to9dh7RrS0OwPpBdbLUTyJq1U+b18vndi6GOvDllrJwXP0g3NDt3rVhnQ7PtWGpZ55Kzd+OP6zU0tqt6JBrVOfMadnhOdhUzZGrqZYa0Mv+yFTG4iEuj1811DH/NFUwukW3qlUazSUMhPvXvWtiAPGsuyWZSMz53OfpmFz02BXoa18gPp5VTIInnTarrnbp3vrex3N1JcSzZ0ovKj31f3ZPmz75VGsUoBTX+fNR3k5iVATvLb62TDYBY+Nw3dzLBWfiDK5CaSD2kM7ejG+d7KfmdhOIt0T7srP/p9dU/WP/teWc4EdhwK2cyi6pGsLwNWKjlrNm7m2TUvcc5NjQ9NbZcsfG7q0cuwVlueNJxJJPvS6t3o9Pke3+/Z0yZy0dGzWL9pmOdefKluC34WhrPI9jrZC9PuXhX9vron6599vFHswU+8jVvOOZgJY0awav3mTPU8tkMrIz/SGjXSjnImalx4dNkL24I8yMZvLwuj69Sjl2G91PIk0quyMLSjGdF+z542kfPesR8X3PZY4lbUvB5zXjSa6KTTvTDtvrbp99U9efjs+/qMXceNynTPYzu0MvIjjVEj7SpnosaFy//mdU399tqZGCoLo+sU6GVU9MPbZexIbjnnYNxdwy9FGmBmRwH/AvQD17r7F8senw58E5gYbnOhu99pZiOBa4E3EJSRN7j7F9q1n1kY2tGMaL/nHrr3tiAPkmWxa/SYlaExuWYqU51eRLjdlZ+8nlNFkJfPvhcXzobWMls28tzyMnvSwEhWrtvUls88alxYs3FLw7+9omQTrfn+XXvnHtBsF3U8I9kbv/CfvH/+/bz40rAqNyIJmVk/cAXwTmAWcKKZzSrb7FPALe4+GzgBuDK8/2+A0e6+P3AgcI6Z7dWufc3C0I5mRPu967hRDbWilkpOfx/MP/nARMesDI2NaWboXDd6Ydo51Div51QR5OWzz0PPY16Vl9mfvOMx/vf5tTyzZmNbPvOoceGq+37Hpe89oKHfXtLyMssJhupRj16bVGoluOGMgxg/ZgRbhktVWzBLJee5F1/qyZYmkRQdBDzh7k8CmNnNwLHAktg2DkwI/78z8Ezs/nFmNgIYADYDL7ZrR7MwtKMZ0X4/9+JLiVtR4+XilPGjueTY1zJj8jjGju5n8rjKlf1WW9673RvY6fdvpgKb9V6YRj/DvJ5TRdCJzz6Ncyrrv/k8Ky+z33vgNObetJiLjp7Vls88PhT8y3ctTXRdiSQpL2v1+kXHm+VyRoFeHc0WKOU/9CnjR/P8iy9x6nXV57FEP6b1m4bb1tLU7UqPSIfsCSyL3V4OvLFsm4uBn5jZ3wHjgCPC+28lCAqfBcYCH3X3P5W/gZmdDZwNMH369JZ2tttDO5rV12e8YsKYxPOt4uXi8tUb+eD1DzF10gB3zJvTlvl83c4A2I33b6YCm+X54M1+hnk9p4qglSF+nZpPmuXffN6Vl9kTB0ayfPXGbT1u5fO5W/3MW2lcSFJeVmtsXHDuHJ5/cVPXri9JaehmDZWGDP1+1XpWrn2J51/YyDNrNlbtxi3/oc89dG/Ov3XHeSzx7uHox7Rq/ea2ZCTTECiR7ZwIXO/uU4F3ATeaWR9Bb+BW4JXADODjZvZn5U9296vdfdDdB6dMmdLJ/c6URhagbaW3KS5pedjtDIDdeP9mhs51ehHhRnT7O2wHMzvKzJaa2RNmdmGVbd5vZkvM7HEz+3bZYxPMbLmZfbUze9we1eokw8OlqsPk0sxS3O7ffJ6H+7WivMyO5s49vGwNX75rKRcdPYtb5x7MLeccXPEzb+Zza3YoeJLystp1a+Pmrbkom9SjV0O1Xrkv/ugpTjtkRs0sc+WtBFGLRlx5BSf6MbWr1aNXJx9LT1oBTIvdnhreF3cmcBSAu99vZmOAycBJwI/dfQuw0swWAoPAk23f6wZkqXc+aQt+I71N0fGVSiXmn3Ig59y4uOHysNvzcLo1962Z1u2s9oB1+ztMW2z+8NsJRho8ZGYL3H1JbJuZwCeAOe6+2sx2K3uZS4CfdWqf26VSneQrdy/l74/Yd4fzPapfpfl7aOdvvtujCbqpvLf0tsXLuOrkA5l702IeXraGS36whGtOHeQVE8ZUDPI6+bklKS+rXbe2uueibFKgV0O1XrmLjp5VN8tc+Q99w+atdSs40Y8p3uqx67hRvHLiQMUTotXjifY9az9KkRQ8BMw0sxkEAd4JBAFc3NPA4cD1ZvZqYAwwFN7/NoIevnHAm4B/7tSOJ5HXSkTS4VLlx3fkrN349ofeSH+fpT4sp5269f5ZDdqSKG/AGDmir2hzqZLMHz4LuMLdVwO4+8roATM7ENgd+DFBA1RuVaqTvPfAaduCPNixftXtczqpXm5YrxQ8TRoYmajxqRufW73ystp1a8zI9H6LbV3iIZVXKajy7ueoVy5J71z5sIDXTdu5bvdwvAs5avUYN3pEKkFepeOJ9iNrBaRIq9x9GDgXuAv4NUF2zcfN7LNmdky42ceBs8zsUeA7wOnu7gSt7ePN7HGCgPEb7v5Y54+iurwOZ0s6XKr8+H6yZCUnXfsgo0b0pz4sp526/f55U2ko37qXhov2GVaaP7xn2Tb7Avua2UIzeyBcKoZwaPnlwHn13sTMzjazRWa2aGhoKKVdT1elOkm9LL55Oad6vWG9fCjliBF9iYZWZvFzq3bdmjxudGqLyLdzWlWiHr0E61F9DPgQMEzQIn6Gu/8hfGwr8Mtw06fd/Zjw/uuBtwIvhI+d7u6PtHQ0KavWK1dvrY7yyHyPnQfo6zMmDoyq2aLR7mxVmnwsvcTd7wTuLLvv07H/LwHmVHjeOoIlFjIrixfDpJL0NqV1fN3Ovtjt909TJ4YKV2rAOPW6X7Dg3DmF+AwbMAKYCRxKMOz8Z2a2P3AycKe7LzerffzufjVwNcDg4GAmJ4dVqpPsttPomvWrvJxTeel5zJpOfm6NlGnVrluVfosAQ2s3Jf59trsXs26gl2Q8OfAwMOjuG8zsw8CXgOPDxza6++urvPz57n5r87vfXuUFysCofq45dZCv3L206hy6ekOq6n1p7Rxyk5cCUkRqK3olIs3j6/Ywxm6/fxo6NVS4VtKDPSeNTe19uizJ/OHlwIPhPOGnzOw3BIHfwcCbzWweMB4YZWbr3L1iQpcsqFWZrjbEr16DdB7OqSI3rLez0adTn1taZVr0W4w+k6G1L/HH9ZurzjGtpN0NtxaMVKqxgdnBwMXu/o7w9icA3P0LVbafDXzV3eeEt9e5+/gK210P/KCRQG9wcNAXLVqUdPO2iCcI2Org7tv90IfWbuK4KxfuUEHphXHZIs0ws8Xunuu5Jp0um/I6Ry+poh9f3nTqupa162c7yqZwfc7fEMwPXkEwPPwkd388ts1RwInufpqZTSZoTH+9u6+KbXM6QQP7ufXes1t1p2bP4ywlmmpFlo+j2X3rRNncic8tzbIm/plcdPQsLvnBkoZet9l9SVo+JRm6mWQ9qrgzgR/Fbo8xs0UEwzq/6O7fiz32eTP7NHAPcKG7b0qwP11VryUpz0OqRCQfutk734mLsEYfZEunrmtF7gWJuPuwmUXzh/uB66L5w8Aid18QPnakmS0hWOrl/HiQlxfNDknLQ49dEu04jjTK31aCtU4kS+nE91+pTJsyfjSbh7eyYvWGptfNTpLDo1y7y71Us26a2ckEWaDeGrv7Ve6+IlyH6j/N7Jfu/juC1MHPAaMIxpFfAHy2wmumtihxJxR9SJWIdE69YU+drgx1soW+KJW9IujUda1XAvwE84cd+Fj4V+01rgeuT2uf2tGAo4bvdKXVm9ZKsFaU77S8TJs9bSL/cNR+HH/1Aw1/tvHPpF4Oj0raXe4lybqZZDw5ZnYE8EngmHjPnLuvCP99ErgPmB3eftYDm4BvEKQc3kHeFiXOS0YoEcm2dmfiit6jkYVpm8n22YnjyKIiLZbcyetaswsfS/PadY4WMdN3N8/rtLIttxKs5fk7jX93/X1sV6Z95PCZnH9rkHdj9rSJXHT0LNZvGua5F1+q+x3HP5NoHexGy8p2lntJevTqrkcVzsubDxxVtt7LJGCDu28Kx5nPIUjUgpnt4e7PWpA66j3Ar9I4oG7rlRZJEWmvdg+RaaZ1uJkKQi+uJ1W0OYa6rhVbu87RLA3F7faQxzSk1ZvWSg99lr7TRlT67m444yBun3cIW4ZL2xY/nz1tIue9Y78dki3W+o7jn8nDy9bwzZ8/1dS6r+1SN9BLOJ78MoIMUP8WpvyNllF4NTDfzEoEvYdfjGXr/JaZTQEMeASYm/KxdY2GHIlIq9o9RKaZyl0zFYSiDPVpRBGDW13Xiqtd52hWGgiyMOQxDWkNoW4lWMvKd9qoaku33DFvDntOGsvQ2k1MnTTA3EP33hbkRdvV+46z/pkkmqOXYDz5EVWe93Ng/yqPvS35bhZLljMxiUg2tHteVDOVu2YqCL04b7kXg1vJr3aeo1loIEgrQOv2eZ1Wb1qrgUkWvtNG1fvuos92/abhpr7jLH8mqSZjkfq63fUvIvnQ7iEyzVTumqkg5HWoTyt6MbiV/Cr6OZqFIY9pSLPnKMuBSTvU++6iz/a5F18qXNlddx29LMnCOnqtyto6QSLd1ivr6DXTk9+u3v9SyVmzcTPPrnmJc25KvrBrK+/XS6MY1KBXDEUom6B95VNepFXv0nmdX0m/uzx9x2muoycp6nbXv4h0XrMXj3atwxTty5Txo7nk2NcyY/I4xo7uZ/K49mQ57LXW46zP2RAp18w5mpfgMCtDHqV7kn53RfyOFeh1WLe7/kWk87o9ib/avixfvZEPXv/QttbtPF/MsqbXglvpLXnq+dCQR4Hk313RvuMk6+hJirTOnkjvyVJPfpb2RUTyKa013TpF6zNKr1KPXocVsVtYRGrLUk9+lvZFRPJJDUYi+aAevQ4olZyhtZtYsXoDQ2s3AahlSaSHZKknv96+lJdXpVJ+EnaJSGdEDUZxajDKpryX6Xnf/25Tj16b5Wkcu4i0R5Z68mvti8orEUmi6EsyFEXey/S8738WqEevzfI2jl1E2iNLc0Sq7YvKq/xQK7d0U7zBaOEFh3HHvDmqfGdQ3sv0vO9/FqhHr806OY49L6mORSSbNO8mH9TKLVlQtOyERZT3Mr3e/qveW5969NqsU+PYowv/cVcuZM6l93LclQtZ+vzaba28av0VkXo07yYf1MoteaM6SHfkvUyvtf/16r0SUKDXZp1KwlDrwq+TQUSSyFLSGKku76300lt6oQ6S1UC20TI9a8dRa//V4JWMhm62WaeSMNS68GdpsWYRya4sJY2R6rREhuRJ0esg9YZSd3N4YSNlehaHhNfafzV4JaMevQ7oRBKGWt3bOhlEJKksJY2RytTzKnlS9DpI1kdUJS3Ts9pDVm3/8z4stVMU6OVYvIu9v4+qF36dDCIixaGMh5InRa+DNDOiqtvBUyV5C8jV4JWMhm7mVKUu9hvOOIjb5x3CluHSdt3bWu9GRKRYlPFQ8qLodZBaQ6nzFDzlbUi4phoko0Avpyq1Ep163S+4Y94c9pw0drttdTKIiIhINxS9DlIrkF21fnNugqc8BuRq8KpPgV5ONdpKpJNBREREuqHIdZBagWyzwVM3ErgUPSDvVQr0cqhUcswsN61EIiIiIkVVLZBtJnjqZvbLIgfkvUrJWLqomfVKogLg4gW/4tL3HqBJqCKSGVlbg0nq03cm0l6NZjLOUwIXyT716HVJsy028QJgaO1mLjp6FruOG8UrJw7wiglj1MUuIl2RxTWYpDZ9Z5Jl3Vx/rpvylMBFsk89el3SbItNvAB4eNkazrlxMe+76n7cvScKQBHJJrVC54++M8mqLKw/1y1FX46i13V6FIUCvS5ptsVGBYCIZJFaofNH35lkVScbIbI2fFnrwxVXNxowFOh1SbMBmwoAEckiNULlj74zyapONUJksecwnsBl4QWHcce8ORpOXRDdGEWhQK9Lmg3YVACISBapESp/9J1JVnWqESKrw5cbTeAi+dCNURRKxtIlraxXUp7+Nhp20GsTlkUkO7QGU/7oO5Os6tTi3Rq+LJ0UNWB0cmk0BXpdlMZ6JcqaJiJZoTWY8kffmWRRpxohulHxlt7VqQaMOAV6OVdt2MEd8+bo4i2SUb2aNlxEJKlONEJ0o+ItvasboygU6OWchh2I5It64UVEskHDl6XTOj2KQslYck5Z00TyJauT/0VEelEriU+ytjSDSDkFejmnrGki+aJeeBGR/Gt1aQYFidIJGrqZc+0cdqB5RCLp0+R/EZH8ayVHgobwS6eoR68A2rHeSlqLiKrFSmR76oUXEcm/VkZnaAi/dIp69KSieCE0e9pE5h66N+s3DfPciy/xigljEgWTarES2ZEm/4uI5F8rozM0hF86RT16OdGpnrHofTZsHt4W5J33jv245AdLeN9V9/P++fcn7tlTi5VIZe3ohW839c6LSC9IWta1MjpDifSkU9SjlwOd6hmLv89FR89i6qQB5h66Nxfc9lhTY9DVYlVsWZ/DaWZHAf8C9APXuvsXyx6fDnwTmBhuc6G732lmHwDOj216APAGd3+kM3uePeqdF5Fe0EhZ18roDK3fJ52SKNBLUGH6GPAhYBgYAs5w9z+Ej20Ffhlu+rS7HxPePwO4GdgVWAyc4u7q6qmgU4uix9/nqvt+x6XvPYDRI/q2vW80hHPiwEg2D2+lVPKaBVp8WEP03F3HjcLM6j5Xsi3rFX8z6weuAN4OLAceMrMF7r4kttmngFvc/WtmNgu4E9jL3b8FfCt8nf2B7/VykAedK4NERLqp0bKu2TXRNIRfOqXu0M1YhemdwCzgxLBSFPcwMOjuBwC3Al+KPbbR3V8f/h0Tu/9S4Cvuvg+wGjizheMotE71jMXf5+Fla/jyXUvZeWAkUycNbDeE8/irH+D4qx+oO4QzarE6ctZuTQ//lGzKwbDcg4An3P3JsAHpZuDYsm0cmBD+f2fgmQqvc2L43J6m3nkR6QXxsm72tInMP+VALv+b121r3E5THofwS/4kmaNXt8Lk7ve6+4bw5gPA1FovaGYGvI0gKIRg+NR7GtnxXtKpsdzl7/PwsjVcdtf/Mv+UA/nI4TMrDuGsVbGPWqwuPua1DT9Xsi0HFf89gWWx28vD++IuBk42s+UEvXl/V+F1jge+U+kNzOxsM1tkZouGhoZa3+MM03wSEekFUVnXTOO2SBYlCfSSVJjizgR+FLs9JqwMPWBmUTC3K7DG3YcTvmZPa2c69vik4/4+dnifj759P/bbbSf23m1cUxX7vj7D3bMeFEiDClLxPxG43t2nAu8CbjSzbWWimb0R2ODuv6r0ZHe/2t0H3X1wypQpndnjLtGSECLSC6KyrpnGbZEsSjUZi5mdDAwCb43d/Sp3X2Fmfwb8p5n9Enihgdc8GzgbYPr06Wnubm60ayx3pXlWN5xxELfPO4Qtw6Xt3mdg5Iim0whrgejiycFE8hXAtNjtqeF9cWcCRwG4+/1mNgaYDKwMHz+BKr15vUbzSUSkF0Rl3bjR/WqglkJI0qOXpMKEmR0BfBI4xt03Rfe7+4rw3yeB+4DZwCpgoplFgWbF1wyf1zOt5rW0Yyx3pXlWp173Cwzb4X1aadFXb0DxxCv+Cy84jDvmzclMIpbQQ8BMM5thZqMIgrYFZds8DRwOYGavBsYQJJMi7Nl7P5qft43mk6RHS1VI1vXybzTeuB2nBmrJoyQ9etsqTATB2AnASfENzGw2MB84yt1Xxu6fRDD0aZOZTQbmAF9ydzeze4H3EVSkTgO+n8YBSXKNzLNqpUVfvQHF1Gy2sU5w92EzOxe4iyBb8HXu/riZfRZY5O4LgI8D15jZRwkSs5zu7qETxVYAACAASURBVFFt5i3AsrCBSiQ1Wc9YK+1XL5N5uM37CeYRO/Cou59kZq8HvkaQRGor8Hl3/27a+6ffaC5GrYgkUjfQS1hhugwYD/xbkGdl2zIKrwbmm1mJoPfwi7H05hcAN5vZ5wiydn495WOTOhodUllesY9a/JIEb1kOCqSY3P1OgiQr8fs+Hfv/EoLGp0rPvQ94Uzv3T3qTlqrobUmWfjGzmcAngDnuvtrMdgsf2gCc6u6/NbNXAovN7C53X5PmPuo3qgZqKY5Ec/QSVJiOqPK8nwP7V3nsSYKMntIlrbRYqcVPRKRxOchYK+21LZM5gJlFmczja3yeBVzh7qsBopFS7v6baAN3f8bMVgJTgFQDvSL8RkslZ9X6zS0FaWqgliJINRmL5EsrLVZq8RMRaZySUyWXRmU9gyplMn9j2Tb7ApjZQoKRVBe7+4/jG5jZQcAo4Hdp72Def6NqiBZ5WZJkLFJgzSZYKEKLn4hIpyk5VTJRZf24Kxcy59J7Oe7Khb20jtkIYCZwKMEyMNeY2cToQTPbA7gR+KC7lyq9QCvrfOb9N1qtIVpLI0gvUo+eNCXvLX4iIt2guT/JFHjUSJJM5suBB919C/CUmf2GIPB7yMwmAD8EPunuD1R7E3e/GrgaYHBwsKHoOO+/UTVES7vlabSBevSkKXlv8RMR6RYtVVFfgSvrSZZ++R5Bbx5hxvJ9gSfD7e8AbnD3W9u5k3n+jUYN0XFqiJa05G20gQI9aUqr66j18ho9IiJSW1Er6+4+DESZzH8N3BJlMjezY8LN7gJWmdkS4F7gfHdfRbC251uA083skfDv9V04jExrtiFa9RJJIm9DgzV0U5rWbEYqTZQWEZFairyOWYJM5g58LPyLb3MTcFMn9jHP4g3RpVKJrQ7uwVC7akPsVC+RpPI22kCBnnRcgedeiEjG5WluRS/L+zwx6a6+PmPXcaMSB2+ql0hSectRoaGb0nF5aw0RkWLI29yKXpfneWLSfY0MsVO9RJLKW44K9ehJx+WtNUREikGt9iK9o5HgTfUSSSpvow3UoyepSjKZOW+tISJSDGq1F+kdjST0Ub1EGpGn0Qbq0ZPUJJ3MnLfWEBEpBrXai/SORhL6qF4iRaVATxpWLZlBI8Oims3YKSLSrCJnchSR7TUavKleIkWkQE8aUqvXTsOiRCTL1Gov0lsUvEmv0xw9aUitLFZFXeBWRIojT3MrREREWqFAr0clSZpSSa1eO01mFhERkXZott4i0ss0dLMHJU2aUkmtZAYaFiUiIiJpa6XeItLL1KPXgxpZRLRcpV67G844CMdZsXoDq9ZvZtdxozQsSkRERFLRSr0lK9QjKd2gHr0e1ErSlPJeu4FR/Tz/4iZOvfLnamUTERGR1OU92Zt6JKVb1KPXg1pNmhJPZrC1RO5b2URERCS78p7srQg9kp2mHtB0KNDrQWkmTcl7K5uIiIhkW96Tvamu1JioB/S4Kxcy59J7Oe7KhSx9fq2CvSZo6GYPSjNpSq3kLCIinVYqOavWb1ZCKJECqVdvyfp5r7pSY6r1gN4xb47WRWyQAr0eldYiolErW/m48zRa2bJecItItmgejEhxVau35OG8T1pXUr0noB7Q9CjQE6D5wiXN3sH4PkRJXrJccItItqgVWKT35OG8T1JXykPA2inqAU2P5uhJy2Oh48lZml1SoXwfHl32giYui0hD1Aos0nvyct7XqyspYcvL8j4nM0vUoydtaQ1rtIewfB/GjurPRcEtItmhVmCR3lOU8z4vAWsnpDlarNepR09SL1ya6SEs34c1G7fkOpWyiHSeWoFFek9Rzvu8LyGRtjRGi4l69IT0W8Oa6SEs34er7vsdl73vAM6/9bHUk7yISDGpFVik9xTlvG9ncjvpXQr0JPXCpZkewvJ9GFq3id0njOH2eYewZbiUWpKXvF4ARCSZtDIKi0h+FOG8L0rAKtmiQE9SL1ya6SFsVwGnLFYiIiKSB0UIWCVbNEdPgHTHQjc7Xr4d47GVxUpEREREepF69CR1WRp+kFaimWrDPzUsVERERESySIGetEVWhh+kkWim2vDPmVPG89uhdRoWKiIiIiKZo6GbUmhppF2uNvxz5bpNGhYqIiIiIpmkHj0ptDSGkVYb/rlla0mLm4qIiIhIJinQk1yL5siVSiW2Orj7DsFcq8NIqw3/HNnfl+r6gyIiIiIiadHQTcmtaO7cJ+94jCeG1vP++fcz59J7Oe7KhSx9fi2lkqfyPtWGf+42fnTLw0JFpHeVSs7Q2k2sWL2BobWbUiuzREREIGGPnpkdBfwL0A9c6+5fLHv8Y8CHgGFgCDjD3f8Qe3wCsAT4nrufG953H7AHEHWHHOnuK1s6Gukp0dy5i46exQW3PbbDXLk75s1JJSFMreGfWckuKiL5ojU+RSSrlFG8OOoGembWD1wBvB1YDjxkZgvcfUlss4eBQXffYGYfBr4EHB97/BLgZxVe/gPuvqjpvZeeFs2dmzgwsu1z5aoN/4zfr4JRRJKqluQprQYqEZFmqBGqWJIM3TwIeMLdn3T3zcDNwLHxDdz9XnffEN58AJgaPWZmBwK7Az9JZ5dFAtHcuTUbt2wbPhlJa65c0qFVUcF43JUL2zJ8VESKJa01PkVE0lStEUoZxfMpSaC3J7Asdnt5eF81ZwI/AjCzPuBy4Lwq237DzB4xs4vMTM0EPSDNOSnR3LnbFi/j0vcekPpcuUaCNxWMItKIqKEqTsmcRKTb1AhVLKlm3TSzk4FB4K3hXfOAO919eYU47gPuvsLMdgJuA04BbqjwmmcDZwNMnz49zd2VDkt7OEA0R+7zxx1AqVTilnMOrph1s1mNDK1SwSgijYgaqsrLQyVzEpFuqpZpXI1Q+ZSkR28FMC12e2p433bM7Ajgk8Ax7r4pvPtg4Fwz+z3wZeBUM/sigLuvCP9dC3ybYIjoDtz9ancfdPfBKVOmJDooyaZ29HpFc+R233mAV04cYM9JY5my0+hUxpE3ErxltXW+l7P6mdlRZrbUzJ4wswsrPD7dzO41s4fN7DEze1fssQPM7H4ze9zMfmlmYzq791J08WROCy84jDvmzdEcGBHpumqZxtUIlU9JevQeAmaa2QyCAO8E4KT4BmY2G5gPHBXPnOnuH4htczpBwpYLzWwEMNHd/2hmI4Gjgf9o9WAk26oFTqVSiaG1mzKXxKSRVq0sts738oTqhEmkPgXc4u5fM7NZwJ3AXmH5dBNwirs/ama7Als6fAjSA1pd41NEJG3KKF4sdQM9dx82s3OBuwiWV7jO3R83s88Ci9x9AXAZMB74t3CI5tPufkyNlx0N3BUGef0EQd41rR2KZF2lwOnIWbvxx/WbOefGxZkLRhoJ3rJYMPZ4Vr9tSaQAzCxKIhUP9ByYEP5/Z+CZ8P9HAo+5+6MA7r6qI3ssIiKSAWqEKo5Ec/Tc/U6C1u74fZ+O/f+IBK9xPXB9+P/1wIEN7KcUQKXA6VPvnsVJ1z6YiWCk0vIIjQRvWSsYe3zeYKUkUm8s2+Zi4Cdm9nfAOCAqx/YF3MzuAqYAN7v7l9q7uyIiIiLpSjUZi0gtlXq92hWMNLqmXa1hjlkK3hqhCdV1nQhc7+6Xm9nBwI1m9lqCcvEvgb8ANgD3mNlid78n/mQlihIREZEsS5KMRSQ1Ua9XlDSlHUlMmlnTrojLI/T4hOokSaTOBG4BcPf7gTHAZILev5+5+x/D9UHvBN5Q/gZKFCUiIiJZpkBPuqodwUgzQVsRhzn2eFa/bUmkzGwUQRKpBWXbPA0cDmBmryYI9IYI5iPvb2Zjw8Qsb2X7uX0iIiIimaehm9JV7Uhi0kzQVtRhjlmbN9gpCZNIfRy4xsw+SpCY5XR3d2C1mf1/BMGiE6wF+sPuHImIiIhIcxToSdelHYw0E7RlcXkEaU2CJFJLgDlVnnsTwRILIiIiIrmkQE8Kp5mgLYvLI4iIiIiINEuBnhROtaANqLkwe5aGOTaaNVREREREJE6BnhRSedBWa/mErAVQedpXEREREckmZd2UnpCn5RPytK8iItIYMzvKzJaa2RNmdmGVbd5vZkvM7HEz+3bs/tPM7Lfh32md22sRySP16ElPiGfinD1tInMP3ZuJAyPZPLyV4eESqzduaWiYZDuHVhZxqQcREQEz6weuAN5OsGbnQ2a2IEwOFW0zE/gEMMfdV5vZbuH9uwD/CAwSZAReHD53daePQ0TyQYGe9IQoE+eU8aM57x37ccFtj7F89UaOnLUbHzl8X+betDjxMMl2D60s6lIPIiLCQcAT7v4kgJndDBzL9mt1ngVcEQVw7r4yvP8dwN3u/qfwuXcDRwHf6dC+i0jOaOimZE6p5Ayt3cSK1RsYWruJUslbfm6UifMjh8/cFuQBvPfAaduCPEg2TLLdQyvbsYi8iIhkwp7Astjt5eF9cfsC+5rZQjN7wMyOauC5IiLbqEdPMqWV3rJ6z91v950YN7p/u56yiQMjGx4m2e6hlVrqQUSkp40AZgKHAlOBn5nZ/o28gJmdDZwNMH369LT3T0RyQj16kimt9JbVe25fnzEwcsS2njKANRu3bHcb6g+TjIZW1ntOKz2TUdbQPSeNZcpOoxXkiYgUwwpgWuz21PC+uOXAAnff4u5PAb8hCPySPBcAd7/a3QfdfXDKlCmp7byI5IsCPcmUVnrLkjy3fFjkbYuXcdXJBzY0TDLJ0Mqod/G4Kxdy7rcf5lcrXuDpP21g5dqXGgr4RESkUB4CZprZDDMbBZwALCjb5nsEvXmY2WSCoZxPAncBR5rZJDObBBwZ3iciUpGGbkqmtJKIJMlzKw2LnDQwsqFhkkmGVka9i+XJX+oNRdVC6SIixeXuw2Z2LkGA1g9c5+6Pm9lngUXuvoCXA7olwFbgfHdfBWBmlxAEiwCfjRKziIhUokBPMiXqLSufZ5ckEUnS55Yvpg7scLueSq8RF/UuXnT0rO2Sv0TDSe+YN2eH52uhdBGR4nP3O4E7y+77dOz/Dnws/Ct/7nXAde3eRxEpBgV6kinVetyS9HJlKYlJ1LvYSLKXanMMKwWFIiIiIiK1KNCTzIn3lpX3ch05azc+9e5Z9PdZxUCuXk9bp0S9i8+98FLioahaKF1ERERE0qJkLJJp8V6u2dMmctohMzjp2gczn+Ak6l183bSdmZ8w2UvSbJ4iIiIiIvWoR08yLd7LNffQvbngtscaTnDSLX19xi7jRjNxYFSi4aStzE8UEREREYlToCeZFs+kGc13ayTBSRb8/+zdfbhddXng/e+dhIQQgolwipAXYTSlZixT9BRr046oWGNroXlsK1iLTC2RoYx9am3BR0utttNCWzt1hCpaqtQKKpROqjj4MvhYM2IJA6JAUyO+JAHDMUQJARKSc88fe+10Z3NOzst+W2vt7+e6zsXZa6+9931WDr+z7nX/1v2b7nTSMt1jKEmSpGpz6qZKrXXNuubi5jNpcFI1LpQuSZKkbrCip1JrrXKNj4/zvl99Pg89snfWa+1JkiRJw8CKnkqvWeU6/mkLec4zjplRgxNJkiRpGFnRU6XMtMHJ4YyP57TW55MkSZKqxkRPldTpennt6/NNt3Nnt5NDk01JkiT1gomehlLr+nwwvc6ds00OJ9Pt95MkSZKavEdPQ6l1fb6mqTp3TpYc7tyzb1YxdPv9JEmSpCYTPQ2l5vp8rabq3Dmb5PBwuv1+kiRJUpOJnoZS6/p8ML3OnbNJDg+n2+8nSZIkNXmPnoZS6/p8022E0kwO2++pm+6yDu2NV5YuPKKj95MkSZImY6KnoTXTzp2zSQ6bJmu8smrk6I6XiZAkSZLamehJMzDbZR1aG6+ctmIJF57xLPbs3c9Dj+7lGcccObDkzuUdJEmS6slET+qyiZKnZuOV01Ys4c0vP4VLbry74yUVOk3SplrewSRQkiSpumzGInVRM3lad9VG1lx+K+uu2sjmHbs5Yt4cli9dyIVnPOtgkgezX1Jhss8ZH89pv8fhlnfoxvtLkiRpcKaV6EXE2ojYHBFbIuLSCZ5/U0TcGxF3R8TnIuKZbc8fExHbIuI9LdueHxFfLd7z3RFhqUClMT6ejO3ey/ZdjzG2e++0E5zJkqd5c+Jgo5VuLKnQjTX4Dre8g2v8SZIkVduUiV5EzAWuBF4BrAbOjYjVbbvdCYxm5qnADcAVbc+/E/hC27a/Ai4AVhVfa2ccvdQDnVSzJkueHt93gFOOX8yJSxZ2ZUmFbqzBd7jlHVzjT5IkqdqmU9E7HdiSmfdn5j7geuDs1h0y89bMfKx4eBuwvPlcRDwfOB74dMu2E4BjMvO2zEzgWuAXOvpJpC7ppJp1uORpzpzgGcccOeP1+2b6OdN1uLUEXeNPkiSp2qbTjGUZsLXl8TbgBYfZ//XApwAiYg7w58BrgTPb3nNb23sum0YsUs91Us2aaq29TpZomMnnTMfhYunG+0uSJGlwutp1MyJeC4wCLyo2XQTcnJnbZnsLXkSsB9YDrFy5shthSofVrGa1JnvTrWZNJ5Gb7RINM/2c6b7PRLF06/0lSZI0GNNJ9LYDK1oeLy+2HSIizgTeCrwoM/cWm18I/HREXAQcDcyPiEeBv6Rleudk7wmQmVcDVwOMjo7a8k8912k1qxuJXBk+p18/hyRJkrpvOone7cCqiDiZRjJ2DvCa1h0i4jTgfcDazHyouT0zf6Vln/NpNGy5tHj8SET8BPBl4Dzgv3f2o0jdUfVqluvfSZIkacpELzP3R8TFwC3AXOCazLwnIt4BbMrMDcCf0qjYfbyYovmdzDxrire+CPggsJDGPX2fmvVPIXVZVatZUy2CLkmSpOEwrXv0MvNm4Oa2bZe1fH/mU1701Pf4II3Ervl4E/DcacYpaRom6xh600VrKpm4SpIkaXa62oxF0mDNtmPo4aZ7OhVUkiSpekz0pBqZTcfQw033BJwKKkmSVEHTWTBdUgmMjydju/eyfddjjO3ey/j4U5vQHm4R9MkcboH4ThaPlyRJ0uBY0ZMqYLpNVibrGAowtnvvhNMvp5ruOdvF4wctItbSWMplLvCBzPyTtudXAh8ClhT7XJqZN0fEScB9wOZi19sy88J+xS1JktQNVvSkCphJZa3ZMXTZ0qMONmDZvGM3667ayJrLb2XdVRvZvGP3wYpgc7pnq+Z0z8M9V2YRMRe4EngFsBo4NyJWt+32NuBjmXkajWVjrmp57huZ+WPFl0meJEmqHBM9qcSa0zUf27d/1pW1iZLEv/jMZr77yBNs3/UYc+cw6XTP2UwFLYnTgS2ZeX9m7gOuB85u2yeBY4rvnwY80Mf4JEmSesqpm1JJtU7X/L1Xrp5xk5Wm9qmZp61Ywut+8mR++X1fOjgN9NpfO52/v+gneXL/+FOmdlZ08fhlwNaWx9uAF7Tt83bg0xHxX4BFQOsyMSdHxJ3AI8DbMvOf2j8gItYD6wFWrlzZvcglqYLs0CyVjxU9qaRaK3Hv/fw3uPxVp86qstY+/fLCM57FJTfefUiF77xr/pkgDk73bL/vb2TxAk54WuM9HvzB45M2g6mYc4EPZuZy4GeBv42IOcCDwMpiSuebgI9ExDHtL87MqzNzNDNHR0ZG+hq4JJVJ88LkZLcISBoMK3pSSbVW4u7c+n3+7JbN/N4rV/OcZyxm4fx5075a2px+2Uwaj100f8bTQKfbDKZEtgMrWh4vL7a1ej2wFiAzvxQRRwLHZeZDwN5i+x0R8Q3gh4FNPY9akiposvvIb7pozcF7xSX1nxU9qaTaK3F3bv0+7/zEvSycP+8pVbfDae3EufGSF3PikoUzbrBSwWUWbgdWRcTJETGfRrOVDW37fAd4KUBEPAc4EhiLiJGimQsR8e+AVcD9fYtckipmqu7NkgbDRE8qqW42QmntxPmMY46c8ftO94/4dNb664fM3A9cDNxCY6mEj2XmPRHxjog4q9jtt4ELIuIrwHXA+ZmZwH8E7o6Iu4AbgAsz8+H+/xSSVA1V7dAs1Z1TN6WSmmxNvE6nSs7mfZt/xA/XDKZs0zsz82bg5rZtl7V8fy+wZoLX3Qjc2PMAJakm2m8RqFCHZqnWTPSkEmtW4gb9vtP5I+49GpI0nHp1YVJSZ0z0JE1pqj/i4+PJ40/Ofq0/SVK19erCpKTZM9GTNC2T/RFvTtn87g+emPVaf5IkSeoum7FIFVOWhidNzSmb7/7c12e91p8kSZK6y4qeVCFla3gC/9aRc9uuxw+u9bdk4REsX7qQE5620Hs0JEmSBsCKnlQh/VjPbqYVw9a22ndu/T5v+Ns7+O2Pf4X58+aa5EmSJA2IiZ5UIb1elLZZMVx31UbWXH4r667ayOYduw+b7HVzvT9JkiR1h4meVALTraL1elHa2VQMWztybrzkxdx00ZqBTiWVpDKLiLURsTkitkTEpRM8f35EjEXEXcXXr7c8d0VE3BMR90XEuyPCgVbSpLxHTxqwmdx3N9F6dtf+2ukkyfZdj3W8dtFsK4a21ZakqUXEXOBK4GXANuD2iNiQmfe27frRzLy47bU/CawBTi02fRF4EfD5ngYtqbJM9KQBm8lC4+3r2S2cP5cdj+zlvKv+d1easzQrhi6RIEk9cTqwJTPvB4iI64GzgfZEbyIJHAnMBwI4AtjRozgl1YBTN6UBm2kVrVk9W7b0KA6MczBJPG3FEn7vlavZs3c/333kiVktu+D9dpLUU8uArS2PtxXb2r0qIu6OiBsiYgVAZn4JuBV4sPi6JTPvm+hDImJ9RGyKiE1jY2Pd/QkkVYYVPWnAOqmiNZPE01Ys4c0vP4VLbry7o8pee8Ww06mgkqQZ+0fguszcGxFvAD4EvCQing08B1he7PeZiPjpzPyn9jfIzKuBqwFGR0cHu9iqpIGxoicNWCdVtGaSeOEZzzqY5EFnyy60VgxHFi8wyZOk7tkOrGh5vLzYdlBm7szMvcXDDwDPL75fB9yWmY9m5qPAp4AX9jheSRVmRU8asE6qaM0kcc/e/T1ddkGS1BW3A6si4mQaCd45wGtad4iIEzLzweLhWUBzeuZ3gAsi4o9p3KP3IuC/9SVqSZVkoieVwGy7VjaTxO8+8oRNVCSp5DJzf0RcDNwCzAWuycx7IuIdwKbM3AC8MSLOAvYDDwPnFy+/AXgJ8FUajVn+Z2b+Y79/BknVYaInVdycOcEzjjnyKcsu2ERFksonM28Gbm7bdlnL928B3jLB6w4Ab+h5gJJqw0RPqgGbqEiSJKmViZ5UEy5aLkmSpCa7bkqSJElSzZjoSZIkSVLNmOhJkiRJUs14j540RMbHk5179tmwRZIkqeZM9KQhMT6ebN6x+ylLMJxy/GKTPUmSpJpx6qY0JHbu2XcwyQPYtutxLrh2Ezv37BtwZJIkSeq2aSV6EbE2IjZHxJaIuHSC598UEfdGxN0R8bmIeGax/ZkR8X8i4q6IuCciLmx5zeeL97yr+Pqh7v1Yktrt23/gYJLXtG3X4+zbf2BAEUmSJKlXppy6GRFzgSuBlwHbgNsjYkNm3tuy253AaGY+FhH/GbgCeDXwIPDCzNwbEUcDXyte+0Dxul/JzE3d/IEkTWz+vLksX7rwkGRv+dKFzJ83d0bv431+kiRJ5Tedit7pwJbMvD8z9wHXA2e37pCZt2bmY8XD24DlxfZ9mbm32L5gmp8nqQeOXTSf9583yvKlCwEO3qN37KL5036P5n1+667ayJrLb2XdVRvZvGM34+PZq7AlSZI0C9NpxrIM2NryeBvwgsPs/3rgU80HEbEC+CTwbOB3Wqp5AH8TEQeAG4E/zEzPFqUemTMnOOX4xdx00ZpZV+Mmu8/vpovWMLJ4Qa9ClyRJ0gx1tetmRLwWGAVe1NyWmVuBUyPiROAfIuKGzNxBY9rm9ohYTCPR+1Xg2gnecz2wHmDlypXdDFcaOnPmREcJmff5SZIkVcN0plJuB1a0PF5ebDtERJwJvBU4q2W65kFFJe9rwE8Xj7cX/90NfITGFNGnyMyrM3M0M0dHRkamEa6kXmne59dqNvf5SZIkqbemk+jdDqyKiJMjYj5wDrChdYeIOA14H40k76GW7csjYmHx/VLgp4DNETEvIo4rth8BvJJGEiipxLpxn5/6Z3w8Gdu9l+27HmNs917vpZQkaYhMOXUzM/dHxMXALcBc4JrMvCci3gFsyswNwJ8CRwMfjwiA72TmWcBzgD+PiAQC+LPM/GpELAJuKZK8ucBngff34OeT1EXduM9P/dFsnNO8p7KZlJ9y/GL/vSRJGgLTukcvM28Gbm7bdlnL92dO8rrPAKdOsH0P8PwZRSqpFDq9z0/9YeMcSWXlMj1Sf3S1GYskqRxsnCOpjJxtIPWP69pJUg3ZOEdSGU0222Dnnn0DjkyqHxM9SaohG+dIKiNnG0j949RNSaohG+dIKqPmbIPWZM/ZBlJvWNGTpJpqNs5ZtvQoRhYvMMmTNHDONpD6x4qeJEmS+sLZBlL/mOhJkiSpb1ymR+oPp25KkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJqqWIWBsRmyNiS0RcOsHzKyPi1oi4MyLujoifneD5RyPizf2LWpIkqTtM9CTVTkTMBa4EXgGsBs6NiNVtu70N+FhmngacA1zV9vy7gE/1OlZJkqReMNGTVEenA1sy8/7M3AdcD5zdtk8CxxTfPw14oPlERPwC8E3gnj7EKkmS1HUmepLqaBmwteXxtmJbq7cDr42IbcDNwH8BiIijgUuAPzjcB0TE+ojYFBGbxsbGuhW3JElSV5joSRpW5wIfzMzlwM8CfxsRc2gkgH+RmY8e7sWZeXVmjmbm6MjISO+jlSRJmgEXTJdUR9uBFS2PlxfbWr0eWAuQmV+KiCOB44AXAL8YEVcAS4DxiHgiM9/T+7AlSZK6w0RPUh3dDqyKiJNpJHjnAK9p2+c7wEuBD0bEc4AjgbHM/OnmDhHxduBRkzxJRnbKLgAAIABJREFUklQ1Tt2UVDuZuR+4GLgFuI9Gd817IuIdEXFWsdtvAxdExFeA64DzMzMHE7EkSVJ3WdGTVEuZeTONJiut2y5r+f5eYM0U7/H2ngQnSZLUY1GlC9gRMQZ8e5q7Hwd8r4fhdFOVYoVqxVulWKFa8XYr1mdmZqW7mdR4bIJqxVulWKFa8VYpVuhOvJUfm6DW41OVYoVqxVulWKFa8fb13KlSid5MRMSmzBwddBzTUaVYoVrxVilWqFa8VYq1TKp23KoUb5VihWrFW6VYoXrxlkWVjluVYoVqxVulWKFa8fY7Vu/RkyRJkqSaMdGTJEmSpJqpc6J39aADmIEqxQrVirdKsUK14q1SrGVSteNWpXirFCtUK94qxQrVi7csqnTcqhQrVCveKsUK1Yq3r7HW9h49SZIkSRpWda7oSZIkSdJQMtGTJEmSpJqpZaIXEWsjYnNEbImISwcdT6uIWBERt0bEvRFxT0T8ZrH96RHxmYj4evHfpYOOtSki5kbEnRHxieLxyRHx5eL4fjQi5g86xqaIWBIRN0TEv0TEfRHxwrIe24j4reJ34GsRcV1EHFmmYxsR10TEQxHxtZZtEx7LaHh3EffdEfG8QcVdZo5N3VeV8alKYxOUe3xybOq+Mo9NUM3xqSpjE1RrfCrz2FTEV6rxqXaJXkTMBa4EXgGsBs6NiNWDjeoQ+4HfzszVwE8Av1HEdynwucxcBXyueFwWvwnc1/L4cuAvMvPZwC7g9QOJamJ/CfzPzPwR4D/QiLt0xzYilgFvBEYz87nAXOAcynVsPwisbds22bF8BbCq+FoP/FWfYqwMx6aeqcr4VImxCSoxPn0Qx6auqcDYBNUcn6oyNkFFxqcKjE1QtvEpM2v1BbwQuKXl8VuAtww6rsPE+z+AlwGbgROKbScAmwcdWxHL8uKX8iXAJ4AAvgfMm+h4DzjWpwHfpGgy1LK9dMcWWAZsBZ4OzCuO7cvLdmyBk4CvTXUsgfcB5060n18Hj4ljU/djrMT4VKWxqYil9OOTY1NXj2WlxqYixlKPT1UZm4pYKjM+VWFsKmIozfhUu4oe//ZL0LSt2FY6EXEScBrwZeD4zHyweOq7wPEDCqvdfwN+FxgvHh8LfD8z9xePy3R8TwbGgL8ppkt8ICIWUcJjm5nbgT8DvgM8CPwAuIPyHtumyY5lZf6/G6DKHKOKjE1QnfGpMmMTVHZ8cmyavUodo4qMT1UZm6BC41NFxyYY4PhUx0SvEiLiaOBG4P/NzEdan8tGWj/wdS8i4pXAQ5l5x6BjmaZ5wPOAv8rM04A9tE01KNGxXQqcTWOAPRFYxFNL/aVWlmOp7qrC2ASVG58qMzZB9cenMh1LdVcVxqeKjU1QofGp6mMT9P9Y1jHR2w6saHm8vNhWGhFxBI2B6u8y8++LzTsi4oTi+ROAhwYVX4s1wFkR8S3gehpTEP4SWBIR84p9ynR8twHbMvPLxeMbaAxeZTy2ZwLfzMyxzHwS+Hsax7usx7ZpsmNZ+v/vSqD0x6hCYxNUa3yq0tgE1RyfHJtmrxLHqELjU5XGJqjW+FTFsQkGOD7VMdG7HVhVdOCZT+MmzQ0DjumgiAjgr4H7MvNdLU9tAF5XfP86GvPPByoz35KZyzPzJBrH8X9l5q8AtwK/WOxWilgBMvO7wNaIOKXY9FLgXkp4bGlMO/iJiDiq+J1oxlrKY9tismO5ATiv6CD1E8APWqYpqMGxqYuqND5VbGyCao5Pjk2zV+qxCao1PlVpbILKjU9VHJtgkONTr25EHOQX8LPAvwLfAN466HjaYvspGiXbu4G7iq+fpTF/+3PA14HPAk8fdKxtcZ8BfKL4/t8B/wxsAT4OLBh0fC1x/hiwqTi+/wAsLeuxBf4A+Bfga8DfAgvKdGyB62jMgX+SxhW/1092LGncaH5l8f/cV2l0xBr4MS7bl2NTz2Iv/fhUpbGpiLe045NjU0+OaWnHpiK+So5PVRibitgqMz6VeWwq4ivV+BTFB0mSJEmSaqKOUzclSZIkaaiZ6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOhJkiRJUs2Y6EmSJElSzZjoSZIkSVLNmOipFCLiRyJi/6DjkCRJqoOIOCkiMiLmzfL1ERF/ExG7IuKfi23/OSJ2RMSjEXFsdyNWt5no6RDF/7jNr/GIeLzl8a908L63RcRruxmrJM1ERHyrbUx7NCLeM+i4JNVPMd6c2bbt/Ij44qBimoWfAl4GLM/M0yPiCOBdwM9k5tGZuXOw4Wkqs8rwVV+ZeXTz+4j4FvDrmfnZwUUkSV3181ONaRExLzP3T7Vtpu8hSVVRVAGfCXwrM/cUm48HjgTuGVhgmhErepqRiJgbEb8XEfdHxPci4u8iYknx3KKIuD4iHo6I70fElyNiaUT8OfDjwAeKK+h/Po3PWRkRNxfv9a8R8bqW59ZExJ0R8UhEfDci/vhwn1889/SIuLbYf2tE/H5EzCme+5GI+GJE/CAixiLi2l4cO0nlVFxl3xgRfxERO4G3T7JtTkS8LSK+HREPFWPK04r3aE6Ren1EfAf4XxFxZER8OCJ2FmPS7RFx/EB/WEmlEBGXRsQ3ImJ3RNwbEetannt7RHy45fEhUzCL8en+4rXfbM64Ks7R/qw4P7sf+Lm2zzwxIjYU50lbIuKCts+8oRizHgFeD3wAeGFx7nYdsLnY/fsR8b96dWzUPVb0NFNvBn6GRjn/YeC9wF8A/wn4dRq/U8uAJ4HTgH2Z+dsRsQZ4T2Z+eMJ3faqPA/8bWAf8KPDpiNiSmRuB9wD/NTM/HhGLgdXFayb8/OK5vwO2AP8OeBpwM/At4EPAHwP/APw0jStVz5vZIZFUAy8ArqdxxfoI4NUTbDu/+Hox8BBwLY3x6Fdb3udFwHOAceB1NMabFcBe4MeAx3v9g0iqhG/QOO/4LvBLwIcj4tmZ+eDhXhQRi4B3Az+emZsj4gTg6cXTFwCvpHH+swe4se3l1wNfA04EfgT4TER8IzObSdvZRSznAQtojFu/npk/VXz2ScA3gSXOWKgGK3qaqQuBSzPzgcx8AvgD4NURETSSqxHgWZm5PzNvbyn3T1tErAL+A/D/ZebezNxEIyFrnkw9CfxwRBybmbsz88st25/y+RHxTOA/Am/KzMeKQfTdwDktrzsJeEZmPl4kk5Lq6R+K6lrzq3lF+4HM/O/F2PH4JNt+BXhXZt6fmY8CbwHOiUMbHbw9M/cU+z8JHAs8OzMPZOYdmflIv35QSQN3yHgDXNV8IjM/XpxLjWfmR4GvA6dP833HgedGxMLMfDAzm1Mpfxn4b5m5NTMfpnEhG4CIWAGsAS7JzCcy8y4aFbvzWt73S5n5D0VMXpSqARM9TVuRzK0Abm4ZtO6k8Xt0LPDXwP8P3BAR2yLiv0bE3Fl81InAWNsg820alTpoXCU/FfjXYnrmy4vtk33+M2lU6sZa4v5LGlfpAX4LOAq4MyLuDpvGSHX2C5m5pOXr/cX2rRPs277tRBpjUdO3acwiaJ2O2fqavwVuAa6PiAci4opoNDOQNBwOGW+Ai5pPRMR5EXFXy3nJc4HjpnrD4gL6q2lceH8wIj4ZET9SPH0ih45BrePVicDDmbm77fllLY8nGgdVYSZ6mrbMTGA78JK2E6UjM/N7RfXtssz8ERoVtF/i36pmOYOPegAYiYiFLdtWFp9NZt6Xma8GfohGZe7vI2L+YT5/K/AosLQl5mMy83nF+23PzF8DTgDeCFwTEStnc4wkVdZEY1T7tgdoXDhqWgnsB3ZM9JrMfDIz/yAzVwM/SWNKVevVc0lDqJhp9H7gYuDYIgn8GhDFLntoXIBuekbr6zPzlsx8GY3zln8p3gvgQRoX5Jtaz2UeAJ5e3PLS+vz21ree1Q+k0jLR00y9F/iTYgoAEfFDEfHzxfdnRsTqosnJIzROgMaL1+2gcX/cdGwBvgr8YUQsiIjn0ajifbj4nPOKaZsHgB/QGJhyss/PzG8CtwFXRMTioqHCqohozjl/dUScWCSy3y9iODDrIySprq4DfisiTo6Io4H/Cnx0sntVIuLFEfGjxcyCR2hM5RyfaF9JQ2URjXOXMYCI+E80KnpNdwH/MRqN6Z5GY5o4xb7HR8TZxb16e2lcyG6OKx8D3hgRy6PRjO7S5usycyuN3gd/XDSKOpVGw5Xp9k5QBZnoaaauAD5Lo6PcbhqDRrN5yTLgfwC7aVyZuhn4aPHcXwDnRWPRzSsO9wFFwvVLNJqsfLd4j9/JzObaM68ENhef/8fAL2fmk1N8/rnAEhpXvh4utjenW70QuCMiHqXRBGZ9ZrZe4ZJUH/8Yh66jd9MMXnsNjemYX6DRkOAJ4L8cZv9nADfQSPLuozG1/G9nF7akusjMe4E/B75E40L4jwIbW57/DI3zlLuBO4BPtLx8DvAmGhW6h2k0gPrPxXPvpzFd/CvA/wH+vu2jz6XRk+AB4Cbg911Cq96icU4tSZIkSaoLK3qSJEmSVDMmepIkSZJUMyZ6kiRJklQzJnqSJEmSVDPzBh3ATBx33HF50kknDToMSV10xx13fC8zRwYdRyccm6T6qcPYBI5PUh1Nd3yqVKJ30kknsWnTpkGHIamLIuLbg46hU45NUv3UYWwCxyepjqY7Pjl1U5IkSZJqxkRPkiRJkmrGRE+SJEmSasZET5IkSZJqxkRPkiRJkmrGRE+SJEmSasZET5IkSZJqxkRPkiRJkmrGRE+SJEmSambeoAOQJPXG+Hiyc88+9u0/wPx5czl20XzmzIlBhyVJkvrARE+Samh8PNm8YzcXXLuJbbseZ/nShbz/vFFOOX6xyZ4kSUPAqZuSVEM79+w7mOQBbNv1OBdcu4mde/YNODJJktQPHSV6EbE2IjZHxJaIuHSC5y+MiK9GxF0R8cWIWF1sf1lE3FE8d0dEvKSTOCRJh9q3/8DBJK9p267H2bf/wIAikiRpZsbHk7Hde9m+6zHGdu9lfDwHHVKlzHrqZkTMBa4EXgZsA26PiA2ZeW/Lbh/JzPcW+58FvAtYC3wP+PnMfCAingvcAiybbSyD5D0wkspo/ry5LF+68JBkb/nShcyfN3eAUUmSND3egtC5Tip6pwNbMvP+zNwHXA+c3bpDZj7S8nARkMX2OzPzgWL7PcDCiFjQQSwD0fwFXHfVRtZcfivrrtrI5h27vdogaeCOXTSf9583yvKlCwEO/oE8dtH8AUcmSdLUvAWhc500Y1kGbG15vA14QftOEfEbwJuA+cBEUzRfBfyfzNw70YdExHpgPcDKlSs7CLf7JvsFvOmiNYwsrlzeKqlG5swJTjl+MTddtMYZB5KkyvEWhM71vBlLZl6Zmc8CLgHe1vpcRPx74HLgDYd5/dWZOZqZoyMjI70Ndob8BZRUZnPmBCOLF7Bs6VGMLF5gkidJqozmLQitvAVhZjpJ9LYDK1oeLy+2TeZ64BeaDyJiOXATcF5mfqODOAbGX0BJkiSp+7wFoXOdTN28HVgVESfTSPDOAV7TukNErMrMrxcPfw74erF9CfBJ4NLM3NhBDAPV/AVsv0nUX0BJkiRp9rwFoXOzTvQyc39EXEyjY+Zc4JrMvCci3gFsyswNwMURcSbwJLALeF3x8ouBZwOXRcRlxbafycyHZhvPIPgLKEmSJPVG8xYEzU4nFT0y82bg5rZtl7V8/5uTvO4PgT/s5LPLwl9ASZIkSWXT82YskiRJkqT+MtGTJEmSpJox0ZMkSZKkmjHRkyRJkqSaMdGTJEmSpJox0ZMkSZKkmjHRkyRJkqSaMdGTJEmSpJox0ZMkSZKkmjHRkyRJkqSaMdGTJEmSpJqZN+gAJEmSJFXX+Hiyc88+9u0/wPx5czl20XzmzIlBhzX0TPQkSZIkzcr4eLJ5x24uuHYT23Y9zvKlC3n/eaOccvxik70Bc+qmpKEVEddExEMR8bWWbe+MiLsj4q6I+HREnDjIGCVJKrOde/YdTPIAtu16nAuu3cTOPfuARiI4tnsv23c9xtjuvYyP5yDDHSomepKG2QeBtW3b/jQzT83MHwM+AVzW96gkSaqIffsPHEzymrbtepx9+w8crPatu2ojay6/lXVXbWTzjt0me31ioidpaGXmF4CH27Y90vJwEeBfI0mSJjF/3lyWL114yLblSxcyf97cKat96i0TPUlqExF/FBFbgV9hkopeRKyPiE0RsWlsbKy/AUqSVBLHLprP+88bPZjsNe/RO3bR/MNW+9R7NmORpDaZ+VbgrRHxFuBi4Pcn2Odq4GqA0dFRq36SpKE0Z05wyvGLuemiNU/putms9rUme81qn3rPip4kTe7vgFcNOghJkspszpxgZPECli09ipHFCw522zxctU+9Z0VPklpExKrM/Hrx8GzgXwYZjyRJVXW4ap96z0RP0tCKiOuAM4DjImIbjSmaPxsRpwDjwLeBCwcXoSRJ1das9qn/nLopaWhl5rmZeUJmHpGZyzPzrzPzVZn53GKJhZ/PzO2DjlNSfUTE2ojYHBFbIuLSCZ4/PyLGirU874qIX2957nUR8fXi63X9jVxS1VjRkyRJ6oOImAtcCbwM2AbcHhEbMvPetl0/mpkXt7326TRmHYzSWPbljuK1u/oQuqQKsqInSZLUH6cDWzLz/szcB1xP417g6Xg58JnMfLhI7j4DrO1RnJJqwERPkiSpP5YBW1sebyu2tXtVRNwdETdExIoZvlbSFMbHk7Hde9m+6zHGdu9lfLyeqyQ5dVOSJKk8/hG4LjP3RsQbgA8BL5nJG0TEemA9wMqVK7sfoYbe+Hiyc8++SnbSHB9PNu/YzQXXbmLbrscPLvlwyvGLK/MzTJcVPUmSpP7YDqxoeby82HZQZu7MzL3Fww8Az5/ua1ve4+rMHM3M0ZGRka4ELjU1E6V1V21kzeW3su6qjWzesbsyVbGde/YdTPJOW7GE33vlavbs3c93H3miMj/DdJnoSZIk9cftwKqIODki5gPnABtad4iIE1oengXcV3x/C/AzEbE0IpYCP1Nsk/qqNVEC2LbrcS64dhM79+wbcGTTs2//gYNJ3ptffgrv/MS9/OJ7v8Qvv+9LlUpYp8NET5IkqQ8ycz9wMY0E7T7gY5l5T0S8IyLOKnZ7Y0TcExFfAd4InF+89mHgnTSSxduBdxTbpL5qJkqttu16nH37DwwoopmZP28uy5cu5MIznsUlN95d2YR1OrxHT5IkqU8y82bg5rZtl7V8/xbgLZO89hrgmp4GKE2hmSi1JnvLly5k/ry5h+xX1vv4jl00n/efN8qevfsrnbBOhxU9SZIkDU0nQnWmmSgtX7oQ4GAzk2MXzT+4T5nv45szJzjl+MWcuGThwZ+haaKEtROD/n/Kip4kSdKQG6ZOhOpMM1G66aI1k1brJruP76aL1jCyeMGgQj9ozpzgGcccyfvPG33K73xrwtqJMvw/ZaInSZI05Mp+Yq5ymTMnDvt7UYX7+KaTsHaiDP9PdTR1MyLWRsTmiNgSEZdO8PyFEfHViLgrIr4YEauL7cdGxK0R8WhEvKeTGCRJktSZKpyYqzqa9/G16va0yG5oJqzLlh7FyOIFXa20leH/qVknehExF7gSeAWwGji3mci1+Ehm/mhm/hhwBfCuYvsTwO8Bb57t50uSJKk7qnJirmqYzn18dVeG/6c6mbp5OrAlM+8HiIjrgbOBe5s7ZOYjLfsvArLYvgf4YkQ8u4PPlyRJUhc0T8x7db+SeqOsnS0PNy2yrDF3Wxn+n+ok0VsGbG15vA14QftOEfEbwJuA+cBLZvohEbEeWA+wcuXKWQUqSZKkyfX6fiV1XxmafRzORPfxlT3micw2MS3D/1M9X14hM6/MzGcBlwBvm8Xrr87M0cwcHRkZ6X6AkiRJ6un9Suq+yZp9lHnB76rF3OkyEYP+f6qTRG87sKLl8fJi22SuB36hg8+TJEmSRDmafcxU1WKuWmLarpNE73ZgVUScHBHzgXOADa07RMSqloc/B3y9g8+TJEmSxMybfQx68W4oR4OSmahaYtpu1oleZu4HLgZuAe4DPpaZ90TEOyLirGK3iyPinoi4i8Z9eq9rvj4ivkWjC+f5EbFtgo6dkiRJkiYwk86WnU5BHETMZVC1xLRdZPY/m5+t0dHR3LRp06DDkNRFEXFHZo4OOo5OODZJ9VOHsQkcn+puuo1CxnbvZd1VGw+pTi1furCvi3c3Vanr5mybx/T6Z5zu+NRJ101JkiTVVJVOyIfVRJ0tJ1KmKYjTjbkMZtM5s0ydRXvedVOSJEnVUpapfuqOqk9BHKTJOmdOds9jmRq4mOhJkiTpEGU6WVXnqnZvXNkd7kJImaqnTt2UJEnSIcp0sqrOlWHx7jqZ7ELITRetOVg9bb8fchDVUyt6kiRJOoRT/epn0It318nhLoSUqXpqRU+SJEmHaJ6stjeUcKqfxGGrdmWqnproSZIk6RBlOlmVymaqCyFl6SxqoidJkqSnKMvJqlQ2VbkQYqInSZIkaWjNZs3IKlwIMdGTJEmSNJTKtMB5t9l1U5IkSdJQqvOakVb0JEmSJA2lTteMnM20z34x0ZMkSZI0lDpZ4Lzs0z6duilJkiRpKHWywHnZp31a0ZMkSZI0lDpZKqHTaZ+9ZqInSZIkaWjNdqmETqZ99oNTNyVJkiRphjqZ9tkPVvQkDa2IuAZ4JfBQZj632PanwM8D+4BvAP8pM78/uCglSVIZdTLtsx+s6EkaZh8E1rZt+wzw3Mw8FfhX4C39DkqSJFVDc9rnsqVHMbJ4QWmSPDDRkzTEMvMLwMNt2z6dmfuLh7cBy/semCRJUodM9CRpcr8GfGqiJyJifURsiohNY2NjfQ5LkiTp8Ez0JGkCEfFWYD/wdxM9n5lXZ+ZoZo6OjIz0NzhJkmZpfDwZ272X7bseY2z3XsbHc9AhqUdsxiJJbSLifBpNWl6amf4FlCTVwvh4snnH7oOLfDe7RJ5y/OJS3Vum7rCiJ0ktImIt8LvAWZn52KDjkSSpW3bu2XcwyYPG4t4XXLuJnXv2DTiy8qtiJdSKnqShFRHXAWcAx0XENuD3aXTZXAB8JiIAbsvMCwcWpCRJXbJv/4FDFveGRrK3b/+BAUVUDVWthJroSRpamXnuBJv/uu+BSJJUGB9Pdu7Z15N12ebPm8vypQsPSfaWL13I/Hlzu/L+dTVZJfSmi9YwsnjBgKObnFM3JUmSpBJoVo7WXbWRNZffyrqrNrJ5x+6uTRM8dtF83n/eKMuXLgQ4WJk6dtH8rrx/XVW1EmpFT5IkSSqBXleO5swJTjl+MTddtKYnFcO6qmol1IqeJEmSVAL9qBzNmROMLF7AsqVHMbJ4wcEkr4rNRvql00rooI6tFT1JkiSpBAZVOapqs5F+6aQSOshja0VPkiSpTyJibURsjogtEXHpYfZ7VURkRIwWj4+IiA9FxFcj4r6IeEv/ola/DOoeurItu1DG6uJkldCpDPLYWtGTJEnqg4iYC1wJvAzYBtweERsy8962/RYDvwl8uWXzLwELMvNHI+Io4N6IuC4zv9Wf6NUPg7qHrkzNRupWXWw9tqetWMKFZzyLJQuPYN/+A4yPZ09/Jit6kiRJ/XE6sCUz78/MfcD1wNkT7PdO4HLgiZZtCSyKiHnAQmAf8EiP49UAzLZy1InmlNFWg2o2UrbqYqeax/a0FUt488tP4Z2fuJdXX30br776tq52VJ1IR4neVNMPIuLCYorBXRHxxYhY3fLcW4rXbY6Il3cShyRJUgUsA7a2PN5WbDsoIp4HrMjMT7a99gZgD/Ag8B3gzzLz4Yk+JCLWR8SmiNg0NjbWteBVX2VadmGi6uLI0QvYt/9AqaZyTlfz2L7xpau45Ma7+5rAznrq5jSnH3wkM99b7H8W8C5gbZHwnQP8e+BE4LMR8cOZWe7FKCRJknokIubQOFc6f4KnTwcO0DhvWgr8U0R8NjPvb98xM68GrgYYHR2tzhmxBqZMyy60N6Q5bcUSfnftKbz66tsqOZWzeWwXLZjb9+mxnVT0ppx+kJmtUwoW0Zh2QLHf9Zm5NzO/CWwp3k+SJKmutgMrWh4vL7Y1LQaeC3w+Ir4F/ASwoWjI8hrgf2bmk5n5ELARGO1L1BoKg5gyOpH26uIbX7qK37mhv5WwbpszJ1h4xLy+T4/tJNGbcvoBQET8RkR8A7gCeONMXlu83ukHkiSpDm4HVkXEyRExn8bspg3NJzPzB5l5XGaelJknAbcBZ2XmJhrTNV8CEBGLaCSB/9LvH0Dqtdbq4sZLXsyzfmhRaRrFdGIQ02N73nUzM68EroyI1wBvA143w9c7/UCSJFVeZu6PiIuBW4C5wDWZeU9EvAPYlJkbDvPyK4G/iYh7gAD+JjPv7n3U5TQ+nuzcs2/g0wzVG83qIsDY7r0DWVuw2wYxPbaTRG+q6Qftrgf+apavlSRJqrzMvBm4uW3bZZPse0bL94/SWGJh6NWt/X6V9SPhblbC2v+9B9EoplOtCWw/dJLoHZx+QCNJO4fG/PGDImJVZn69ePhzQPP7DcBHIuJdNG4qXgX8cwexSJIkaQhM1n7/povW9PUketj1K+EuU6OYqpl1ojfN6QcXR8SZwJPALoppm8V+HwPuBfYDv2HHTUmSJE2lTIt7D7N+Jtz9roTVRUf36E01/SAzf/Mwr/0j4I86+XxJkiQNl/b2+1DNe7aqro4Jd93u/exowXRJkiSpn8q0uPcwaybcraqccDenoq67aiNrLr+VdVdsWZIcAAAgAElEQVRtZPOO3ZVanL1dz7tuSpIkSd3iPVvlUKcmKVDPez9N9CRJklQp3rM1eHVLuOs4FdVET5IkST1Xt/ufZqKuP3udEu72ez9PW7GEN750FQcyGdu9t5L/ZiZ6kiRJ6qlhXvtumH/2Kmmdijpy9AJ+d+0p/M4Nd1f638xmLJIkSeqpye5/2rln34T7j483qijbdz3G2O69lW6IMdOfveqq+m/XOhX1Pa857WCSB9X9N7OiJ0mSpJ6ayf1PdauA1fHer8lU/d+uORV1+67HavFvZkVPkiRJPTWTVvx1q4B1exmCmVTMul1dm+r96vJvV5elI0z0JEmS1FMzWfuubhWwbq77N5O13rq9Ltx03q8M/3bdSG7rslajUzclSZLUUzNpxd/e/RCqWU1p6uYyBDNZ663b68JN5/36+W/X3sl06cIjeGTvkzz4/Sd4w4fv6GjqaF2WjrCiJ0mSpJ5r3v+0bOlRjCxeMOlJc12qKa2m87NPpxI1k4pZt6tr03m/fv3btVcX33rT3fzLjt18ZesPDiZ5zfhmO3V0ur+vZWZFT5IkSaVRl2rKTEy3iclMKmbdrq5N5/369W/XXl181fNXcOGH7+DPf+k/DHzqaJlY0ZMkSVKp1KGaMhPTbWIyk4pZt6tr032/fvzbtVcXlyw8gm27Huf7jz9ZiyYq3WJFT5IkSRqg6U6znEnFrNvVtTJVWturi80E772f/waXv+pULrnx0IXOqzzttxMmepIkSdIAzWSaZbNiNh0z2XcQ7zdbzepiswp64x1bee9rn8+FH76DP7tlM+88+7mcfNwijlowl+MWlbsi3N5UppvJs4meJEmSNEDticuwV6KmMlF1cenCI0pRbZyJXi8wb6InSZIkDVC3p0X2skpUFhNVF8tQbZyJbi+B0c5ET5IkSRqwTqZFtiZ2C+fPZccje3tWJVL39HqBebtuSpIkaShMZ626qmlfU+4rW38wrQ6eGrzmvZmtutkl1ERPkiRJtdeeEK27aiObd+yedbJXlqSxffrfUfPn1nYtubIc827p9QLzTt2UJElS7XXzfqheN9GYifbpf82lBrq1UHpZlOmYd0uvl6ywoidpaEXENRHxUER8rWXbL0XEPRExHhGjg4xPktQ93bwfaroLnPdD+/S/937+G/zpL57asyrRoJTpmHdTLxeYt6InaZh9EHgPcG3Ltq8B/w/wvkEEJEnqjZmsVTeVXjfRmIn2pRnGHt3L8cccyd9f9JM8uX+8Nl03y3TMq8JET9LQyswvRMRJbdvuA4io9h9ESdKhurlWXTeTxk71evpfWZTpmFeFiZ4kzUJErAfWA6xcuXLA0UiSptLNhKhsC5x3sjRDVZTtmFeBiZ4kzUJmXg1cDTA6Olrttl+SVCOHWyy8WwnRsFTRysRjPnMmepIkSaqFfnZmHIYqWtnM9pgfLvmvM7tuSpIkqRbq2pmx7nq5Pl6310+sEhM9SUMrIq4DvgScEhHbIuL1EbEuIrYBLwQ+GRG3DDZKSdJ02ZmxenqdiA1z8u/UTUlDKzPPneSpm/oaiCSpK3rZmXFYpv/1++fs5kL2Exnm5N+KniRJkmqh2Zmx24uFD8v0v0H8nL1OxNoXlIfhWZbBRE+SJEm10NqZceMlL+ami9Z0pRHLsEz/G8TP2etErFfJfxU4dVOSJEm10YtumK1Vp9NWLOHCM57FkoVHsG//AcbHszZTOAcxzbHX6+MN87IMHSV6EbEW+EtgLvCBzPyTtuffBPw6sB8YA34tM79dPHc58HPFru/MzI92EoskSZLUC82q08jRC3jzy0/hkhvv7vnyDYPQy3scJ9OPRGxYl8KY9dTNiJgLXAm8AlgNnBsRq9t2uxMYzcxTgRuAK4rX/hzwPODHgBcAb46IY2YbiyRJktQrzarTG1+66mCSB/WbwjmoaY7NRGzZ0qMYWbygFklzGXRS0Tsd2JKZ9wNExPXA2cC9zR0y89aW/W8DXlt8vxr4QmbuB/ZHxN3AWuBjHcQjSVLpNTvajY+PcyAhM4dqKpFURc2q06IFc2vdwXGYpznWUSfNWJYBW1sebyu2Teb1wKeK778CrI2IoyLiOODFwIqJXhQR6yNiU0RsGhsb6yBcSZL6q30R4P37x9m8Yzdvvelutozt4Zff96Vad/CT6mTOnGDhEfNq38HR6lp99KXrZkS8FhgF/hQgMz8N3Az8b6C5YPGEl0Iy8+rMHM3M0ZGRkX6EK0lSxyZqU/7ADxrTvF71/BW1nv4l1dUwd3BU9XQydXM7h1bhlhfbDhERZwJvBV6UmXub2zPzj4A/Kvb5CPCvHcQiSVKpTNSm/KHde9m263GWLDyi1tO/NLmpGtm17PcqGv0NfjwzNxXbTgXeBxwDjBfPPdGXwAU4tVHV0kmidzuwKiJOppHgnQO8pnWHiDiNxoC0NjMfatk+F1iSmTuLQetU4NMdxCJJUqlM1KZ85559LF+6kO8//mTfO9tp8Foa2b2Mxi0vt0fEhsy8t22/xcBvAl9u2TYP+DDwq5n5lYg4Fniyb8H3SfMe1smSqKme74fpdHAsQ5zSrBO9zNwfERcDt9C4KnVNZt4TEe8ANmXmBhpTNY8GPh4RAN/JzLOAI4B/KrY9Ary2aMwiSVItTNSm/MY7tvK+X30+f/nZf+XyV536lBbtTv+qvSkb2RXeCVwO/E7Ltp8B7s7MrwBk5s7eh9tfzenO7eupNZcumOr5sqhKnBqcfl0I6Ggdvcy8mca9dq3bLmv5/sxJXvcEjc6bkiTV0kSLAP/Wy05h1cjR/NG6UxkfH+djb3ihXTeHy0SN7F7QukNEPA9YkZmfjIjWRO+HgYyIW4AR4PrMvKLXAffTRNOdL7h2EzddtIaRxQumfL4sqhJn3ZW1qtrPCwEdJXqSJGlih7uXx5M9TSQi5gDvAs6f4Ol5wE8BPw48BnwuIu7IzM9N8D7rgfUAK1eu7Fm83TbRdOfWe1enen4y/T7hn22c6p4yV1X7eSGgL103JUnl0d7y35b+vWObcrWZqpHdYuC5wOcj4lvATwAbImKURvXvC5n5vcx8jMaMqudN9CFV7VjenO7cqvXe1amen8hE3W97vZTJbOJUd02WTJWhs3E/LwSY6EnSEBnESY+kgw42souI+TQa2W1oPpmZP8jM4zLzpMw8CbgNOKvounkL8KPFGsTzgBfx1Hv7Km2qpQtms7TBIE74XYJh8MpcVe3nhQCnbkrSEPHeEWlwptnIbrLX7oqId9FIFhO4OTM/2ZfA+2SqpQtms7TBIE74XYJh8CZqhlWWqupE92/36kKAiZ4kDZEyX+WUhsFUjezatp/R9vjDNJZY6KoyNa2Y6h7Wmd7jOqgTfu/FHax+JlMz1c8LASZ6kjREynyVU1L/lblpRTeU+YRfvVP2qmq/LgSY6EnSEKn7SU+ZKhNSFdR9OnfZTvgdo7pvsmNqVdVET5KGStlOerqp7pUJqReGYTp3WU74HaO6z2N6eHbdlKQhU9eW/2Vupy2VlUsB9E/ZxqhBL7XTjc8v2zEtGyt6kqRaGIbKhNRt3Z7O7dTEyZVpjBp0Jaxbn1+mY1pGVvQkSbVgZUKaudbp3BsveTE3XbRm1if7rtN5eGUaowZdCevW55fpmJaRiZ4kqRZcpFianW5N557tyfugpxD2S5nGqEFXwrr1+WU6pmXk1E1JUi3UudGMVBaHm5o5m5P3QU8h7KcyjVGDXmqnW59fpmNaRlb0VHvDcqVQUn0bzUhlMNXUzNlMoxv0FMJ+K8sYNehKWDc/vyzHtIys6KnWhulKoSRNxOYY6pap1tybTWOXQU8hHFaDroQN+vOHhYmeaq3uC8FK0uFU+WKXCWr5TJWUzebkfdBTCIfZoNcXHPTnDwOnbqrWvFIoqdWwTeWu6rQ4uzeW03SmZs50Gt2gpxD22rCNOSoXK3qqNa8USmqqcnVrtqp6scvZGOXU7TX3oN5T+IZxzFG5WNFTrdX9SqGk6atqdasTVV1jqqoJat11c8299vetYzONYRxzVC5W9FRrdb5SKGlmhjF56EUFph+cjVFe3lc1fcM45qhcTPRUe/5RkgTDmTxU9WJXVRNUqdUwjjkqFxM9SdJQGNbk4XAXu8ra2bKqCarUaljHHJWHiZ4k9UFZT6iHicnDocreKMLZGCqL2Y7fjjkaNBM9Seqxsp9Qd0sVklmTh39jZ0tpap2O3445GiS7bkpSjw1D5zXXPaueQTaKcG0xVcUwjN+qLxM9SUMrIq6JiIci4mst254eEZ+JiK8X/13a6efUofPaVCfmngxVz6CWXvCigKqkDuO3hpeJnqRh9kFgbdu2S4HPZeYq4HPF445UdS2zpumcmHsyVD2DWmfUiwKqUkW36uO3hpuJnqShlZlfAB5u23w28KHi+w8Bv9Dp5wzqhLpbpnNi7slQf3XjRLlXi19PxYsCw61qFd2qj98abjZjkaRDHZ+ZDxbffxc4fqKdImI9sB5g5cqVh33D2XZeK0tzk+mcmNtGvH+62dxnEI0iXFtsuFWtCZCdM1VlJnqSNInMzIiY8DJzZl4NXA0wOjo65aXomZ5Ql6lT53ROzD0Z6p+qnSi386LAcOtFRbfXF8XsnKmqMtGTpEPtiIgTMvPBiDgBeGgQQZTpZH66J+aeDPVH1ac+elFguHW7olumi2JS2ZjoST1Wlul3mrYNwOuAPyn++z8GEUSZTuY9MS+XOkx99KJA9Uz2t2ymf+O6XdEt00UxqWxM9KQe8kpjuUXEdcAZwHERsQ34fRoJ3sci4vXAt4FfHkRs/TiZn8kJmifm5eHUR/XbZH/LVo0czdfHHp3R37huXzgq00WxXvGCsWaro66bEbE2IjZHxJaIeEoL8oh4U0TcGxF3R8TnIuKZLc9dERH3RMR9EfHuiPA3VrVjG/Fyy8xzM/OEzDwiM5dn5l9n5s7MfGlmrsrMMzOzvStnX/S601vVOt/p3wyqW2aVVKl9fxVM9rfsoUf3zupvXPPC0bKlRzGyeEFHv7t17/jrWK1OzDrRi4i5wJXAK4DVwLkRsbpttzuB0cw8FbgBuKJ47U8Ca4BTgecCPw68aLaxSGU1DFca1Ru9Ppnvx0UIT7Z7p5snynXjiXH3Tfa37MkD4wP/G1f35Q+8YKxOdDJ183RgS2beDxAR19NYf+re5g6ZeWvL/rcBr20+BRwJzAcCOALY0UEsUinV4V4aDU4vp0v2+iJEp9OWnaqk2fKere6b7G/ZEXPnDPxvXN3vIfaCsTrRydTNZcDWlsfbim2TeT3wKYDM/BJwK/Bg8XVLZt430YsiYn1EbIqITWNjYx2EK/Vf3a80anA6rZb1erpTJ1ehrcioE54Yd99kf8t+6OgFpfgbV+cKd92npqq3+tKMJSJeC4xSTM+MiGcDzwGWF7t8JiJ+OjP/qf21M12rSiqTul9p1GB0o8lPrxt6dHKybUVGnXAmRfdN9Lds6cIj2PX4kzz9qCP42BteSGb6N64HbL6kTnSS6G0HVrQ8Xl5sO0REnAm8FXhRZu4tNq8DbsvMR4t9PgW8EHhKoidVnd0K1W3dSIR6fRHi/7Z3/lF2VFW+/+5O0p1Od0KH0PzKD8nDGG0zwZgefuU5REFAJ0NEEIEXwZ8QGRY+Z4Lg0iBD9L0XiKIuYRJG0KeOOsgPzYtoYHhk3loYgcQ4EcJEgzgkMZAW84uk0/lx9/vj3mqqq++tW3Wr6tY5p76ftbLSt27dql2nTu3a++x99klibDMiQ5JAwzgb/O+y2oNN7dY6eaami3PAmCQhiaP3DIBpIjIVZQfvcgBX+ncQkVkAVgC4UFX9iw6/BOATIvI/UZ6jdw6AryaQhRBCCkNajlCWgxBJjG1GZEgSaBhnj2tRd9OXQuKAMWmUhh09VT0iItcDWA1gBID7VPU5EbkNwDpVXQngDgCdAH5UWT3hJVW9COUKnO8C8BuUC7P8XFX/T7JLIYQQu2h0BNkGRyiJsc2IjHs0O1pCwzhbXIu6u+a4EuKRaI6eqj4C4JHAtlt8f59X43dHAVyb5NyEEGIzSUaQbXGEwoztMMOfERm3MD1aQuJjw2BTHFxzXAnxSLRgOiGEkMZIUpXS9gWzo1TVdLmKXtHgOmDu4VpFaVa2JK7SlKqbhBBChpJ0BNnm1DSmSRUDL2p74NARRkscw7Wouy1ZEsQMTC3cUw06eoQQkgOupT7FgWlS7uNP11w8r6ewfd1WohiyNg82BXHNcSXZYVsqOlM3CSEkB1xLfYqDaWlSSRefLwJx28gftV2+5gUsvWRmIfu6jURJrXYRpouTKNiWis6IXhVsCskSQuykyCPIJqVJ2TY6mxVh771G2sgftd2wdTeWrd6MxfN68JYTx6K9deTg8fm+NQ+mVhM/fEaHYltGCh29AHzpE0KahUupT2FUMxRqObnNNipMMmqTXnujv6/33ovaRv7zi8iQdM0NW3djyapNQ35T1PetiFwI4GsoL031TVX9XzX2uwTl5aj+UlXX+bZPAbAJwK2quixt+dI0ZOkk2E1Rn9EwbJt2wdTNALaFZAkhxGRqpYEBGJYmlUfKmCmjs0mvPcnv6733orRR8Py3rnwWyxfMDk3XLOL7VkRGALgLwHsA9AC4QkR6quw3FsCnADxV5TBfAfCzrGRMK7W6qCmgLlHEZ7Qetk27oKMXwJSXPiGEuEBUQ6FUUry892DqRkW9uWWmzBdMalAl+X29916UNgqe/9FNO/H1x3+L+689q+YSIAV9354OYIuq/l5VDwH4IYD5VfZbAmApgIP+jSLyPgAvAnguKwHTMmT9fWLW5C4snteD/QNH8PLeg3T2LKGgz2goti1vREcvgCkvfUIIcYE40aA/7u5P1aiIElEwZXQ2qUGV5Pf13ntR2qja+R/dtBOqWrO4RUHftxMBbPV93lbZNoiIvB3AZFX9aWB7J4CbAPxDvZOIyDUisk5E1vX19cUSMC1D1usTsyZ3YdEF07Fk1SZcunwtLluxlpE9SyjoM1oXmwr30NELYMpLnxBCXCBONOjV/YdSNSqiRLlMGZ1NalAl+X29916UNmrk/HzfDkdEWlBOzfz7Kl/fCuBOVX2t3nFU9R5V7VXV3u7u7thypGHIen1i4dxTcdODG5n+ZyF8Ru2HxVgCFLkSHikenChP0iCsH0WpsOmN/Htl+D2jMKlRETXKFbUoTpbPS9JKpEl+H+W9V6+NGjl/M9+3Bum67QAm+z5PqmzzGAtgBoA1IgIAJwJYKSIXATgDwKUicjuALgAlETmoqt9oiuQx8frE/oEjuaX/GXTfh2GybB60ie2Hjl4VilIJL0tsUGBFh9W0SBrU60dRDAVv5N9fhn9CRytO7mrHieNGN9wf06yOFvd5iasDkxpUafw+yXuv0fM3431rmK57BsA0EZmKsoN3OYArvS9VdQ+A47zPIrIGwKJK1c13+LbfCuA1U5084PU+8fLeg7lUKWzmfY/7vBvWJ0OhTWw3TN0kqcNKW3bAalokDaKmR4algfnTg7wy/B1tIxM5ecHjAsnSjuI8L43qwKTpct7vTzqmfL079vQ3dQF4U+etmKTrVPUIgOsBrAbwPID7VfU5EbmtErVzipYWwYnjRueS/tes+97I825SnwTqF60i9sKIHkkdk9alIrVhNS1Sjbgj02n0o6zSg9I8bpzrzFMH2hQpaBam6TpVfQTAI4Ftt9TYd26N7bemLlhG5JX+16z73sjzblKfpM5wG0b0SOqYpMBIbVhNiwRpZGQ6rX6UVTQorePGuc48daBpkQIToK7Lnzyivc2674087yb1SeoMt6GjR1LHJAVGasNqWiRII+teNbMf5ZleFOc689SBHGgbDnVdMWnWfc+y4mwzdB51htswdZOkTtLqcaQ5sJoWCRJc9ypY/bJaKk+z+lHe6UX1rtOf8treOiI3HZhmARpXoK4rJs2671lVnG2WzqPOcBtRtWfCZW9vr65bty5vMUgEWHWTREVE1qtqb95yJMEV3dS3bwAX3/0kFs/rwZJVm4a9+POcZ+vJZpJMHtUMsu989HR0jh6Jw0dKTdWBeTvELuGCbgLc0U8mk4XN0yydR51hJ1H1EyN6JBNYjpcQ+zBh3ataVEsv6u5sw6EjR7F914FcB5SqzXG56r6n8fB1czBx/JimysLoFSHNJwubp1kpldQZbkNHjxBCCkK9Uee8170KI5heNGtyFz5z4XR88J5f5j4KbdocF9cG2pghQqLiUl9pZkqlazqDvA6LsRBCiOOUSoo/7x/A8zv21q2omee6V2EEixfccO403PjARiMqxbEAVXZwXVYSFdf6CosIkTTgHD3DcGk0ipAouDAPxmTd5Bk/L+85iMU/eTbyfI9auigPHeWds1Qq4agCqoqjqvir29cM2/fJm97Z9HRJznHJjjznZrqgmwCz9VOamDyPt1FoE5JacI6ehdBYIISkjTd/7MsfOC1WemG1VJ48dFStQiejR72e1jRrchcWzj0VEzpaIVJ2RpupMznHJTtMS4sl5uJiX2FKJUkKUzcNgotWEkIapdZ6S57xs7v/cOL0wjx0VPCc3Z1teGXvQdy68lksvWQmzu85HosumI4lqzbh0uVrcdmKtbmka+WxIHQRYFosiUrafSXPdTsJSQs6egbh4mgUISR7wuameMbP8jUvYOklMxPN98hDRwXPuXDuqbjxgY14dNNOLFu9GTde8ObB9f48eThA5g6cp0SikmZfcW2+HykuTN00CC5aSQhphFqRtoevmzNkMd9lqzdjyfwZmHpcB8a0jcBxHfEiT9UqX95w7jQc1fLIdxbpisFzdrWPGvx7w9bd+PP+QxwgcximxZKopNlXwnQqUymJTTCiZxAcuSSENEJYpM1v/HzjylmYMfEYTDl2DI4fOzq2AeTXUd7yBot/8iz+6vY1mY14B/XigUNHh6RnpZGSSsyGabEkKmn1FWZYEVdgRM8gbBm5ZBUoQsyiXjZAWhP6gzrKW8MOyG7EO3jO9tYRgxHKbbv68eD6rVi+YDYWfm/9kAIxHCAbjiu625XrIObCDCviCnT0DMP0CkusDEqIWZRKihEtwIoFs3FtE5wdT0dt33WgaSPeQb3Y1d46ZEBsfPso4wfI8sYV3R33OugUkkbwp7xzAInYDB09EgvmrZMiICKfAvAJAALgn1T1qzmLVBW/0dvd2ZZo/l1c8hzxrjYg1mz9Y5sDkaXublZblEqKl/cejHwdrji3pPnYkmFFSD04R4/EgnnrxHVEZAbKTt7pAE4DME9E3pivVNXxG+8btu7GR779DBbc+xQEkrlBYvuc4iSl022syJeV7m5WW3jn+ePu/sjXwSWLSBI4N9RNirZsBiN6JBbMWycF4C0AnlLVAwAgIv8G4P0Abs9VqirkOfBi84h30kiPjZkNjeruetG6ZrWFd57F83oGr2PW5C4snHsqJnS0QkRQKukQ2TgwSWzAtuwAmylilJ8RPRIL20fxCYnAswDeISITRGQMgPcCmBzcSUSuEZF1IrKur6+v6UIC+S8mbeuId9JIT9YORBYjzo3o7ijRumY5U955vPUgz+85HosumI4lqzbh0uVrcdmKtcNky/v5IKQeNmYH2EwRo/yJHD0RuVBENovIFhG5ucr3fycim0Rko4g8LiJvqGx/p4j82vfvoIi8L4ksRSLPsLN/FP/Jm96Jh6+b4/RICCkeqvo8gKUAHgXwcwC/BjDMalXVe1S1V1V7u7u7myxlmbQXCC5KOktS58TvQMya3IUVH5qNBxaeNRhVSkJcwy/qfWtEd0cxiprlTHnn2bB1N5at3owbL3gzbnpwY6hsHJgkplNExyNPihjlbzh1U0RGALgLwLsBbAPwjIisVNVNvt02AOhV1QMi8kmUU58+qKpPAHhb5TjHAtiCslFF6mBC2Nn0yqCEJEVV7wVwLwCIyP9AWcdlTlgKT63v0kifNEGvNJOkKeieA3HnY5tx9dlTBx2ONNotTipk3PsWV3dHMYqaVZ3Qf54NW3djT//hurLZnF5M7CRuGmYRHY88KeL0oyQRvdMBbFHV36vqIQA/BDDfv4OqPuHNcwHwSwCTqhznUgA/8+2XCq6NTnvXs2NPP0d/CMkYETm+8v8UlOfnfT/rc4ZFcsK+SyN9MmxUOWtdmoeuThrp8RyIWy+aUTeqFJc4hl/W0YAo0bpqkcJp3Z14df+hVO9p8Dwnd7VHiiTaml5MXscWe66RNEymFzeXIkb5kxRjmQhgq+/zNgBnhOz/MQA/q7L9cgBfqfUjEbkGwDUAMGXKlEiCuTY67b+eL3/gNI7+EJI9D4rIBACHAfytqu7O+oRhkRwAmRa8qOVclEqlTHVpXro6jUhPS4tAVVPXx3FGnLOOBkSN1vkjhVne0+B5uM6Z+9hkzzVSmIjr9TWXIkb5m1J1U0QWAOgFcE5g+0kA/gLA6lq/VdV7ANwDAL29vZGGcWysiBaG/3p29x8uXNiZkGajqu9o9jnrGe1ZGvS1nIujmq2DmaeuTiMFPYs0oDiGX73zJ63mV8soAoC+fQNVj9usexqUrb11BI6UFH37DuKoAqpaCCPOdWyy5xoZeCmi45E3RZt+lMTR246hlegmVbYNQUTOA/A5AOeo6kDg68sAPKyqhxPIMQzXcp791+NVHAvOCZnQ0coSvYRYTD2jPcsBnlrORaMRq6i6yHZdncVofBzDL+z8aUVCgkZRvePWu6dpvqc82TyZspgzSfLFJh3R6MCPLY4HbUw7SeLoPQNgmohMRdnBuxzAlf4dRGQWgBUALlTVnVWOcQWAzyaQoSquTbb0X49XcWzJ/Bk49fhOtI96fYTVlvSGZkCFRGyjntPgfdfd2YYbzp2Gqcd1QKHD1g4D4vf/Ws7Fq/sPxdalcRwM23V1VqPxUQ2/sPP37RtoKBKSdN28sHuaVRqef429anMmTYz+kGjYpCNcTsNM69mlbdZ8Gi7Golzq7B8AAB19SURBVKpHAFyPctrl8wDuV9XnROQ2EbmostsdADoB/KiyjMJK7/cicgrKEcF/a1SGWrg22TJ4PX2vDeDEY0ZjUlf74ORyluh9Ha5LQ2wkrPy9993K6+fgi++bgcU/eRZzl63B++/+xbC+3Wj/r1a0ohFdGkcXuaCr8y72Uev8jURC0lg3L+yeZvWe8mTqah9lTfSHRMMmHeHy8lNpPLu0zfIh0Rw9VX0EwCOBbbf4/j4v5Ld/QLmgS+q4lvMc5XpsSm/IGpty+gnxExbJaWkRHC0B135vfWjfTrP/N6JL4+gi13S1STQSCYnSd+odN+yeZvWe8mTiHHb3sE1H2JKGGZc0nl3aZvmQaMF0k8l7lDVt6l0PS/S+Dp1e4ipR+nba/T+uLo2ri0zU1baUcw+jkUhInHXzwo5b655m9Z7yZHpw/VYsvWSmFdEfEh0TdUTRSOPZpW2WD02pukmyx+Xc8LjYlNOfF8yTt5MofTvv/m+7LvLPRfHPhxzTNgLHddhjZDYSCYnSd5JEWLLqG55MX7p4JkqlEu6/9ixW3SQkRdJ4dvN+NxUVUbVnpLK3t1fXrVsX6zdFMmiLdK1h2LTuTh6Y1j4isl5Ve5t+4hRpRDc1QpR7Z8L9tVkX9e0bwMV3P4nuzjYsumC6kxUca92fZvQdm/qGC7oJaJ5+Im6T9Nk14d3kElH1k9OOHjtVcbHJmGg2niEbHFXLK0/eBWOqmYZUlL7N/j+cqG2yfdcBzFn6BFZ8aDaWrNpkzHOSFvXei+w7r+OCbgLMdvTy7G/s682HbZ4eUfWT06mbpk78jNPRbXgoTJTR1QnRacA8ebuJ0rfZ/4fSyJIPrlZwrPde9K9N9+r+Q9ixp98YvU7cIs/BeAYC8oHvpubjbDEWwEyDNk55WRtK0dogIxkKC/eQotHIkg8HDh118jmJ8l6kXifNIM9lobgkFSkKTjt6Jhq0cZSLDYrIBhnJUGxal4iQNGhkyYfTJh+DFQtmO/ecRHkvUq+TZpDnYLyJgQBCssDp1E0Tq7/FUS42KCIbZCRDsW1dIkKSErfaW0uL4NiONnS1tzr3nER5L1Kvk2aQZxVGVoAkRcFpR89EgzaOcrFBEdkgIxkO8+RJkWh00M/F5yTKe5F6nTSDPAfjTQwEEJIFTlfdNJE4E4BtmCxsg4zEbFyobOeCbnKNYJGo8e2jsKv/sDGDfiZDvV7GBd0EmK2fWHWTkMZg1U1DiRNlNDEiGSRvGamoCSFB6KgkI2+9TopDnlFzFyP2hASho5cDcZRLsxRREocpL2VJY44QUg1Tl9axCRrBhBBiP05X3TSFUknRt28A23cdQN++gaaVqI56XltLabtYGS6vvkKIS7CYCCGEEEJHL3PycKJKJcWf9w/g+R17I53XVofJNWPOVoebENPIc2kdDtaQeojIhSKyWUS2iMjNIftdIiIqIr2Vz+8WkfUi8pvK/+9qntTEBKhfSFzo6GVMs50oz1n49617cO331kc6r60Ok4nrJCbBVoebpA9f5snIa63IeoM1vK+1KUrbiMgIAHcBeA+AHgBXiEhPlf3GAvgUgKd8m/8E4G9U9S8AXA3gu9lLHJ2i3MO84GAwaQQ6ehnTbCfKcxbGtI6IfF5bHSbXFv621eEm6cKXeXL8xUSevOmdePi6OU2Zuxs2WMP7WpuCtc3pALao6u9V9RCAHwKYX2W/JQCWAjjobVDVDar6x8rH5wC0i4gREykLdg9zgYPBdmDagEehHL08Gr/ZTpTnLOzuPxz5vFEdJuM6b0xjzjT5gzDdjAB8maeFV0xk4vgx6B7b1pQCTWGDNS7e17T0hottE8JEAFt9n7dVtg0iIm8HMFlVfxpynEsA/EpVB9IXMT4Fu4e5wMFg8zFxwKMwVTfzqtDY7EU5PWdh+ZoXsPSSmbjpwY11zxullLapFS6jVoaLK79XhbRUKuGoAqqaeYnxvBZwNfXeFhW+zO0lbKFx1+5rmnrDtbZJgoi0APgKgA+H7PNWlKN954fscw2AawBgypQp6QpZBd7D7AnTL8QMTKz4XJiIXl6jTc1OIfKchb7XBrBs9WYsmT8DaxbNxUPXnR163nqj37aP1sWR3zNgPvfwRmzp24/LVqxtysiMielmpPnYmkodFZejx2HZEa7d1zT1hmttU4ftACb7Pk+qbPMYC2AGgDUi8gcAZwJY6SvIMgnAwwCuUtUXap1EVe9R1V5V7e3u7k75EoZTsHuYC65NV3EREwc8ChPRy7Pxm7keUVYL3ZrYef3UWwcwjvyeAbN4Xs9gRNTbP+uRmTzWrjL93haNvCK7zcD16HGY/nXtvqapN1xrmzo8A2CaiExF2cG7HMCV3pequgfAcd5nEVkDYJGqrhORLgA/BXCzqj7ZVKnrULB7mAtZ2XckPUyMuhbG0TOx8cMwbQFzk9svivEYR37PgOlqH1UIB8jke1tEXH6Zm5jWkja19K9r9zVNveFa24ShqkdE5HoAqwGMAHCfqj4nIrcBWKeqK0N+fj2ANwK4RURuqWw7X1V3Zit1fYp0D/Mkj8FgEh0TBzwKk7qZR8i70RSlLCdz1pOp1vcmpwxESSGKI79nwMQpaGMzJt/bopJHIZFmUPTosUv3NW294VLb1ENVH1HVN6nqqar6pcq2W6o5eao6V1XXVf7+oqp2qOrbfP9yd/I8inQPCalGXlNwwihMRC9stClJ9KwWSVKUshr1ridTve9NHa2LYjzGkd8zYO58bHPNgjZZ9Jm8aPTeutQGpDmYHj1mn46Oye8EQgjJC9Oirs45emEv6mqNn9WckSTOWlaj3vVkqvd91p23USMrqvEYVX7PgPnSxTNRKpVw/7VnDam6CaChPhN2fWkYmM1M93V9rhXJBhPTWjzYp+NjmkFDCCFkKE45eo28qLOKniVx1rIa9a4nU55pVUmMrCyMxzADpm/fQOw+E3Z9QGOOY5TjT+vuxK7+w6mPuBdhrhVJH5OjQOzThBQTRvLNgvcjXZyao9dIued6zk2j8+ySlBrOas5UPZnyLI+cpFR3s3OiG3GIw64vjTLl1Y5x52ObsXlnNnM9a7VBqVRytnR+lri85EAQU+fxFH3+ICFFxMQFrosM70f6OOXoNfKiDnNu4nS4oKE2vn1Uw85aVo5LNQfyOx89HQrF9l0HMKIFuRXlSGpkNct4LJUUIhLbIQ67vrjXXs0pqHaMS2ZPxrXfXZ/J+njVnpvze47Hn/YfooKOCV9sZsB1wAgpHlxH1ix4P9LHqdTNRlIew9L+oqbyhKXNNZqilMXch2DaVHvrCLyydwBX3f2LQbm/89HT8dB1Z+PwkVIqIfOoIXj/vZs1uQsL556KCR2tECkXiUlzLluSa9n8yr7QIi21qNc3o/bbWn1tQmfrsGNM6GjNLEJR7bn5/F/34MpvPsXUt5gwZdAMTJ4/SAjJBhcj+TanPrp4P/LGKUevkRd12JyRah2uu7MNh44cxfZdBwb3TcNQa9aD6Xcgq801u+q+p/HwdXMwcfyYxOeKOu+uVFKMaAFWLJiNrz3+W1x99tRhTlRac9mS4L/PffsOYfG8HkzoaMXJXe04cdzoUBnq9c2o/bZWX1t5/Zxhxzh+bFtDcz2j9MVqzw0VdGOw3czA5PmDhJBsML0ScFxsLyrl2v0wAaccvUZf1LWiZ8Eo02cunI7OtpH44D2/HPIAjRs9MpGhlteDGdXAbNQJjeIA+6+9u7MNd3zgNHz4W09X/Q2AVCIfjV6Pv702bN2Na7+7HgDw5E3vrLtMR72+GXXpj1r3rP/Q0WHH8NKHvba94dxpmHpcBxQ6JEoabBv//fB+M6ZtBI7rGJoSG3xu+vYNUEE3AF9s5sAqkoQUC9ci+bZniLh2P0zAKUcPSPdF7V9P7eqzp+Lg4RJufOBXQ9IL9w8cwbjRIyMZarUcgWY8mNXOHcXATOKERnEk/de+bVc/Xn1tIPQ3SSMfSa4nrL2iHDesb0Zd+uP7Hz+jpgzVjjH9hLFYef0c7Nh9ENd+b33da/buR3dnGxZdML1qZLVWO1FBNwbbjcTB5rQsQpKQRd93LZJve4aIa/fDBJxz9KLgKYtSqYSjiiFrpAUjFtNPGItbL5qBy1asxZc/cNqgk+c3gs/vOR7LF8zGwoAh7TfUqhnt3/no6egcPRL9hxp7MKNeR61zHzNmJFYsmD3MAfDLncQJjeJIBpXS7v7Dqcxlq0XY9XhpuLWUS9z5nHc+thm3XjSj5n1pRNYv/nQTVnxo9mCRlXpOQUuL4GgJg/c4eM3Be+jdj8Xzegb7tzeoUVLFjj3lY4Q9L1TQ8WC7mY8pzpXtaVmENEqWfd+lSL4LGSIu3Q8TKJyj5y+oEZwL5jlewUIkqoptu/oHnZCFc08d/B0APLppJwAMW1jbr3yCRnt3Zxte2XsQV923EYvn9cR+MMOuI6j8ws7d3dmGJfNn1EzPSzI65HeMvDTAN53QicNHS4NzHEeNbBly7cvXvIA7Lp2JGx+oXugkaeSj1rzLUqmE53fsDY16xZnPOWtyF64+eyouW7G24ZdSNVkf3bQTS+bPiOUUxLmH3kuiq33UkEGN//2LF3H12VOHOZjB63FJQYvIpwF8HIAC+A2Aj6jqwTSOXc1xcKXdXMMk58r2tCxCGoV9PxrMECFBEi2vICIXishmEdkiIjdX+f7vRGSTiGwUkcdF5A2+76aIyKMi8nxln1OSyBIVT1lcMnvyEGfNc37ef/cvhpU494zf5WtewNJLZlatZvjopp1QVUwcP2YwwhNW/n7h3FMHnRnvuHGWNah1HZ7y85eiDTv3hq278ZFvP4MF9z4FgQwzXJKUHPcco5XXz8EX3zcDP3j6P/GHVw/gshVrB9v4tYNHhizp0PfaAE4YNxoPXXf2sKUl0lh2wn89syZ34QefOAO3zX8rNu3YVzXqFSzpW2sZh2A7BQcDah0vbP20Wm3f0tISupRE8JieMx08TrV76L0kDhw6OmRQI0o/cwkRmQjgBgC9qjoDwAgAl6dxbC6nYBcmlfu2PS2LkEZh349Gs9cVJubTsKMnIiMA3AXgPQB6AFwhIj2B3TagbCjNBPAAgNt9330HwB2q+hYApwPY2agscfCUhRex8PA7P8DQl7ln/Pa9NoBlqzeja0xr7LX3gsa2//wbtu7GstWbsXheD/7fjXMjPZi1rsOT3a/8gg5DlN8AQ6thVnNCoyzy7E8drOYsXHXf0zhhXNsQpXTKhA4cP3Z0VUfGc7ROOqYsz449/bEWmPbu5fk9x2PRBdNx8HAJn/znX2FM64hEL5HgGoVRljaoZ/BXW/fQPwDgtf8re/rxx9392L7rAP68f2DYMYPOdNhAgveSOG3yMVixYPbgdUTtM44xEkC7iIwEMAbAH9M4qEmOA6mPSQYm1/ojRYV9PzrNWleY2EGSiN7pALao6u9V9RCAHwKY799BVZ9Q1QOVj78EMAkAKg7hSFV9rLLfa779MsVTFl4apkeYIesfIfnGlbNwbEftxdBrGXEjW2TIb7yIiceGrbuxZNUmtLeOjPRg1roOTx6/8gs6DMFzV/uN54Rc9I0n8fkfP4sl82dgzaK5eOi6s4csdRAlKlHPKe0/dDSWUkoSEfHPu7zpwY2DDl6UdqwlS9++AezY048TxrUNRiJP7mqve7wwg99L7Tt2zCjcf+1Zw0bmvDb43MMbsaVv/2CU9N+37qm6ZEbQmQ4bSGhpERzb0Ya3nDRu8DrqtU8Up98mVHU7gGUAXgKwA8AeVX00jWOb5DiQ+phkYNYb/CHEVdj3CWmMJHP0JgLY6vu8DcAZIft/DMDPKn+/CcBuEXkIwFQA/wrgZlUdZumIyDUArgGAKVOmJBC3jL+Spn/Ra8/5qTVPLjj3qKu9NfLae54zE1ysPEkeda3rqHacagul1zt3sBrmR779DCaNb8fD181BS4tUXYOvVr580Cn1F/iotih6PZLm6lebd+mlz8ZZBD1s7g5Qez6h58QdOHSkal8plUo1jts+bN6lv2gKgJqRyf5DR2OvjdjSIjhx3Ohh/Sy4VMORIyX8ru81I+YwpYWIjEd54GoqgN0AfiQiC1T1e759GtJNLkyWLxImzXlh4R5SVNj3CWmMphRjEZEFAHoBnOM77zsAzEJ5xPxfAHwYwL3B36rqPQDuAYDe3t7EYQJPWXzp4pkolUqDBVTiOl5R1t7zqFX+vpazmOQ6wha4jnPuelGHWt+XSiX07RsYctygU+oV9ohTut9PGhGR4LzLmx7ciGWrN4cWpglSz+Gs9lICXl/0vVYRnqNafb3AldfPwdFS+fqPVhzVYJS0XtXSuAT72UOfPBt9+waGFK35/sfPcHGS/HkAXlTVPgCoDEqdDWDQ0WtUN5nkOJD6mGZgulTwiJA4sO8TEp8kjt52AJN9nydVtg1BRM4D8DkA56jqQGXzNgC/VtXfV/b5MYAzUcXRy4JayiKJ4+URx4hLqrSS/L7eb+tFHap9f37P8fjT/kNVKzP6nYUv/M1bBxedB+I7BmlERPz3Ka6D5xHV2T3pmNcjcf5IaK0oohdt9NPd2TZkLbxvffgvh0VJgfpVSxvB31f8Tp53vTv3ha99aCkvAThTRMYA6AdwLoB1aRzYNMeB1IcGJiGEEBtJ4ug9A2CaiExF2cG7HMCV/h1EZBaAFQAuVNWdgd92iUh3ZcT8XUjJiEpCGi9zV4y4eg5rte8//9c9uPKbT9V04Ly23b7rQCzHIFiKfnz7qMQRkbj3KeqC82HObjC111+E5y0njkV768jBeZ7B495w7rQhDtbXH/8d7rh0Jr715ItDnEV/1dLgMiFpUM25rSav7amIqvqUiDwA4FcAjqBcWOqetI5Px4EQQgghWdOwo6eqR0TkegCrUS49fp+qPicitwFYp6orAdwBoBPl+S0A8JKqXqSqR0VkEYDHpfzFegD/lPRiTMEFI66eI1Tt+6gplXEicrXmwU3r7kzsTEe9T2EyxHV2g9fuFeHxRzOrOdFTj+sY0l4btu7G7T/fjG9cOQsjW6Ru6m5aVLt3D67fGmsRd1tQ1S8A+ELechBCCCGENEKiOXqq+giARwLbbvH9fV7Ibx8DMDPJ+Um21HOEgt/37RuI5MBFTW8tlRQv7z0Ya/5XtchbUqcnbC5eXGc3yrVXc6IVOqxt+14bQOvIEU0dVKgm/6ffPT0Vx5sQQgghhKRHU4qxkGIQ1YGLkjbpRdH2D1SvTFktzTOsCmYSpyPMeYvr7EZNGQ0et1RSIwp4hMlvexSbEEIIIcQl6OiR1Igz762eY+BfPiBqmmfSZRdqESfVNGrELq48ac39TCPiSaeOEJIVWWRlEEJIUaGjR1IlLSfAi6LFWd8uq4Wo41ZSzaoYT9K2zSriSQghaUAdRQgh6UJHjxiJF0XzV6ac0NGKk7vaceK40VVf+lktRB3XeTM14pVVxJMQkoywKFaRIlzUUcQEivTMEfdpyVsAQqrhRdE8Z2/Jqk3oaBtZ08kL/gZAqvPYPOdt4vgx6B4bbZ0908gq4kkIaRwvinXx3U9iztIncPHdT2LzK/tQKmnody5CHUXypmjPHHEfRvSIkTSSAunKGoZZkVXEkxDSOGFRLACD382a3IWFc0/F/oEjeHnvwdBBL1uhjiJ5w6gycQ1G9IixNBJFcyHylhVZRjwJIY0RFsXyvps1uQuLLpiOJas24dLla3HZirVORhmoo0jeMKpMXIMRPUIKAiOehJhHvSjWpPHtWDj31MGCVIC7UQbqKJI3jCoT12BEj5ACwYgnIWYRFsXyvpvQ0VqYKAN1FMkTRpWJazCiRwghhOREvSjW9BPG4uW9BxllIKQJMKpMXIMRPUIIISRHwqJYLS2CE8eNZpSBkCbBqDJxCUb0CCGEEINhlIEQQkgj0NEjhBBCDMeLMhBCCCFRYeomIYQQQgghhDgGHT1CCCGEEEIIcQw6eoQQQgghhBDiGHT0CCGEEEIIIcQx6OgRQgghhBBCiGPQ0SOEEEIIIYQQx6CjRwghhBBCCCGOQUePEEIIIYQQQhyDjh4hhBBCCCGEOIaoat4yREZE+gD8Z8TdjwPwpwzFSRObZAXsktcmWQG75E1L1jeoancKx8kNh3UTYJe8NskK2CWvTbIC6chrvW4CnNZPNskK2CWvTbICdsnbVNvJKkcvDiKyTlV785YjCjbJCtglr02yAnbJa5OsJmFbu9kkr02yAnbJa5OsgH3ymoJN7WaTrIBd8tokK2CXvM2WlambhBBCCCGEEOIYdPQIIYQQQgghxDFcdvTuyVuAGNgkK2CXvDbJCtglr02ymoRt7WaTvDbJCtglr02yAvbJawo2tZtNsgJ2yWuTrIBd8jZVVmfn6BFCCCGEEEJIUXE5okcIIYQQQgghhYSOHiGEEEIIIYQ4hpOOnohcKCKbRWSLiNyctzx+RGSyiDwhIptE5DkR+VRl+7Ei8piI/K7y//i8ZfUQkREiskFEVlU+TxWRpyrt+y8i0pq3jB4i0iUiD4jIf4jI8yJylqltKyKfrvSBZ0XkByIy2qS2FZH7RGSniDzr21a1LaXM1ytybxSRt+clt8lQN6WPLfrJJt0EmK2fqJvSx2TdBNipn2zRTYBd+slk3VSRzyj95JyjJyIjANwF4D0AegBcISI9+Uo1hCMA/l5VewCcCeBvK/LdDOBxVZ0G4PHKZ1P4FIDnfZ+XArhTVd8IYBeAj+UiVXW+BuDnqvpmAKehLLdxbSsiEwHcAKBXVWcAGAHgcpjVtt8GcGFgW622fA+AaZV/1wD4xybJaA3UTZlhi36yQjcBVuinb4O6KTUs0E2AnfrJFt0EWKKfLNBNgGn6SVWd+gfgLACrfZ8/C+CzecsVIu9PALwbwGYAJ1W2nQRgc96yVWSZVOmU7wKwCoAA+BOAkdXaO2dZjwHwIipFhnzbjWtbABMBbAVwLICRlba9wLS2BXAKgGfrtSWAFQCuqLYf/w22CXVT+jJaoZ9s0k0VWYzXT9RNqbalVbqpIqPR+skW3VSRxRr9ZINuqshgjH5yLqKH1zuBx7bKNuMQkVMAzALwFIATVHVH5auXAZyQk1hBvgrgMwBKlc8TAOxW1SOVzya171QAfQC+VUmX+KaIdMDAtlXV7QCWAXgJwA4AewCsh7lt61GrLa157nLEmjayRDcB9ugna3QTYK1+om5qHKvayBL9ZItuAizST5bqJiBH/eSio2cFItIJ4EEA/11V9/q/07Jbn/u6FyIyD8BOVV2ftywRGQng7QD+UVVnAdiPQKqBQW07HsB8lBXsyQA6MDzUbzSmtCVJFxt0E2CdfrJGNwH26yeT2pKkiw36yTLdBFikn2zXTUDz29JFR287gMm+z5Mq24xBREahrKj+WVUfqmx+RUROqnx/EoCdecnnYw6Ai0TkDwB+iHIKwtcAdInIyMo+JrXvNgDbVPWpyucHUFZeJrbteQBeVNU+VT0M4CGU29vUtvWo1ZbGP3cGYHwbWaSbALv0k026CbBTP1E3NY4VbWSRfrJJNwF26ScbdROQo35y0dF7BsC0SgWeVpQnaa7MWaZBREQA3AvgeVX9iu+rlQCurvx9Ncr557miqp9V1UmqegrK7fh/VfW/AXgCwKWV3YyQFQBU9WUAW0VkemXTuQA2wcC2RTnt4EwRGVPpE56sRratj1ptuRLAVZUKUmcC2ONLUyBlqJtSxCb9ZJluAuzUT9RNjWO0bgLs0k826SbAOv1ko24C8tRPWU1EzPMfgPcC+C2AFwB8Lm95ArL9V5RDthsB/Lry770o528/DuB3AP4VwLF5yxqQey6AVZW//wuApwFsAfAjAG15y+eT820A1lXa98cAxpvatgD+AcB/AHgWwHcBtJnUtgB+gHIO/GGUR/w+VqstUZ5oflflmfsNyhWxcm9j0/5RN2Umu/H6ySbdVJHXWP1E3ZRJmxqrmyryWamfbNBNFdms0U8m66aKfEbpJ6mciBBCCCGEEEKII7iYukkIIYQQQgghhYaOHiGEEEIIIYQ4Bh09QgghhBBCCHEMOnqEEEIIIYQQ4hh09AghhBBCCCHEMejoEUIIIYQQQohj0NEjhBBCCCGEEMf4/3jgneuVwZ0hAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 1080x864 with 6 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "start = 0\n",
    "\n",
    "f, ((c1r1, c1r2, c1r3), (c2r1, c2r2, c2r3)) = plt.subplots(2, 3, sharey=False)\n",
    "f.set_size_inches(15, 12)\n",
    "\n",
    "c1r1.set_title(\"Train losses - 0.33 a, 2.00 w, 8e-5, 1e-2 \")\n",
    "sns.scatterplot(y = np.array(train_losses[start:]),\n",
    "                x = np.array([x for x in range(len(train_losses[start:]))]),\n",
    "               ax = c1r1)\n",
    "\n",
    "c1r2.set_title(\"October 3 - F1 score\")\n",
    "sns.scatterplot(y = np.array(f1s[start:]),\n",
    "                x = np.array([x for x in range(len(f1s[start:]))]),\n",
    "               ax = c1r2)\n",
    "\n",
    "c2r1.set_title(\"Test losses\")\n",
    "sns.scatterplot(y = np.array(test_losses[start:]),\n",
    "                x = np.array([x for x in range(len(test_losses[start:]))]),\n",
    "               ax = c2r1)\n",
    "\n",
    "c2r2.set_title(\"Errors\")\n",
    "sns.scatterplot(y = np.array(errors[start:]),\n",
    "                x = np.array([x for x in range(len(errors[start:]))]),\n",
    "               ax = c2r2)\n",
    "\n",
    "c2r3.set_title(\"Hausdorff\")\n",
    "sns.scatterplot(y = np.array(hausdorff[start:]),\n",
    "                x = np.array([x for x in range(len(errors[start:]))]),\n",
    "               ax = c2r3)\n",
    "\n",
    "c1r3.set_title(\"Dice\")\n",
    "sns.scatterplot(y = np.array(dices[start:]),\n",
    "                x = np.array([x for x in range(len(dices[start:]))]),\n",
    "               ax = c1r3)\n",
    "\n",
    "plt.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# Make sure that the equibatch is working with the augmentation\n",
    "randomize = equibatch(train_ids)\n",
    "sum_no_equibatch = []\n",
    "sum_equibatch = []\n",
    "for k in tnrange(int(len(randomize) // 20)):\n",
    "    rand = [x for x in range(len(randomize))]\n",
    "    batch_ids = rand[k*BATCH_SIZE:(k+1)*BATCH_SIZE]\n",
    "    _, y_batch = augment_batch(batch_ids, BATCH_SIZE)\n",
    "    sum_no_equibatch.append(np.sum(y_batch))\n",
    "    \n",
    "for k in tnrange(int(len(randomize) // 20)):\n",
    "    batch_ids = randomize[k*BATCH_SIZE:(k+1)*BATCH_SIZE]\n",
    "    _, y_batch = augment_batch(batch_ids, BATCH_SIZE)\n",
    "    sum_equibatch.append(np.sum(y_batch))\n",
    "    \n",
    "print(\"No equibatch SD: {}\".format(np.std(np.array(sum_no_equibatch))))\n",
    "print(\"Equibatch SD: {}\".format(np.std(np.array(sum_equibatch))))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# September changes\n",
    "- Implement equibatch\n",
    "- Implement 4x4 FPA, with CSSE in middle blocks\n",
    "- Reduce label smoothing from 0.08 to 0.03\n",
    "- reduce dropblock to 0.95 from 0.8\n",
    "\n",
    "# Things to test\n",
    "- Concatenating mean after GRU\n",
    "- Turning of sse in GRU"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 78, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b115d046e9744c34a5f18062053f237e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 78: Loss 0.257999986410141\n",
      "75\n",
      "all: Val loss: 0.2770000100135803 Thresh: 0.6 F1: 0.883 R: 0.907 P: 0.859 D: 0.585 H: 0.42 Error: 8.772\n",
      "Saving model with 0.5847387439838561\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 79, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b37e46c2d9b14c1ca11e527329dd59f0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 79: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.879 R: 0.887 P: 0.872 D: 0.643 H: 0.455 Error: 9.748\n",
      "Saving model with 0.6426870410077185\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 80, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b70d08e121234fada180c995286c5770",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 80: Loss 0.2590000033378601\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.902 P: 0.867 D: 0.638 H: 0.44 Error: 9.017\n",
      "Saving model with 0.6380304408177268\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 81, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "a9fee82886ab4c9e8f59bc0bddb72ea9",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 81: Loss 0.2549999952316284\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.45 F1: 0.882 R: 0.896 P: 0.868 D: 0.632 H: 0.439 Error: 9.128\n",
      "Saving model with 0.6316572892630127\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 82, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7cb6fa12cf264f7b826c4176b5151525",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 82: Loss 0.2549999952316284\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.91 P: 0.86 D: 0.651 H: 0.474 Error: 8.783\n",
      "Saving model with 0.6508574877414848\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 83, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "fab92589f8c744fc9d99c7c035f7df39",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 83: Loss 0.257999986410141\n",
      "75\n",
      "all: Val loss: 0.3199999928474426 Thresh: 0.6 F1: 0.843 R: 0.805 P: 0.884 D: 0.571 H: 0.448 Error: 13.553\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 84, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "abb900a6dcde4ac5b0d1a312b3c0c87c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 84: Loss 0.25699999928474426\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.886 R: 0.904 P: 0.869 D: 0.64 H: 0.424 Error: 9.188\n",
      "Saving model with 0.6403583136495129\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 85, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f66a3d8d91fe44fbaaacfbf120e86360",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 85: Loss 0.2549999952316284\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.884 R: 0.904 P: 0.865 D: 0.649 H: 0.454 Error: 9.212\n",
      "Saving model with 0.6490416961648612\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 86, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b0a71d1684c647838ead7e7428f2900b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 86: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.4 F1: 0.877 R: 0.876 P: 0.878 D: 0.64 H: 0.46 Error: 10.528\n",
      "Saving model with 0.6398700433186314\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 87, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "23c8b05a7dfa4ed4ae886e60686df00c",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 87: Loss 0.2529999911785126\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.45 F1: 0.878 R: 0.888 P: 0.867 D: 0.628 H: 0.473 Error: 9.839\n",
      "Saving model with 0.6282944697738909\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 88, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "dd7dfd2184f2413485e61a8efb8c882f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 88: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.912 P: 0.858 D: 0.652 H: 0.428 Error: 8.913\n",
      "Saving model with 0.6518133736802593\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 89, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ce44ab3d502d4674a3ab93b33ac77186",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 89: Loss 0.2540000081062317\n",
      "75\n",
      "all: Val loss: 0.2669999897480011 Thresh: 0.5 F1: 0.876 R: 0.881 P: 0.87 D: 0.614 H: 0.414 Error: 9.352\n",
      "Saving model with 0.6140965298928375\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 90, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ac3692931053432a97cf254b24871e10",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 90: Loss 0.25200000405311584\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.885 R: 0.904 P: 0.867 D: 0.641 H: 0.46 Error: 9.31\n",
      "Saving model with 0.6405345383271784\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 91, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0e7f85577dfa449cbcf1748868c9a4e9",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 91: Loss 0.25699999928474426\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.885 R: 0.914 P: 0.858 D: 0.657 H: 0.477 Error: 8.859\n",
      "Saving model with 0.6565049917178822\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 92, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "35e32ad026e144aa91204fe8c0e441d0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 92: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.27300000190734863 Thresh: 0.55 F1: 0.87 R: 0.883 P: 0.857 D: 0.612 H: 0.447 Error: 10.003\n",
      "Saving model with 0.611845482676035\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 93, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "308d6b6dab9b4c36a346c7edea19749a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 93: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.4 F1: 0.878 R: 0.914 P: 0.845 D: 0.665 H: 0.434 Error: 9.181\n",
      "Saving model with 0.6653243463602638\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 94, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "534acbb5b6c74cc398012e5251d519bb",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 94: Loss 0.25699999928474426\n",
      "75\n",
      "all: Val loss: 0.2669999897480011 Thresh: 0.55 F1: 0.881 R: 0.907 P: 0.856 D: 0.619 H: 0.465 Error: 9.091\n",
      "Saving model with 0.6194530368837815\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 95, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1895547ea6604d95aefb04070985667e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 95: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.27000001072883606 Thresh: 0.55 F1: 0.88 R: 0.9 P: 0.862 D: 0.617 H: 0.438 Error: 9.401\n",
      "Saving model with 0.6174196288250035\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 96, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "a184bbe63d0d450aa928a70e1ca28124",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 96: Loss 0.25200000405311584\n",
      "75\n",
      "all: Val loss: 0.27000001072883606 Thresh: 0.5 F1: 0.873 R: 0.885 P: 0.862 D: 0.636 H: 0.459 Error: 10.041\n",
      "Saving model with 0.6363312596577573\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 97, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "4fe188f05f6541f9bfd273137e8c933e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 97: Loss 0.25200000405311584\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.45 F1: 0.884 R: 0.91 P: 0.86 D: 0.644 H: 0.468 Error: 8.805\n",
      "Saving model with 0.6440664456881896\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 98, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "bd4a84a6a45a4c7b939d92b6aea0444d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 98: Loss 0.25099998712539673\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.885 R: 0.895 P: 0.874 D: 0.642 H: 0.424 Error: 9.793\n",
      "Saving model with 0.6419391916353786\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 99, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "85ece29fb89447c99f94afe5878844e3",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 99: Loss 0.2529999911785126\n",
      "75\n",
      "all: Val loss: 0.26899999380111694 Thresh: 0.55 F1: 0.878 R: 0.896 P: 0.86 D: 0.627 H: 0.416 Error: 9.524\n",
      "Saving model with 0.6274170955856144\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 100, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d11d494c9c1747b5ad950ecd2edb409b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 100: Loss 0.2590000033378601\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.4 F1: 0.88 R: 0.917 P: 0.846 D: 0.618 H: 0.444 Error: 8.325\n",
      "Saving model with 0.6176917557586576\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 101, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "8685f99e8d184e27ab277cf5eb6e52d1",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 101: Loss 0.25699999928474426\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.45 F1: 0.881 R: 0.888 P: 0.874 D: 0.623 H: 0.408 Error: 9.653\n",
      "Saving model with 0.6229662577022711\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 102, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "885a1b5ad8e34d54af98346cbe87653d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 102: Loss 0.2529999911785126\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.888 R: 0.898 P: 0.879 D: 0.622 H: 0.433 Error: 8.87\n",
      "Saving model with 0.6220705066809479\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 103, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ac23ec01729946a49838253d98d7a851",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 103: Loss 0.25600001215934753\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.4 F1: 0.883 R: 0.898 P: 0.869 D: 0.646 H: 0.45 Error: 9.465\n",
      "Saving model with 0.646151499312362\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 104, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7f7cbaf9dd474211bcec8097620e1926",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 104: Loss 0.24799999594688416\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.895 P: 0.874 D: 0.637 H: 0.464 Error: 9.527\n",
      "Saving model with 0.636825834266749\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 105, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "fed5dca3910b4ac98815af150ca90a1b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 105: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.879 R: 0.898 P: 0.861 D: 0.653 H: 0.463 Error: 9.78\n",
      "Saving model with 0.6534945372150316\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 106, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "64c126bb4fdb4d8f8418fb82f556c678",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 106: Loss 0.24699999392032623\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.5 F1: 0.88 R: 0.901 P: 0.86 D: 0.625 H: 0.468 Error: 9.163\n",
      "Saving model with 0.6248974816532133\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 107, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "dbea984cbd9f417eb6b6d88a48448c61",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 107: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.45 F1: 0.884 R: 0.902 P: 0.867 D: 0.631 H: 0.438 Error: 9.292\n",
      "Saving model with 0.6311724380412959\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 108, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ff14b79c2e3449eea4693e46ad1afbf4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 108: Loss 0.25099998712539673\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.888 R: 0.907 P: 0.871 D: 0.647 H: 0.429 Error: 9.14\n",
      "Saving model with 0.6474887542116438\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 109, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "44c785d81aee483ea6c88ae422f5211b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 109: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.885 R: 0.897 P: 0.872 D: 0.64 H: 0.46 Error: 9.225\n",
      "Saving model with 0.6397742432553998\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 110, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f9433b8ba4824d51b4dea18395950471",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 110: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.2639999985694885 Thresh: 0.5 F1: 0.882 R: 0.897 P: 0.868 D: 0.631 H: 0.452 Error: 9.138\n",
      "Saving model with 0.6308350821592965\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 111, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "d7d1106f697d499fbe8ef972064e9f11",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 111: Loss 0.24799999594688416\n",
      "75\n",
      "all: Val loss: 0.2709999978542328 Thresh: 0.5 F1: 0.864 R: 0.87 P: 0.858 D: 0.613 H: 0.474 Error: 10.412\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 112, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1cf66441bdbb48d6a507c47c58401e5b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 112: Loss 0.24899999797344208\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.886 R: 0.92 P: 0.854 D: 0.661 H: 0.456 Error: 8.513\n",
      "Saving model with 0.6610112569338923\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 113, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1fa42c43ff2246ab944cfc6904cc4fb5",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 113: Loss 0.24699999392032623\n",
      "75\n",
      "all: Val loss: 0.2669999897480011 Thresh: 0.5 F1: 0.88 R: 0.887 P: 0.872 D: 0.624 H: 0.438 Error: 9.474\n",
      "Saving model with 0.6244776242533411\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 114, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ba52c0251b4849c1a8d995a1682d9eb4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 114: Loss 0.24799999594688416\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.888 R: 0.911 P: 0.867 D: 0.656 H: 0.43 Error: 8.653\n",
      "Saving model with 0.6555088490918676\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 115, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "97008889c97145a8888633b12ec0efe0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 115: Loss 0.2460000067949295\n",
      "75\n",
      "all: Val loss: 0.2750000059604645 Thresh: 0.55 F1: 0.867 R: 0.866 P: 0.868 D: 0.612 H: 0.471 Error: 10.198\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 116, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1d81157a0f684f7d959f9d3b879e1ca5",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 116: Loss 0.25099998712539673\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.45 F1: 0.887 R: 0.903 P: 0.872 D: 0.629 H: 0.482 Error: 8.968\n",
      "Saving model with 0.6290329248499251\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 117, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ec1e81a334fe45c5967db5d2c41c7d94",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 117: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.887 R: 0.897 P: 0.878 D: 0.646 H: 0.436 Error: 9.552\n",
      "Saving model with 0.6461579335274751\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 118, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "11a072d1fffc46c5af10eea996b3a0e2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 118: Loss 0.24500000476837158\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.89 R: 0.923 P: 0.859 D: 0.656 H: 0.446 Error: 8.237\n",
      "Saving model with 0.6555760610947508\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 119, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1baaec91f31243a6a1e0fae4e73a6fb7",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 119: Loss 0.24899999797344208\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.45 F1: 0.889 R: 0.903 P: 0.876 D: 0.637 H: 0.42 Error: 8.718\n",
      "Saving model with 0.6373480114322347\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 120, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "cd4e8aa666e548cc84e8b06ae08f844e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 120: Loss 0.24400000274181366\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.886 R: 0.912 P: 0.862 D: 0.648 H: 0.472 Error: 8.684\n",
      "Saving model with 0.6482243077724903\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 121, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b76c510de8d14f41a0568146c1e84509",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 121: Loss 0.24699999392032623\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.883 R: 0.926 P: 0.843 D: 0.654 H: 0.494 Error: 8.03\n",
      "Saving model with 0.6542075588602395\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 122, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "fd3f65e5b6294ff8948ab1a82ed47226",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 122: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.885 R: 0.894 P: 0.876 D: 0.647 H: 0.468 Error: 9.418\n",
      "Saving model with 0.6471618652889325\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 123, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "8f9983fbdcf74cc69959f2c8559485ff",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 123: Loss 0.24699999392032623\n",
      "75\n",
      "all: Val loss: 0.257999986410141 Thresh: 0.4 F1: 0.891 R: 0.908 P: 0.875 D: 0.649 H: 0.415 Error: 9.005\n",
      "Saving model with 0.6492462519575202\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 124, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b9eaebb81cfe45cc8e612f2e34ef3f32",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 124: Loss 0.24199999868869781\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.89 R: 0.905 P: 0.875 D: 0.645 H: 0.469 Error: 8.904\n",
      "Saving model with 0.6448285147205174\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 125, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ebe5a0cc96514baaad16406780a725ff",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 125: Loss 0.24199999868869781\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.885 R: 0.89 P: 0.88 D: 0.633 H: 0.473 Error: 9.274\n",
      "Saving model with 0.633174652785487\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 126, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "39b4e0904633444b84d5a5f90084ae5d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 126: Loss 0.24199999868869781\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.888 R: 0.913 P: 0.864 D: 0.644 H: 0.493 Error: 8.433\n",
      "Saving model with 0.6439155988157441\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 127, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ae894b54438e452caf4dc0da7b79cb8a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 127: Loss 0.24500000476837158\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.5 F1: 0.878 R: 0.899 P: 0.857 D: 0.638 H: 0.483 Error: 9.382\n",
      "Saving model with 0.6377308178430875\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 128, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0bfb52af3d1040b2a4d24e9799e4d9ae",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 128: Loss 0.24500000476837158\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.4 F1: 0.88 R: 0.88 P: 0.879 D: 0.646 H: 0.456 Error: 10.673\n",
      "Saving model with 0.646106158761863\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 129, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "cbe3565bf934481d89e261af92c3aee4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 129: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.257999986410141 Thresh: 0.4 F1: 0.892 R: 0.917 P: 0.868 D: 0.651 H: 0.437 Error: 8.401\n",
      "Saving model with 0.650807340319897\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 130, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "17594033cadb4025bd68db5790e6dd41",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 130: Loss 0.24400000274181366\n",
      "75\n",
      "all: Val loss: 0.26899999380111694 Thresh: 0.45 F1: 0.869 R: 0.869 P: 0.868 D: 0.631 H: 0.481 Error: 10.686\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 131, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f8282e4e6a0743eb890fad9ee4c57c74",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 131: Loss 0.2460000067949295\n",
      "75\n",
      "all: Val loss: 0.2849999964237213 Thresh: 0.6 F1: 0.861 R: 0.863 P: 0.86 D: 0.606 H: 0.464 Error: 10.696\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 132, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "2f4d5121be4e498aa5aaa034e117bb21",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 132: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.2639999985694885 Thresh: 0.4 F1: 0.883 R: 0.933 P: 0.838 D: 0.665 H: 0.44 Error: 7.742\n",
      "Saving model with 0.6645813570752133\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 133, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7c1e4f9717a1447cb2f46b373921346d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 133: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.886 R: 0.892 P: 0.88 D: 0.644 H: 0.427 Error: 9.515\n",
      "Saving model with 0.6438142517227122\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 134, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3cd7f72a2ceb49b982a9b5b1ba42bd35",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 134: Loss 0.2409999966621399\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.45 F1: 0.89 R: 0.901 P: 0.879 D: 0.638 H: 0.473 Error: 8.931\n",
      "Saving model with 0.6380702793901692\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 135, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0b889f9210ef4cd28dc91ce7ec337dfe",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 135: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.891 R: 0.924 P: 0.86 D: 0.654 H: 0.499 Error: 7.733\n",
      "Saving model with 0.6537644029063651\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 136, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "67a7022d5da84ae49399398d262b1627",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 136: Loss 0.24400000274181366\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.892 R: 0.927 P: 0.86 D: 0.651 H: 0.477 Error: 7.682\n",
      "Saving model with 0.6513077771274256\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 137, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "a08bcd63c8cf403c9f6a71ce1a3351fd",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 137: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.2639999985694885 Thresh: 0.4 F1: 0.884 R: 0.92 P: 0.851 D: 0.646 H: 0.504 Error: 8.049\n",
      "Saving model with 0.6464116002271403\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 138, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3c2441dd51e844afb33c027b7a6914b4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 138: Loss 0.24500000476837158\n",
      "75\n",
      "all: Val loss: 0.2639999985694885 Thresh: 0.45 F1: 0.875 R: 0.887 P: 0.864 D: 0.641 H: 0.473 Error: 9.958\n",
      "Saving model with 0.6411909668452709\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 139, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b531bdfa769f41b9b641761eb5a961ea",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 139: Loss 0.2460000067949295\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.888 R: 0.899 P: 0.877 D: 0.647 H: 0.497 Error: 8.899\n",
      "Saving model with 0.6467135248476973\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 140, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "799f138c9a334771a44c5ad75d33bc5b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 140: Loss 0.2409999966621399\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.45 F1: 0.885 R: 0.899 P: 0.872 D: 0.641 H: 0.503 Error: 9.528\n",
      "Saving model with 0.6414053464679604\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 141, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7986268a3ce34f519aa7e4ed188b1e48",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 141: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.45 F1: 0.88 R: 0.897 P: 0.864 D: 0.642 H: 0.426 Error: 9.374\n",
      "Saving model with 0.6422232326003673\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 142, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "247e7e30665e49cf9cb746fdbbf56b0d",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 142: Loss 0.2460000067949295\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.886 R: 0.913 P: 0.861 D: 0.65 H: 0.495 Error: 8.819\n",
      "Saving model with 0.6495119445052833\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 143, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e49cff881d384ccc812306e8cdbd9c8e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 143: Loss 0.24500000476837158\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.882 P: 0.886 D: 0.647 H: 0.455 Error: 10.236\n",
      "Saving model with 0.6471582577763235\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 144, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "36d388e77b694e6d8be4184b97634b66",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 144: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.891 R: 0.903 P: 0.879 D: 0.646 H: 0.464 Error: 9.046\n",
      "Saving model with 0.646080436319169\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 145, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "faf718b4ba5b47d38aa1a975ca5f439e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 145: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.45 F1: 0.887 R: 0.906 P: 0.87 D: 0.64 H: 0.416 Error: 8.672\n",
      "Saving model with 0.6399896979450738\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 146, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "439c6fdd7d7c4c3580f02aeec8aee24b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 146: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.2800000011920929 Thresh: 0.6 F1: 0.873 R: 0.884 P: 0.863 D: 0.613 H: 0.48 Error: 10.088\n",
      "Saving model with 0.6128746115736199\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 147, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "080a40fbacbb41baa8e39b10db464372",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 147: Loss 0.2409999966621399\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.45 F1: 0.88 R: 0.886 P: 0.875 D: 0.633 H: 0.512 Error: 9.531\n",
      "Saving model with 0.632991270519556\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 148, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "ff66d84c5f6843618d9b55ba3ba08fcf",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 148: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.888 R: 0.906 P: 0.87 D: 0.648 H: 0.479 Error: 8.78\n",
      "Saving model with 0.6478519393450267\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 149, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e4208960a17946058a8723c5d33f6829",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 149: Loss 0.2409999966621399\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.886 R: 0.914 P: 0.86 D: 0.653 H: 0.468 Error: 8.626\n",
      "Saving model with 0.6530457259334039\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 150, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "fecd0b39acf444dca9852a0a6780402f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 150: Loss 0.2370000034570694\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.5 F1: 0.886 R: 0.905 P: 0.867 D: 0.632 H: 0.472 Error: 8.958\n",
      "Saving model with 0.6318969421861738\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 151, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "f62c1599d4404b2187bc51163cade8f0",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 151: Loss 0.24199999868869781\n",
      "75\n",
      "all: Val loss: 0.26499998569488525 Thresh: 0.5 F1: 0.878 R: 0.896 P: 0.862 D: 0.642 H: 0.456 Error: 9.567\n",
      "Saving model with 0.6424607746560417\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 152, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "def5d1cca44f46cb989f876d4a04ea86",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 152: Loss 0.24300000071525574\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.888 R: 0.905 P: 0.871 D: 0.643 H: 0.472 Error: 8.823\n",
      "Saving model with 0.6427575256483601\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 153, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5bfc6235083241e2b1da44be63b674c3",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 153: Loss 0.23800000548362732\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.884 R: 0.921 P: 0.85 D: 0.662 H: 0.472 Error: 8.366\n",
      "Saving model with 0.6615856524990635\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 154, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "287d4ce94ac24029bcac43f654236ae4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 154: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.4 F1: 0.889 R: 0.902 P: 0.877 D: 0.65 H: 0.459 Error: 9.001\n",
      "Saving model with 0.6501414011571381\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 155, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "9cbc8d3f80c44f0f8cd819fe00b8e516",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 155: Loss 0.2370000034570694\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.45 F1: 0.888 R: 0.897 P: 0.879 D: 0.637 H: 0.465 Error: 9.527\n",
      "Saving model with 0.6366227228569972\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 156, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "362a1ef49cee432db4753804a3d774e2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 156: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.45 F1: 0.887 R: 0.901 P: 0.875 D: 0.645 H: 0.43 Error: 8.87\n",
      "Saving model with 0.6454197585990951\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 157, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "a1ecadc8f6e847cb8fee2d3349a76081",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 157: Loss 0.2370000034570694\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.888 R: 0.887 P: 0.889 D: 0.639 H: 0.499 Error: 9.599\n",
      "Saving model with 0.638535845374485\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 158, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "1417bd54448b4eb98dd160ed1f2a1853",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 158: Loss 0.2370000034570694\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.883 R: 0.888 P: 0.879 D: 0.642 H: 0.498 Error: 9.68\n",
      "Saving model with 0.6416606358872309\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 159, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7d7f141dc3814417a87381c83dfae501",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 159: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.45 F1: 0.887 R: 0.901 P: 0.874 D: 0.637 H: 0.489 Error: 8.808\n",
      "Saving model with 0.6372659243402793\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 160, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b26dca2cd786408b887a974c744c7ffa",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 160: Loss 0.24400000274181366\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.4 F1: 0.881 R: 0.878 P: 0.885 D: 0.637 H: 0.476 Error: 10.024\n",
      "Saving model with 0.6367586611488245\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 161, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7be7afc77abe49838f27c9f4ddbe8b75",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 161: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.888 R: 0.897 P: 0.879 D: 0.652 H: 0.474 Error: 9.53\n",
      "Saving model with 0.6521576108361848\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 162, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "4faf6900e81a4c97ad40175ab335ab76",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 162: Loss 0.23499999940395355\n",
      "75\n",
      "all: Val loss: 0.257999986410141 Thresh: 0.4 F1: 0.893 R: 0.908 P: 0.878 D: 0.641 H: 0.494 Error: 8.398\n",
      "Saving model with 0.6411651852920782\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 163, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e16ae067e6944cf1b8e68284ba8d1210",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 163: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.2680000066757202 Thresh: 0.4 F1: 0.879 R: 0.935 P: 0.829 D: 0.659 H: 0.483 Error: 7.768\n",
      "Saving model with 0.6588297125433765\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 164, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0a6c2f413a4341158af203b1c61a9c04",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 164: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.2759999930858612 Thresh: 0.55 F1: 0.868 R: 0.868 P: 0.868 D: 0.618 H: 0.442 Error: 10.209\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 165, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "0bb35b48e3f34995b8d6ac18a48a2fd6",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 165: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.2639999985694885 Thresh: 0.4 F1: 0.88 R: 0.891 P: 0.868 D: 0.641 H: 0.492 Error: 9.211\n",
      "Saving model with 0.640822133584205\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 166, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "55ffcef78f12483380e7b5fa51831deb",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 166: Loss 0.2370000034570694\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.45 F1: 0.891 R: 0.905 P: 0.876 D: 0.638 H: 0.487 Error: 9.001\n",
      "Saving model with 0.6380268689709359\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 167, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "73f1ffba5b5c49049bec7a801ca937ca",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 167: Loss 0.23999999463558197\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.45 F1: 0.886 R: 0.897 P: 0.876 D: 0.639 H: 0.42 Error: 9.042\n",
      "Saving model with 0.6386500792326983\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 168, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "3b5bbc36c8b8451ba5380a721acf0841",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 168: Loss 0.23899999260902405\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.4 F1: 0.886 R: 0.901 P: 0.872 D: 0.648 H: 0.492 Error: 8.955\n",
      "Saving model with 0.6483618460781579\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 169, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "979dddbf47f143a982c4c2bd0ddaafa4",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 169: Loss 0.23800000548362732\n",
      "75\n",
      "all: Val loss: 0.26100000739097595 Thresh: 0.45 F1: 0.888 R: 0.908 P: 0.869 D: 0.644 H: 0.497 Error: 8.814\n",
      "Saving model with 0.6440026475889805\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 170, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5fd851869b994d95b14e71084904534a",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 170: Loss 0.23499999940395355\n",
      "75\n",
      "all: Val loss: 0.2590000033378601 Thresh: 0.45 F1: 0.887 R: 0.905 P: 0.87 D: 0.648 H: 0.481 Error: 8.812\n",
      "Saving model with 0.6475216623506055\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 171, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "6d8f0d201b89496c9f2cf04b50b26aa7",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 171: Loss 0.25\n",
      "75\n",
      "all: Val loss: 0.2630000114440918 Thresh: 0.45 F1: 0.881 R: 0.882 P: 0.879 D: 0.628 H: 0.479 Error: 9.826\n",
      "Saving model with 0.6277056734345834\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 172, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "5d3f7acae4ae4c63b7bed571016f6d5f",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 172: Loss 0.23800000548362732\n",
      "75\n",
      "all: Val loss: 0.25999999046325684 Thresh: 0.4 F1: 0.888 R: 0.903 P: 0.874 D: 0.649 H: 0.46 Error: 9.024\n",
      "Saving model with 0.6493770923196042\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 173, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "8b69a765956e4af5936e2a2f7315f825",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch 173: Loss 0.23800000548362732\n",
      "75\n",
      "all: Val loss: 0.2619999945163727 Thresh: 0.45 F1: 0.885 R: 0.894 P: 0.875 D: 0.639 H: 0.47 Error: 9.412\n",
      "Saving model with 0.6392583627311577\n",
      "[1104, 548, 548, 347, 355, 344, 365, 320, 853]\n",
      "4784\n",
      "starting epoch 174, alpha: 0.33, beta: 0.0 drop: 0.8\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "e6a794eaf8184b8a8b052b3767d55d0e",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=238), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-96-25dbbf7f481e>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     54\u001b[0m                                      \u001b[0malpha\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mal\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     55\u001b[0m                                      \u001b[0mbeta_\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mbe\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 56\u001b[0;31m                                      \u001b[0mft_lr\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mft_learning_rate\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     57\u001b[0m                                      })\n\u001b[1;32m     58\u001b[0m         \u001b[0mlosses\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mtr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36mrun\u001b[0;34m(self, fetches, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m    927\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    928\u001b[0m       result = self._run(None, fetches, feed_dict, options_ptr,\n\u001b[0;32m--> 929\u001b[0;31m                          run_metadata_ptr)\n\u001b[0m\u001b[1;32m    930\u001b[0m       \u001b[0;32mif\u001b[0m \u001b[0mrun_metadata\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    931\u001b[0m         \u001b[0mproto_data\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mtf_session\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mTF_GetBuffer\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrun_metadata_ptr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_run\u001b[0;34m(self, handle, fetches, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m   1150\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mfinal_fetches\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0mfinal_targets\u001b[0m \u001b[0;32mor\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mhandle\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0mfeed_dict_tensor\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1151\u001b[0m       results = self._do_run(handle, final_targets, final_fetches,\n\u001b[0;32m-> 1152\u001b[0;31m                              feed_dict_tensor, options, run_metadata)\n\u001b[0m\u001b[1;32m   1153\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1154\u001b[0m       \u001b[0mresults\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_do_run\u001b[0;34m(self, handle, target_list, fetch_list, feed_dict, options, run_metadata)\u001b[0m\n\u001b[1;32m   1326\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mhandle\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1327\u001b[0m       return self._do_call(_run_fn, feeds, fetches, targets, options,\n\u001b[0;32m-> 1328\u001b[0;31m                            run_metadata)\n\u001b[0m\u001b[1;32m   1329\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1330\u001b[0m       \u001b[0;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_do_call\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0m_prun_fn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeeds\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetches\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_do_call\u001b[0;34m(self, fn, *args)\u001b[0m\n\u001b[1;32m   1332\u001b[0m   \u001b[0;32mdef\u001b[0m \u001b[0m_do_call\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1333\u001b[0m     \u001b[0;32mtry\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1334\u001b[0;31m       \u001b[0;32mreturn\u001b[0m \u001b[0mfn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m*\u001b[0m\u001b[0margs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1335\u001b[0m     \u001b[0;32mexcept\u001b[0m \u001b[0merrors\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mOpError\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1336\u001b[0m       \u001b[0mmessage\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mcompat\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mas_text\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmessage\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_run_fn\u001b[0;34m(feed_dict, fetch_list, target_list, options, run_metadata)\u001b[0m\n\u001b[1;32m   1317\u001b[0m       \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_extend_graph\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1318\u001b[0m       return self._call_tf_sessionrun(\n\u001b[0;32m-> 1319\u001b[0;31m           options, feed_dict, fetch_list, target_list, run_metadata)\n\u001b[0m\u001b[1;32m   1320\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1321\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_prun_fn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages/tensorflow/python/client/session.py\u001b[0m in \u001b[0;36m_call_tf_sessionrun\u001b[0;34m(self, options, feed_dict, fetch_list, target_list, run_metadata)\u001b[0m\n\u001b[1;32m   1405\u001b[0m     return tf_session.TF_SessionRun_wrapper(\n\u001b[1;32m   1406\u001b[0m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_session\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0moptions\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtarget_list\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1407\u001b[0;31m         run_metadata)\n\u001b[0m\u001b[1;32m   1408\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1409\u001b[0m   \u001b[0;32mdef\u001b[0m \u001b[0m_call_tf_sessionprun\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mhandle\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfeed_dict\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfetch_list\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "### import scipy\n",
    "best_val = 0.5\n",
    "fine_tune = False\n",
    "countries['all'] = [0, len(test_x)]\n",
    "ft_epochs = 0\n",
    "ft_learning_rate = 5e-3\n",
    "\n",
    "\n",
    "\n",
    "ft_e = 0\n",
    "for i in range(78, 250):\n",
    "    ft_e += 1\n",
    "    al = np.min( [0.01 * (i - 1), 0.33] )\n",
    "    be = 0.0\n",
    "    test_al = 0.33 if al < 0.8 else al\n",
    "    if fine_tune == True:\n",
    "        op = ft_op\n",
    "        ft_epochs += 1\n",
    "        if ft_epochs % 40 == 0:\n",
    "            ft_learning_rate /= 2\n",
    "            print(\"DIVIDING LR\")\n",
    "        print(\"FINE TUNING WITH {} LR\".format(ft_learning_rate))\n",
    "    else:\n",
    "        op = op = train_op\n",
    "        \n",
    "    train_ids = [x for x in range(len(train_y))]\n",
    "    randomize = equibatch(train_ids)\n",
    "    print(f\"starting epoch {i}, alpha: {al}, beta: {be} drop: {np.max((1. - (i*0.0075), 0.80))}\")\n",
    "    \n",
    "    loss = train_loss\n",
    "    BATCH_SIZE = 20\n",
    "    test_ids = [x for x in range(0, len(test_x))]\n",
    "    losses = []\n",
    "    \n",
    "    for k in tnrange(int(len(randomize) // BATCH_SIZE)):\n",
    "        rmax_epoch, dmax_epoch, rmin_epoch = calc_renorm_params(i, len(train_y), 20, k)\n",
    "        if k % 10 == 0:\n",
    "            sleep(1.75)\n",
    "        batch_ids = randomize[k*BATCH_SIZE:(k+1)*BATCH_SIZE]\n",
    "        x_batch, y_batch = augment_batch(batch_ids, BATCH_SIZE)\n",
    "        x_median_input = calc_median_input(x_batch)\n",
    "        opt, tr = sess.run([op, loss],\n",
    "                          feed_dict={inp: x_batch,\n",
    "                                     inp_median: x_median_input,\n",
    "                                     length: np.full((BATCH_SIZE, 1), 12),\n",
    "                                     labels: y_batch,\n",
    "                                     is_training: True,\n",
    "                                     clipping_params['rmax']: rmax_epoch,\n",
    "                                     clipping_params['rmin']: rmin_epoch,\n",
    "                                     clipping_params['dmax']: dmax_epoch,\n",
    "                                     loss_weight: 1.7, # global: 2.0, LAC: 1.75\n",
    "                                     #loss_weight: np.max([1.9 - (i * 0.015), 1.3]), \n",
    "                                     keep_rate: np.max((1. - (i * 0.0075), 0.9)),\n",
    "                                     alpha: al,\n",
    "                                     beta_: be,\n",
    "                                     ft_lr: ft_learning_rate,\n",
    "                                     })\n",
    "        losses.append(tr)\n",
    "    \n",
    "    print(f\"Epoch {i}: Loss {np.around(np.mean(losses[:-1]), 3)}\")\n",
    "    val_loss, f1, error, haus, dice = calculate_metrics('all', al = test_al, canopy_thresh = 75)\n",
    "    train_losses.append(np.mean(losses[:-1]))\n",
    "    test_losses.append(val_loss)\n",
    "    f1s.append(f1)\n",
    "    dices.append(dice)\n",
    "    errors.append(error)\n",
    "    hausdorff.append(haus)\n",
    "    if f1 > (best_val - 0.02):\n",
    "        print(\"Saving model with {}\".format(dice))\n",
    "        os.mkdir(\"../models/unet-final-data/{}-{}-{}/\".format(str(i), str(f1*100)[:2], str(f1*100)[3]))\n",
    "        save_path = saver.save(sess, \"../models/unet-final-data/{}-{}-{}/model\".format(str(i), str(f1*100)[:2], str(f1*100)[3]))\n",
    "        if f1 > best_val:\n",
    "            best_val = f1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 286,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "75\n",
      "all: Val loss: 0.25699999928474426 Thresh: 0.4 F1: 0.894 R: 0.911 P: 0.878 D: 0.642 H: 0.494 Error: 8.384\n"
     ]
    }
   ],
   "source": [
    "val_loss, f1, error, haus, dice = calculate_metrics('all', al = test_al, canopy_thresh = 75)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 287,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "100\n",
      "all: Val loss: 0.125 Thresh: 0.4 F1: 0.969 R: 0.974 P: 0.964 D: 0.734 H: 0.362 Error: 7.585\n"
     ]
    }
   ],
   "source": [
    "val_loss, f1, error, haus, dice = calculate_metrics('all', al = test_al, canopy_thresh = 100)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# 12 time step, 16, 8, 6, 4, 8, 16, 14 UNET \n",
    "#Epoch 100: Loss 0.25600001215934753\n",
    "#all: Val loss: 0.2709 Thresh: 0.5 F1: 0.878 R: 0.9 P: 0.857 D: 0.8044324218159632 H: 0.511 Error: 8.829\n",
    "\n",
    "\n",
    "\n",
    "# 12 time step, ibid, no sse in convGRU\n",
    "#Epoch 67: Loss 0.26600000262260437\n",
    "#all: Val loss: 0.2750 Thresh: 0.4 F1: 0.87 R: 0.882 P: 0.858 D: 0.717465778 H: 0.559 Error: 10.59\n",
    "\n",
    "\n",
    "# Mean concat\n",
    "#Epoch 51: Loss 0.2709999978542328\n",
    "# all: Val loss: 0.272000 Thresh: 0.45 F1: 0.878 R: 0.899 P: 0.857 D: 0.764088 H: 0.584 Error: 9.635\n",
    "\n",
    "# Avbove, 5e-3\n",
    "# Epoch 165: Loss 0.24699999392032623\n",
    "#all: Val loss: 0.2590 Thresh: 0.4 F1: 0.887 R: 0.91 P: 0.866 D: 0.7396746 H: 0.499 Error: 7.854\n",
    "# Updated test data\n",
    "#all: Val loss: 0.2560 Thresh: 0.4 F1: 0.89 R: 0.917 P: 0.866 D: 0.6593579 H: 0.453 Error: 7.809"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Model validation and sanity checks\n",
    "\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "preds2 = np.concatenate(preds).flatten()\n",
    "trues2 = np.concatenate(trues).flatten()\n",
    "tp = preds2 * trues2\n",
    "fn = [1 if x > y else 0 for (x, y) in zip(trues2, preds2)]\n",
    "fp = [1 if y > x else 0 for (x, y) in zip(trues2, preds2)]\n",
    "tn = (len(test_y) * 196) - np.sum(tp) - np.sum(fn) - np.sum(fp)\n",
    "print(\"TP {}, FN {}, FP {}, TN {}\".format(np.sum(tp), sum(fn), np.sum(fp), tn))\n",
    "print(len(preds2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "tps = []\n",
    "fns = []\n",
    "fps = []\n",
    "for i in range(0, len(test_y)*196, 196):\n",
    "    tps.append(np.sum(tp[i:i+196]))\n",
    "    fns.append(np.sum(fn[i:i+196]))\n",
    "    fps.append(np.sum(fp[i:i+196]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sklearn.metrics import f1_score\n",
    "\n",
    "true_canopy = []\n",
    "error_canopy = []\n",
    "pred_canopy = []\n",
    "f1_hard = []\n",
    "tp_softs = []\n",
    "fp_softs = []\n",
    "fn_softs = []\n",
    "for i in range(len(trues)):\n",
    "    true_canopy.append(np.sum(trues[i]) / 1.96)\n",
    "    error_canopy.append(abs(np.sum(preds[i]) - np.sum(trues[i])) / 1.96)\n",
    "    pred_canopy.append(np.sum(preds[i]) / 1.96)\n",
    "    f1_hard.append(f1_score(trues[i], preds[i]))\n",
    "    tp_soft, fp_soft, fn_soft = compute_f1_score_at_tolerance(np.array(trues[i].reshape((14, 14))),\n",
    "                                                 np.array(preds[i].reshape((14, 14))))\n",
    "    tp_softs.append(tp_soft)\n",
    "    fp_softs.append(fp_soft)\n",
    "    fn_softs.append(fn_soft)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "precision = np.sum(tp_softs) / (np.sum(tp_softs) + np.sum(fp_softs))\n",
    "recall = np.sum(tp_softs) / (np.sum(tp_softs) + np.sum(fn_softs))\n",
    "print(precision, recall, np.mean(error_canopy), np.mean(true_canopy), np.mean(pred_canopy))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "plot_ids_loaded = np.load(\"../data/metrics/plotids.npy\")\n",
    "plot_ids_loaded = np.delete(plot_ids_loaded, outliers, 0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "metrics = pd.DataFrame({'true': true_canopy,\n",
    "                        'pred': pred_canopy,\n",
    "                        'f1_hard': f1_hard,\n",
    "                        'error': error_canopy,\n",
    "                        'tp': tps,\n",
    "                        'fp': fps,\n",
    "                        'fn': fns,\n",
    "                        'tp_soft': tp_softs,\n",
    "                        'fp_soft': fp_softs,\n",
    "                        'fn_soft': fn_softs,\n",
    "                       })\n",
    "\n",
    "res = map(lambda x: int(math.floor(np.min([x, 90]) / 10.0)) * 10, true_canopy)\n",
    "res = [x for x in res]\n",
    "metrics['group'] = res\n",
    "metrics['model'] = 'proposed'\n",
    "#metrics['slope'] = slopes\n",
    "metrics['plot_id'] = plot_ids_loaded\n",
    "metrics.to_csv(\"../data/metrics/proposed-sample.csv\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "metrics = pd.read_csv(\"../data/metrics/proposed-sample.csv\")\n",
    "continents = pd.read_csv(\"../data/latlongs/test_continents.csv\")\n",
    "continents = continents.join(metrics, how = 'inner')\n",
    "continents.groupby(\"CONTINENT\").mean()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "hard_precisions = metrics.groupby('group').apply(lambda x: (np.sum(x.tp) / np.sum(x.tp + x.fp)))\n",
    "hard_recalls = metrics.groupby('group').apply(lambda x: (np.sum(x.tp) / np.sum(x.tp + x.fn)))\n",
    "errors = metrics.groupby('group').apply(lambda x: np.mean(x.error))\n",
    "hard_f1 = 2 *  ((hard_precisions * hard_recalls) / (hard_precisions + hard_recalls))\n",
    "\n",
    "precisions = metrics.groupby('group').apply(lambda x: (np.sum(x.tp_soft) / np.sum(x.tp_soft + x.fp_soft)))\n",
    "recalls = metrics.groupby('group').apply(lambda x: (np.sum(x.tp_soft) / np.sum(x.tp_soft + x.fn_soft)))\n",
    "soft_f1 = 2 *  ((precisions * recalls) / (precisions + recalls))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "new_metrics = pd.DataFrame({'group': [x for x in range(0, 100, 10)],\n",
    "                            'hard_rec': hard_recalls,\n",
    "                            'soft_rec': recalls,\n",
    "                            'hard_prec': hard_precisions,\n",
    "                            'soft_prec': precisions,\n",
    "                            'hard_f1': hard_f1,\n",
    "                            'soft_f1': soft_f1,\n",
    "                            'error': errors,\n",
    "                            'model': 'proposed'\n",
    "                           })\n",
    "\n",
    "#new_metrics.to_csv(\"../data/metrics/proposed.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Prediction visualizations"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7b77b1582bdf43c789e18169305bba0b",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=1050), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    }
   ],
   "source": [
    "test_ids = [x for x in range(len(test_x))]\n",
    "diffs = []\n",
    "for idx in tnrange(len(test_ids)):\n",
    "    x_input = test_x[idx].reshape(1, 12, IMAGE_SIZE, IMAGE_SIZE, n_bands)\n",
    "    median_input = calc_median_input(x_input)\n",
    "    y = sess.run([fm], feed_dict={inp: x_input,\n",
    "                                  inp_median: median_input,\n",
    "                                  length: np.full((1, 1), 12),\n",
    "                                  is_training: False,\n",
    "                                  clipping_params['rmax']: rmax_epoch,\n",
    "                                  clipping_params['rmin']: rmin_epoch,\n",
    "                                  clipping_params['dmax']: dmax_epoch,\n",
    "                                  })\n",
    "    y = np.array(y).reshape(14, 14)\n",
    "    y[np.where(y > 0.5)] = 1.0\n",
    "    y[np.where(y < 0.5)] = 0.\n",
    "    diff = np.sum(y) - np.sum(test_y[idx])\n",
    "    diffs.append(diff)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "start = 0\n",
    "\n",
    "\n",
    "test_ids = [x for x in range(0, len(test_x))]\n",
    "\n",
    "def multiplot(matrices, nrows = 2, ncols = 4):\n",
    "    '''Docstring\n",
    "    \n",
    "         Parameters:\n",
    "          matrices (list):\n",
    "          nrows (int):\n",
    "          \n",
    "         Returns:\n",
    "          None\n",
    "    '''\n",
    "    fig, axs = plt.subplots(ncols=4, nrows = nrows)\n",
    "    fig.set_size_inches(20, 4*nrows)\n",
    "    to_iter = [[x for x in range(i, i + ncols + 1)] for i in range(0, nrows*ncols, ncols)]\n",
    "    for r in range(1, nrows + 1):\n",
    "        min_i = min(to_iter[r-1])\n",
    "        max_i = max(to_iter[r-1])\n",
    "        for i, matrix in enumerate(matrices[min_i:max_i]):\n",
    "            sns.heatmap(data = matrix, ax = axs[r - 1, i], vmin = 0, vmax = 0.9)\n",
    "            axs[r - 1, i].set_xlabel(\"\")\n",
    "            axs[r - 1, i].set_ylabel(\"\")\n",
    "            axs[r - 1, i].set_yticks([])\n",
    "            axs[r - 1, i].set_xticks([])\n",
    "    plt.show\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "def identify_alignment(true, pred, wsize = 3, difference = 0.2):\n",
    "    '''Docstring\n",
    "    \n",
    "         Parameters:\n",
    "          true (arr):\n",
    "          pred (arr):\n",
    "          wsize (int):\n",
    "          difference (float):\n",
    "          \n",
    "         Returns:\n",
    "          None\n",
    "    '''\n",
    "    n_single_trees = 0\n",
    "    for x in range(1, true.shape[0] - 1, 1):\n",
    "        for y in range(1, true.shape[1] - 1, 1):\n",
    "            wind_true = true[x-1:x+2, y-1:y+2]\n",
    "            wind_pred = pred[x-1:x+2, y-1:y+2]\n",
    "            if wind_true[1, 1] == 1:\n",
    "                if np.sum(wind_true) == 1:\n",
    "                    n_single_trees += 1\n",
    "                    pred_place = np.argmax(wind_pred.flatten())\n",
    "                    diff = wind_pred.flatten()[pred_place] - wind_pred.flatten()[4]\n",
    "                    if pred_place != 4:\n",
    "                        if diff > difference:\n",
    "                            x_lv = pred_place // 3\n",
    "                            y_lv = pred_place % 3\n",
    "                            print(x_lv, y_lv)\n",
    "                            proposed = wind_true[x_lv - 1:x_lv+2, y_lv-1:y_lv+2]\n",
    "                            if np.sum(proposed) == 0:\n",
    "                                print(\"There is a missed position at {} x, {} y: {}\".format(x, y, diff))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "def aggregate_maxes(y_true, y_pred):\n",
    "    y_out = np.copy(y_pred)\n",
    "    change_map = np.zeros((14, 14))\n",
    "    for x in range(y_true.shape[0]):\n",
    "        for y in range(y_true.shape[0]):\n",
    "            min_x = np.max([0, x-1])\n",
    "            min_y = np.max([0, y-1])\n",
    "            max_y = np.min([y_true.shape[1], y+2])\n",
    "            max_x = np.min([y_true.shape[1], x+2])\n",
    "            \n",
    "            y_true_sum = np.sum(y_true[min_x:max_x, min_y:max_y])\n",
    "            y_pred_max = np.max(y_pred[min_x:max_x, min_y:max_y])\n",
    "            y_pred_min = np.min(y_pred[min_x:max_x, min_y:max_y])\n",
    "            \n",
    "    \n",
    "            if y_true[x, y] == 1: # if positive and unsure\n",
    "                if y_true_sum < 9: # if edge and there is a candidate\n",
    "                    diffs = y_pred_max - y_pred[x, y]\n",
    "                    percentage = np.min([1/(1 + np.exp(-(diffs * 10 - 5))), 0.5])\n",
    "                    y_out[x, y] += percentage\n",
    "                    change_map[x, y] = percentage\n",
    "            if y_true[x, y] == 0:# and y_pred[x, y] > 0.75: # if negative and unsure\n",
    "                if y_true_sum > 0: #and y_pred_min < 0.25: # if edge and there is a candidate\n",
    "                    diffs = y_pred[x, y] - y_pred_min\n",
    "                    percentage = np.min([1/(1 + np.exp(-(diffs * 10 - 5))), 0.5])\n",
    "                    y_out[x, y] -= percentage #= np.min(y_pred[min_x:max_x, min_y:max_y])\n",
    "                    change_map[x, y] = -percentage\n",
    "    return y_out, change_map\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 282,
   "metadata": {},
   "outputs": [],
   "source": [
    "start = 915"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 283,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.8806544754571703\n",
      "915 136776823 40.65921111618777 15.494347435627501\n",
      "916 136776824 55.84752540858844 56.6977383169849\n",
      "917 136776825 51.236828204193955 11.4827261356391\n",
      "918 136776826 55.619810147588694 47.59515071264028\n",
      "919 136776828 53.28481247803196 33.638717801234\n",
      "920 136776830 45.96629317195754 40.74055025242211\n",
      "921 136776831 49.027365512194564 0.481398416463779\n",
      "922 136776832 61.878496384369285 23.04309316050931\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 1440x1152 with 32 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "from sklearn.metrics import f1_score\n",
    "print(start/len(test_ids))\n",
    "#test_ids = sorted(test_ids)\n",
    "#test_ids = np.argwhere(abs(np.array(diffs)) > 25)\n",
    "matrix_ids = [test_ids[start], test_ids[start + 1], test_ids[start + 2], test_ids[start + 3],\n",
    "              test_ids[start + 4], test_ids[start + 5], test_ids[start + 6], test_ids[start + 7]]\n",
    "\n",
    "\n",
    "preds = []\n",
    "trues = []\n",
    "for i in matrix_ids:\n",
    "    idx = i\n",
    "    #print(i)\n",
    "    x_input = test_x[idx].reshape(1, 12, IMAGE_SIZE, IMAGE_SIZE, n_bands)\n",
    "    median_input = calc_median_input(x_input)\n",
    "    y = sess.run([fm], feed_dict={inp: x_input,\n",
    "                                  inp_median: median_input,\n",
    "                                  length: np.full((1, 1), 12),\n",
    "                                  is_training: False,\n",
    "                                  clipping_params['rmax']: rmax_epoch,\n",
    "                                  clipping_params['rmin']: rmin_epoch,\n",
    "                                  clipping_params['dmax']: dmax_epoch,\n",
    "                                  })\n",
    "    y = np.array(y).reshape(14, 14)\n",
    "    #y, mapshape = aggregate_maxes(test_y[idx], y)\n",
    "    preds.append(y)\n",
    "    y2 = np.copy(y)\n",
    "    #print(idx, list(test_data.iloc[i, 0])[0],\n",
    "    #      list(test_data.iloc[i, 1])[0],\n",
    "    #      list(test_data.iloc[i, 2])[0], diffs[i[0]])\n",
    "    print(idx, test_data.iloc[i, 0],\n",
    "          test_data.iloc[i, 1],\n",
    "          test_data.iloc[i, 2])#, diffs[i[0]])\n",
    "    true = test_y[idx].reshape(14, 14)\n",
    "    trues.append(true)\n",
    "\n",
    "\n",
    "to_plot = trues[0:4] + preds[0:4] + trues[4:] + preds[4:]\n",
    "\n",
    "multiplot(to_plot, nrows = 4, ncols = 4)\n",
    "\n",
    "\n",
    "start = start + 8 \n",
    "\n",
    "# 123, 334, 680, 875, 917, 950"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 244,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[201, 604, 657, 659, 666, 777, 919]"
      ]
     },
     "execution_count": 244,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "7f0911aa16044c63ab757fd6efcbf4c2",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(IntProgress(value=0, max=4784), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "train_ids = [x for x in range(len(train_y))]\n",
    "diffs = []\n",
    "for idx in tnrange(len(train_ids)):\n",
    "    x_input = train_x[idx].reshape(1, 12, IMAGE_SIZE, IMAGE_SIZE, n_bands)\n",
    "    median_input = calc_median_input(x_input)\n",
    "    y = sess.run([fm], feed_dict={inp: x_input,\n",
    "                                  inp_median: median_input,\n",
    "                                  length: train_l[idx].reshape(1, 1),\n",
    "                                  is_training: False,\n",
    "                                  clipping_params['rmax']: rmax_epoch,\n",
    "                                  clipping_params['rmin']: rmin_epoch,\n",
    "                                  clipping_params['dmax']: dmax_epoch,\n",
    "                                  })\n",
    "    y = np.array(y).reshape(14, 14)\n",
    "    y[np.where(y > 0.5)] = 1.0\n",
    "    y[np.where(y < 0.5)] = 0.\n",
    "    diff = np.sum(y) - np.sum(train_y[idx])\n",
    "    diffs.append(diff)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 252,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_ids = [x for x in range(train_x.shape[0])]\n",
    "train_ids = sorted(train_ids)\n",
    "start = 200\n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 253,
   "metadata": {
    "scrolled": false
   },
   "outputs": [
    {
     "ename": "IndexError",
     "evalue": "index 200 is out of bounds for axis 0 with size 96",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-253-2b69fd1c3e39>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      4\u001b[0m                                        abs(np.array(diffs)) < 200))\n\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m matrix_ids = [train_ids[start], train_ids[start + 1], train_ids[start + 2],\n\u001b[0m\u001b[1;32m      7\u001b[0m              \u001b[0mtrain_ids\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mstart\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m3\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mtrain_ids\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mstart\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m4\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      8\u001b[0m              train_ids[start + 5], train_ids[start + 6], train_ids[start + 7]]\n",
      "\u001b[0;31mIndexError\u001b[0m: index 200 is out of bounds for axis 0 with size 96"
     ]
    }
   ],
   "source": [
    "##matrix_ids = [70, 139, 456, 630, 718, 800, 835, 1101]\n",
    "\n",
    "train_ids = np.argwhere(np.logical_and(abs(np.array(diffs)) >= 40,\n",
    "                                       abs(np.array(diffs)) < 200))\n",
    "\n",
    "matrix_ids = [train_ids[start], train_ids[start + 1], train_ids[start + 2],\n",
    "             train_ids[start + 3], train_ids[start + 4],\n",
    "             train_ids[start + 5], train_ids[start + 6], train_ids[start + 7]]\n",
    "#matrix_ids = to_update[-8:]\n",
    "preds = []\n",
    "trues = []\n",
    "#print(start//4)\n",
    "print(matrix_ids)\n",
    "for i in matrix_ids:\n",
    "    idx = i\n",
    "    x_input = train_x[idx].reshape(1, 12, IMAGE_SIZE, IMAGE_SIZE, n_bands)\n",
    "    median_input = calc_median_input(x_input)\n",
    "    y = sess.run([fm], feed_dict={inp: x_input,\n",
    "                                  inp_median: median_input,\n",
    "                                  length: np.full((1, 1), 12),\n",
    "                                  is_training: False,\n",
    "                                  clipping_params['rmax']: rmax_epoch,\n",
    "                                  clipping_params['rmin']: rmin_epoch,\n",
    "                                  clipping_params['dmax']: dmax_epoch,\n",
    "                                    })\n",
    "    y = np.array(y).reshape(14, 14)\n",
    "    \n",
    "    #y, _ = aggregate_maxes(train_y[idx], y)\n",
    "    \n",
    "    preds.append(y)\n",
    "    true = train_y[idx].reshape(14, 14)\n",
    "    \n",
    "    print(idx, (list(data.iloc[idx, 1])[0], list(data.iloc[idx, 2])[0]), diffs[i[0]])\n",
    "    #print(idx, test_data.iloc[i, 0],\n",
    "    #      test_data.iloc[i, 1],\n",
    "    #      test_data.iloc[i, 2], diffs[i[0]])\n",
    "    trues.append(true)\n",
    "    \n",
    "start += 8\n",
    "\n",
    "to_plot = trues[0:4] + preds[0:4] + trues[4:] + preds[4:]\n",
    "multiplot(to_plot, nrows = 4, ncols = 4)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "policy-toolkit",
   "language": "python",
   "name": "policy-toolkit"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
